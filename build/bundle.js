
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    function create_animation(node, from, fn, params) {
        if (!from)
            return noop;
        const to = node.getBoundingClientRect();
        if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
            return noop;
        const { delay = 0, duration = 300, easing = identity, 
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = now() + delay, 
        // @ts-ignore todo:
        end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
        let running = true;
        let started = false;
        let name;
        function start() {
            if (css) {
                name = create_rule(node, 0, 1, duration, delay, easing, css);
            }
            if (!delay) {
                started = true;
            }
        }
        function stop() {
            if (css)
                delete_rule(node, name);
            running = false;
        }
        loop(now => {
            if (!started && now >= start_time) {
                started = true;
            }
            if (started && now >= end) {
                tick(1, 0);
                stop();
            }
            if (!running) {
                return false;
            }
            if (started) {
                const p = now - start_time;
                const t = 0 + 1 * easing(p / duration);
                tick(t, 1 - t);
            }
            return true;
        });
        start();
        tick(0, 1);
        return stop;
    }
    function fix_position(node) {
        const style = getComputedStyle(node);
        if (style.position !== 'absolute' && style.position !== 'fixed') {
            const { width, height } = style;
            const a = node.getBoundingClientRect();
            node.style.position = 'absolute';
            node.style.width = width;
            node.style.height = height;
            add_transform(node, a);
        }
    }
    function add_transform(node, a) {
        const b = node.getBoundingClientRect();
        if (a.left !== b.left || a.top !== b.top) {
            const style = getComputedStyle(node);
            const transform = style.transform === 'none' ? '' : style.transform;
            node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
        block.f();
        outro_and_destroy_block(block, lookup);
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.31.2' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    // convert rgb to hsl
    const rgbToHsl = (c) => {
      var r = c[0]/255, g = c[1]/255, b = c[2]/255;
      var max = Math.max(r, g, b), min = Math.min(r, g, b);
      var h, s, l = (max + min) / 2;

      if(max == min) {
        h = s = 0; // achromatic
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return new Array(h * 360, s * 100, l * 100);
    };

    // nes color palette
    const nespalette = [
      {hex: '00', rgb: [124,124,124]},
      {hex: '01', rgb: [0,0,252]},
      {hex: '02', rgb: [0,0,188]},
      {hex: '03', rgb: [68,40,188]},
      {hex: '04', rgb: [148,0,132]},
      {hex: '05', rgb: [168,0,32]},
      {hex: '06', rgb: [168,16,0]},
      {hex: '07', rgb: [136,20,0]},
      {hex: '08', rgb: [80,48,0]},
      {hex: '09', rgb: [0,120,0]},
      {hex: '0A', rgb: [0,104,0]},
      {hex: '0B', rgb: [0,88,0]},
      {hex: '0C', rgb: [0,64,88]},
      {hex: '0D', rgb: [0,0,0]},
      {hex: '0E', rgb: [0,0,0]},
      {hex: '0F', rgb: [0,0,0]},
      {hex: '10', rgb: [188,188,188]},
      {hex: '11', rgb: [0,120,248]},
      {hex: '12', rgb: [0,88,248]},
      {hex: '13', rgb: [104,68,252]},
      {hex: '14', rgb: [216,0,204]},
      {hex: '15', rgb: [228,0,88]},
      {hex: '16', rgb: [248,56,0]},
      {hex: '17', rgb: [228,92,16]},
      {hex: '18', rgb: [172,124,0]},
      {hex: '19', rgb: [0,184,0]},
      {hex: '1A', rgb: [0,168,0]},
      {hex: '1B', rgb: [0,168,68]},
      {hex: '1C', rgb: [0,136,136]},
      {hex: '1D', rgb: [0,0,0]},
      {hex: '1E', rgb: [0,0,0]},
      {hex: '1F', rgb: [0,0,0]},
      {hex: '20', rgb: [248,248,248]},
      {hex: '21', rgb: [60,188,252]},
      {hex: '22', rgb: [104,136,252]},
      {hex: '23', rgb: [152,120,248]},
      {hex: '24', rgb: [248,120,248]},
      {hex: '25', rgb: [248,88,152]},
      {hex: '26', rgb: [248,120,88]},
      {hex: '27', rgb: [252,160,68]},
      {hex: '28', rgb: [248,184,0]},
      {hex: '29', rgb: [184,248,24]},
      {hex: '2A', rgb: [88,216,84]},
      {hex: '2B', rgb: [88,248,152]},
      {hex: '2C', rgb: [0,232,216]},
      {hex: '2D', rgb: [120,120,120]},
      {hex: '2E', rgb: [0,0,0]},
      {hex: '2F', rgb: [0,0,0]},
      {hex: '30', rgb: [252,252,252]},
      {hex: '31', rgb: [164,228,252]},
      {hex: '32', rgb: [184,184,248]},
      {hex: '33', rgb: [216,184,248]},
      {hex: '34', rgb: [248,184,248]},
      {hex: '35', rgb: [248,164,192]},
      {hex: '36', rgb: [240,208,176]},
      {hex: '37', rgb: [252,224,168]},
      {hex: '38', rgb: [248,216,120]},
      {hex: '39', rgb: [216,248,120]},
      {hex: '3A', rgb: [184,248,184]},
      {hex: '3B', rgb: [184,248,216]},
      {hex: '3C', rgb: [0,252,252]},
      {hex: '3D', rgb: [216,216,216]},
      {hex: '3E', rgb: [0,0,0]},
      {hex: '3F', rgb: [0,0,0]},
    ];

    // sort after hue
    const sorted = nespalette.map((c, i) => ({rgb: rgbToHsl(c.rgb), index: i}))
      .sort((a, b) => b.rgb[0] - a.rgb[0] || a.rgb[2] - b.rgb[2])
      .map((data) => nespalette[data.index]);


    class NESColor{
      constructor(hex, rgb){
        this.hex = hex;
        this.rgb = rgb;
        Object.freeze(this);
      }
    }

    // create color objects to be easier to deal with throughout the application
    const mappedColorList = sorted.map(color => new NESColor(color.hex, color.rgb));

    // console store
    const log = (() => {
      const store = writable([]);
      const { subscribe, update } = store;
      return {
        subscribe,
        push(e){
          if(e instanceof ErrorEvent){
            const d = new Date();
            const date = `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}:${String(d.getSeconds()).padStart(2, '0')}`;
            e.date = date;
            update((store) => {
              // don't let the array get to big so let's reset it  
              // when it reaches a size of 20
              if(store.length > 20){
                store = [];
              }
              store.push(e);
              return store;
            });
          }
        }
      }
    })();

    /*
      create a random uuid
      @param Int(default: 4) (how many parts)
      @return String

      @usage:
      const id = uuid(6);
    */
    const uuid = (p = 4) => `${Date.now().toString(36)}-${(new Array(p-1).fill(0).map(_ => (Math.random().toString(36).substr(2, 8)))).join('-')}`;


    // number -> hex
    const dec2hex = (n, p = 6) => {
      if(typeof n !== 'number'){
        throw new Error(`Invalid argument, expecting number got : [${typeof n}]`);
      }
      if(typeof p !== 'number'){
        throw new Error(`Invalid padding argument, expecting number got : [${typeof p}]`);
      }
      const hex = (n >>> 0).toString(16);
      return p ? hex.padStart(p, 0) : hex;
    };

    // constrain a value between a min, max
    // constrain(x, 0, 100);
    const constrain = (n, _min, _max) => Math.max(Math.min(n, _max), _min);

    // map one range -> another
    // map(x, 0, 100, 500, 600);
    const map = (n, start1, stop1, start2, stop2, withinBounds = true) => {
      const newval = ((n - start1)/(stop1 - start1)) * (stop2 - start2) + start2;
      if(!withinBounds){
        return newval;
      }
      return constrain(newval, start2, stop2);
    };

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }

    function flip(node, animation, params) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const scaleX = animation.from.width / node.clientWidth;
        const scaleY = animation.from.height / node.clientHeight;
        const dx = (animation.from.left - animation.to.left) / scaleX;
        const dy = (animation.from.top - animation.to.top) / scaleY;
        const d = Math.sqrt(dx * dx + dy * dy);
        const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
        return {
            delay,
            duration: is_function(duration) ? duration(d) : duration,
            easing,
            css: (_t, u) => `transform: ${transform} translate(${u * dx}px, ${u * dy}px);`
        };
    }

    /* src\_components\ToastNotifications.svelte generated by Svelte v3.31.2 */
    const file = "src\\_components\\ToastNotifications.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (33:0) {#if $notifications.length}
    function create_if_block(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*$notifications*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*notification*/ ctx[2].uuid;
    	validate_each_keys(ctx, each_value, get_each_context, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "toast-notifications svelte-jnrt3b");
    			add_location(div, file, 33, 2, 1023);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$notifications, remove*/ 1) {
    				each_value = /*$notifications*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
    				validate_each_keys(ctx, each_value, get_each_context, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(33:0) {#if $notifications.length}",
    		ctx
    	});

    	return block;
    }

    // (35:4) {#each $notifications as notification (notification.uuid)}
    function create_each_block(key_1, ctx) {
    	let div;
    	let button;
    	let svg;
    	let path;
    	let t0;
    	let p;
    	let t1_value = /*notification*/ ctx[2].message + "";
    	let t1;
    	let t2;
    	let div_data_variant_value;
    	let div_intro;
    	let div_outro;
    	let rect;
    	let stop_animation = noop;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[1](/*notification*/ ctx[2], ...args);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			p = element("p");
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(path, "d", "M12 11.293l10.293-10.293.707.707-10.293 10.293 10.293 10.293-.707.707-10.293-10.293-10.293 10.293-.707-.707 10.293-10.293-10.293-10.293.707-.707 10.293 10.293z");
    			add_location(path, file, 37, 113, 1440);
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "fill-rule", "evenodd");
    			attr_dev(svg, "clip-rule", "evenodd");
    			attr_dev(svg, "class", "svelte-jnrt3b");
    			add_location(svg, file, 37, 10, 1337);
    			attr_dev(button, "class", "svelte-jnrt3b");
    			add_location(button, file, 36, 8, 1280);
    			attr_dev(p, "class", "svelte-jnrt3b");
    			add_location(p, file, 39, 8, 1646);
    			attr_dev(div, "class", "notification svelte-jnrt3b");
    			attr_dev(div, "data-variant", div_data_variant_value = /*notification*/ ctx[2].variant);
    			add_location(div, file, 35, 6, 1128);
    			this.first = div;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			append_dev(div, t0);
    			append_dev(div, p);
    			append_dev(p, t1);
    			append_dev(div, t2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*$notifications*/ 1) && t1_value !== (t1_value = /*notification*/ ctx[2].message + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*$notifications*/ 1 && div_data_variant_value !== (div_data_variant_value = /*notification*/ ctx[2].variant)) {
    				attr_dev(div, "data-variant", div_data_variant_value);
    			}
    		},
    		r: function measure() {
    			rect = div.getBoundingClientRect();
    		},
    		f: function fix() {
    			fix_position(div);
    			stop_animation();
    			add_transform(div, rect);
    		},
    		a: function animate() {
    			stop_animation();
    			stop_animation = create_animation(div, rect, flip, {});
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				if (!div_intro) div_intro = create_in_transition(div, fly, { x: 500, duration: 300 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fly, { x: 0, duration: 300 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_outro) div_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(35:4) {#each $notifications as notification (notification.uuid)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$notifications*/ ctx[0].length && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$notifications*/ ctx[0].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$notifications*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let duration = 5000;
    const notifications = writable([]);
    const queueForDeletion = [];

    const remove = notification => {
    	notifications.update(store => store.filter(n => n !== notification));
    };

    const push = props => notifications.update(store => {
    	let item = {
    		uuid: uuid(),
    		message: `Invalid toast properties.`,
    		variant: "danger"
    	};

    	if (props.message) {
    		item = { ...item, ...props };
    	}

    	store.push(item);

    	setTimeout(
    		() => {
    			// queueForDeletion.push({ item, duration: 4000, timestamp: Date.now() });
    			remove(item);
    		},
    		duration
    	);

    	return store;
    });

    function instance($$self, $$props, $$invalidate) {
    	let $notifications;
    	validate_store(notifications, "notifications");
    	component_subscribe($$self, notifications, $$value => $$invalidate(0, $notifications = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ToastNotifications", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ToastNotifications> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (notification, _) => remove(notification);

    	$$self.$capture_state = () => ({
    		flip,
    		fly,
    		writable,
    		uuid,
    		duration,
    		notifications,
    		queueForDeletion,
    		remove,
    		push,
    		$notifications
    	});

    	return [$notifications, click_handler];
    }

    class ToastNotifications extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToastNotifications",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    // disable context menu 
    window.addEventListener('contextmenu', _ => _.preventDefault());

    window.addEventListener("error", function (e) {
      log.push(e);
      push({message: e.message, variant: 'danger'});
    });

    // for debugging. remove in production
    window.addEventListener('keydown', (e) => {
      // console.log('keydown debugging. remove in production.')
      // console.log(e.code);
    });

    /* src\_components\Artboard.svelte generated by Svelte v3.31.2 */
    const file$1 = "src\\_components\\Artboard.svelte";

    function create_fragment$1(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "content svelte-131dyyn");
    			add_location(div0, file$1, 146, 6, 4495);
    			attr_dev(div1, "class", "wrapper svelte-131dyyn");
    			add_location(div1, file$1, 145, 4, 4446);
    			attr_dev(div2, "class", "outer svelte-131dyyn");
    			add_location(div2, file$1, 144, 2, 4311);
    			attr_dev(div3, "class", "artboard svelte-131dyyn");
    			toggle_class(div3, "active", /*active*/ ctx[0]);
    			add_location(div3, file$1, 143, 0, 4228);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div1_binding*/ ctx[7](div1);
    			/*div2_binding*/ ctx[8](div2);
    			/*div3_binding*/ ctx[10](div3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div2, "mousedown", /*downHandler*/ ctx[2], true, false, false),
    					listen_dev(div2, "wheel", /*wheel_handler*/ ctx[9], false, false, false),
    					listen_dev(div3, "wheel", /*scrollEvent*/ ctx[1], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div3, "active", /*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (default_slot) default_slot.d(detaching);
    			/*div1_binding*/ ctx[7](null);
    			/*div2_binding*/ ctx[8](null);
    			/*div3_binding*/ ctx[10](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let scroll, wrapper, artboard, mouseScroll = false;

    const getCurrentOffset = () => {
    	return {
    		x: scroll.scrollLeft,
    		y: scroll.scrollTop
    	};
    };

    const centerScrollAndCanvas = () => {
    	const center = {
    		x: wrapper.offsetWidth / 2 - scroll.offsetWidth / 2,
    		y: wrapper.offsetHeight / 2 - scroll.offsetHeight / 2
    	};

    	scroll.scrollTo(center.x, center.y);
    	return center;
    };

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Artboard", slots, ['default']);
    	const dispatch = createEventDispatcher();

    	// any number other than 2 will displace the content on resize
    	let gutter = 2;

    	// lets use the resize handler as our way of knowing when the dom has 
    	// finished rendered because else we have to use the setTimeout hack 
    	// to push the centerScrollAndCanvas to the end of the queuestack
    	let firstLoad = false;

    	let active = false;
    	let { x = 0 } = $$props;
    	let { y = 0 } = $$props;

    	const resizeHandler = entries => {
    		for (const entry of entries) {
    			if (entry.contentRect) {
    				entry.contentRect;
    				const w = 4000;
    				const h = 4000;
    				const calc = { x: w * gutter, y: h * gutter };
    				wrapper.style.height = calc.y + "px";
    				wrapper.style.width = calc.x + "px";

    				// 
    				if (!firstLoad) {
    					firstLoad = true;
    					const { x: _x, y: _y } = centerScrollAndCanvas();

    					// offset the artboard
    					scroll.scrollTo(x || _x, y || _y);
    				}
    			}
    		}
    	};

    	const resizeObserver = new ResizeObserver(entries => resizeHandler(entries));
    	const scrollEvent = e => dispatch("artboardScrollEvent", e);
    	let startX, startY;
    	let scrollLeft, scrollTop;
    	let keyDowns = {};

    	const keyDown = e => {
    		e.preventDefault();
    		keyDowns[e.code] = true;
    	};

    	const keyUp = e => {
    		keyDowns[e.code] = false;
    	};

    	const downHandler = e => {
    		if (!keyDowns.Space) {
    			// NOTE: allow middle mousebutton to drag window
    			if (e.which != 2) {
    				return;
    			}
    		}

    		e.stopPropagation();
    		e.stopImmediatePropagation();

    		// if we get this far prevent default behaviour
    		e.preventDefault();

    		$$invalidate(0, active = true);
    		startX = e.pageX - scroll.offsetLeft;
    		scrollLeft = scroll.scrollLeft;
    		startY = e.pageY - scroll.offsetTop;
    		scrollTop = scroll.scrollTop;
    	};

    	const upHandler = () => {
    		$$invalidate(0, active = false);
    		dispatch("artboardOffsetEvent", { x, y });
    	};

    	const moveHandler = e => {
    		if (!keyDowns.Space) {
    			// NOTE: allow middle mousebutton to drag window
    			if (e.which != 2) {
    				return;
    			}
    		}

    		e.stopPropagation();
    		e.stopImmediatePropagation();
    		const _x = e.pageX - scroll.offsetLeft;
    		const walk = (_x - startX) * 1; //scroll-fast
    		const _y = e.pageY - scroll.offsetTop;
    		const walky = (_y - startY) * 1; //scroll-fast

    		// TODO: store x, y and move canvas to that point on scroll
    		// also change the canvas origin so it zooms at the current position
    		// the cursor is pointing at 
    		// console.log(x, y)
    		const offset = getCurrentOffset();

    		$$invalidate(3, x = offset.x);
    		$$invalidate(4, y = offset.y);
    		if (!active) return;
    		e.preventDefault();
    		scroll.scrollLeft = scrollLeft - walk;
    		scroll.scrollTop = scrollTop - walky;
    	};

    	onMount(() => {
    		document.addEventListener("keydown", keyDown);
    		document.addEventListener("keyup", keyUp);
    		resizeObserver.observe(artboard);

    		// centerScrollAndCanvas();
    		// add events 
    		// on:mousemove={moveHandler}
    		document.addEventListener("mousemove", moveHandler, true);

    		document.addEventListener("mouseup", upHandler);
    	});

    	onDestroy(() => {
    		document.removeEventListener("keydown", keyDown);
    		document.removeEventListener("keyup", keyUp);

    		// unsubscribe to all elements
    		resizeObserver.disconnect();

    		document.removeEventListener("mousemove", moveHandler, true);
    		document.removeEventListener("mouseup", upHandler);
    	});

    	const writable_props = ["x", "y"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Artboard> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			wrapper = $$value;
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			scroll = $$value;
    		});
    	}

    	const wheel_handler = e =>  e.preventDefault() ;

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			artboard = $$value;
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("x" in $$props) $$invalidate(3, x = $$props.x);
    		if ("y" in $$props) $$invalidate(4, y = $$props.y);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		scroll,
    		wrapper,
    		artboard,
    		mouseScroll,
    		getCurrentOffset,
    		centerScrollAndCanvas,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		dispatch,
    		gutter,
    		firstLoad,
    		active,
    		x,
    		y,
    		resizeHandler,
    		resizeObserver,
    		scrollEvent,
    		startX,
    		startY,
    		scrollLeft,
    		scrollTop,
    		keyDowns,
    		keyDown,
    		keyUp,
    		downHandler,
    		upHandler,
    		moveHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("gutter" in $$props) gutter = $$props.gutter;
    		if ("firstLoad" in $$props) firstLoad = $$props.firstLoad;
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    		if ("x" in $$props) $$invalidate(3, x = $$props.x);
    		if ("y" in $$props) $$invalidate(4, y = $$props.y);
    		if ("startX" in $$props) startX = $$props.startX;
    		if ("startY" in $$props) startY = $$props.startY;
    		if ("scrollLeft" in $$props) scrollLeft = $$props.scrollLeft;
    		if ("scrollTop" in $$props) scrollTop = $$props.scrollTop;
    		if ("keyDowns" in $$props) keyDowns = $$props.keyDowns;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		scrollEvent,
    		downHandler,
    		x,
    		y,
    		$$scope,
    		slots,
    		div1_binding,
    		div2_binding,
    		wheel_handler,
    		div3_binding
    	];
    }

    class Artboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { x: 3, y: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Artboard",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get x() {
    		throw new Error("<Artboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<Artboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<Artboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<Artboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
      Enum
    */
    class Enum extends Number{
      constructor(value, key){
        if(typeof value != 'number' || typeof key != 'string'){
          throw new Error(`Invalid Enumerable arguments`);
        }
        super(value);
        this.key = key;
        this.value = value;
        Object.freeze(this);
      }
    }

    /*
      EnumerableList

      Usage:
      const types = new EnumerableList('designer', 'programmer', 'webdeveloper');
      console.log(types.get('programmer'));
    */
    class EnumerableList extends Map{
      constructor(...props){
        super();
        props.forEach((key, i) => {
          if(this.has(key)){
            throw new Error(`enum key : '${key}' already exists`);
          }
          if(typeof key !== 'string'){
            throw new Error(`Invalid key. Expecting string, got : [${typeof key}](${key})`);
          }
          const EnumerableItem = new Enum(i+1, key);
          this.set(key, EnumerableItem);
        });
        Object.freeze(this);
      }
    }

    class ActionsManager{
      constructor(...actions){
        // define
        this.__actions = this.define(...actions);
        this.__binds = new Map();
      }
      define(...args){
        const list = new EnumerableList(...args);
        this.__actions = list; 
        return list;
      }
      action(key){
        if(!this.__actions.has(key)){
          throw new Error(`Action is not defined for key '${key}'`);
        } 
        return this.__actions.get(key);
      }
      register(k, f){
        if(typeof k === 'string'){
          this.register(this.action(k), f);
          return;
        }
        if(!(k instanceof Enum)){
          throw new Error(`Invalid key value '${k}'. Expecting instance of 'Enum'`);
        }
        if(this.__binds.has(k)){
          throw new Error(`Action already defined : [${k.key}]`);
        }
        if(typeof f !== 'function'){
          throw new Error(`Invalid callback function`);
        }
        this.__binds.set(k, f);
      }
      exist(value){
        return this.__binds.has(value);
      }
      call(k, ...args){
        if(typeof k === 'string'){
          this.call(this.action(k), ...args);
          return;
        }
        if(!(k instanceof Enum)){
          throw new Error(`Invalid key '${k}'. Expecting 'Enum'`);
        }
        
        if(!this.__binds.has(k)){
          throw new Error(`Action for '${k.key}'(${k}) does not exist`);
        }
        // handle promises to allow for chaining
        return new Promise((resolve, reject) => {
          try{
            resolve(this.__binds.get(k).call(null, ...args));
          }catch(error){
            reject(error.message);
          }
        });
      }
      execute(...args){
        return this.call(...args);
      }
    }

    // create actions
    const actions = new ActionsManager(
      'noop', // a blank command
      // application
      'application_log',
      'notification',
      
      // window
      'window_close',
      'window_minimize',
      'window_maximize',
      'window_toggle_fullscreen',
      'external_link',
      
      // project
      'project_create',
      'project_open',
      'project_save',
      'project_save_as',
      
      // build
      'project_build',
      'project_run',
      'project_build_run',

      // graphics general actions
      'graphics_center_artboard',

      // palettes
      'palette_clear',
      'palette_create',
      'palette_remove',
      'palette_clone_layer',
      'palette_clone_active_layer',
      'palette_make_layer_active',
      'palette_swap_layers',
      'palette_update_layer_label',
      'palette_focus_rename_active_layer',
      'palette_export',
      'palette_import',
      'palette_active_color',
      
      // spritesheets
      'spritesheet_clear',
      'spritesheet_create',
      'spritesheet_remove',
      'spritesheet_clone_layer',
      'spritesheet_clone_active_layer',
      'spritesheet_update_layer_label',
      'spritesheet_make_layer_active',
      'spritesheet_swap_layers',
      'spritesheet_focus_rename_active_layer',
      'spritesheet_zoom_in',
      'spritesheet_zoom_out',
      'spritesheet_zoom_reset',
      'spritesheet_set_active_tool',
      'spritesheet_tool_dblclick',
      'spritesheet_import',
      'spritesheet_export',
      'spritesheet_import_chr',
      'spritesheet_export_chr',
      'spritesheet_export_png',

      'spritesheet_undo',
      'spritesheet_redo',

      'spritesheet_set_selected_tile',

      // tilemaps
      'tilemap_clear',
      'tilemap_create',
      'tilemap_remove',
      'tilemap_clone_layer',
      'tilemap_clone_active_layer',
      'tilemap_update_layer_label',
      'tilemap_make_layer_active',
      'tilemap_swap_layers',
      'tilemap_focus_rename_active_layer',
      'tilemap_zoom',
      'tilemap_zoom_in',
      'tilemap_zoom_out',
      'tilemap_zoom_reset',
      'tilemap_import',
      'tilemap_export',
      'tilemap_export_nametable',
      'tilemap_export_png',

      // tool
      'tool_action',

      // themes
      'toggle_theme',
      'light_theme',
      'dark_theme',
    );

    class Hotkey{
      constructor({keys, data, groups, options}){
        if(!Array.isArray(keys)){
          throw new Error(`Invalid keys. Expecting array of string representation values.`);
        }
        this.options = {
          ...options
        };
        this.groups = groups || [];
        this.signature = keys.toString();
        this.keys = keys;
        this.data = data;
        // callbacks
        this.__on;
        this.__off;
      }
      get callbacks(){
        return {
          on: this.__on,
          off: this.__off
        };
      }
      on(fn){
        if(typeof fn != 'function'){
          throw new Error(`Invalid 'off' function`);
        }
        this.__on = fn;
        return this;
      }
      off(fn){
        if(typeof fn != 'function'){
          throw new Error(`Invalid 'off' function`);
        }
        this.__off = fn;
        return this;
      }
    }

    class HotkeysManager{
      constructor(target, options){
        this.__options = {
          once: true,
          preventDefault: true,
          ...options
        };
        this.__registeredGroups = new Set();
        this.__enabledGroups = '__all__';
        this.__commands = new Map();
        this.__target = target;
      }
      get target(){
        return this.__target;
      }
      _prepare(arr){
        if(!Array.isArray(arr)){
          throw new Error(`Invalid '_prepare' argument. Expecting array, got : [${typeof arr}]`);
        }
        // sort the keys so they always end up in the same order
        return [...arr].map(key => key.toLowerCase()).sort((a, b) => {
          return a.toLowerCase().localeCompare(b.toLowerCase());
        });
      }
      enableAllGroups(){
        this.__enabledGroups = '__all__';
      }
      enableGroups(...groups){
        return [...this.__enabledGroups = [...groups]];
      }
      _find(command){
        // get all command values
        const commands = Array.from(this.__commands.values());
        // sort after priority
        commands.sort((a, b) => b.options.priority - a.options.priority);

        // filter all commands that includes any route
        let found;
        if(Array.isArray(this.__enabledGroups)){
          found = commands.find(KeyboardShortcut => {
            return KeyboardShortcut.groups.some(g => {
              // find a match which matches groups and signature
              if(!this.__enabledGroups || this.__enabledGroups.includes(g)){
                if(KeyboardShortcut.signature == command.toString()){
                  return true;
                }
              }
            });
          });
        // check if we have the __all__ wildcard and to simply look through every single command
        }else if(this.__enabledGroups == '__all__'){
          found = commands.find(KeyboardShortcut => KeyboardShortcut.signature == command.toString());
        }

        return found;
      }
      set(keySequence, { data, groups, ...props }){
        // check to see if groups is an array and has a size of at least 1
        // else return an array with one item which is the '*' wildcard
        // this will register one global entry
        groups = Array.isArray(groups) && groups.length > 0 ? groups : ['*'];
        // track all registered groups
        groups.map(group => this.__registeredGroups.add(group));
        const keys = this._prepare(keySequence);
        const shortcut = new Hotkey({
          keys, 
          data, 
          groups,
          options: { 
            priority: props.priority || 0,
            once: props.once || this.__options.once, 
            preventDefault: props.preventDefault || this.__options.preventDefault,
          }
        });

        // iterate over all groups and store a reference 
        groups.map(group => {
          if(this.__commands.get(`${group},${shortcut.signature}`)){
            throw new Error(`Shortcut already defined : [${group},${shortcut.signature}]`);
          }
          this.__commands.set(`${group},${shortcut.signature}`, shortcut);
        });

        return shortcut;
      }
      execute(command, state){
        // loop through command sequence and dispatch the events
        // which will execute the command like one pressed the keyboard
        // handle on state
        if(state == 'on' || state == undefined){
          const keys = {};
          command.map(key => keys[key.toLowerCase()] = true);
          const e = new Event("keydown");
          e.customExecuteEvent = keys;
          this.__target.dispatchEvent(e);
        }

        // handle off state
        if(state == 'off' || state == undefined){
          // release them
          command.map(key => {
            const e = new Event("keyup");
            e.code = key;
            this.__target.dispatchEvent(e);
          });
        }
      }
      subscribe(callback){
        let keys = {};
        let prevCommand = {};
        const keyDownHandler = (e) => {
          if(e.customExecuteEvent){
            keys = e.customExecuteEvent;
          }else {
            keys[e.code.toLowerCase()] = true;
          }
          // get all active keys
          const currentCommand = this._prepare(Object.entries(keys).filter(([k, v]) => v).map(([k, v]) => k.toLowerCase()));
          // store the previous command
          const match = this._find(currentCommand);
          // if we have a match go ahead and trigger the callback
          if(match){
            if(match.options.preventDefault){
              e.preventDefault();
            }
            // prevent command from executing over and over again if the option 'once' is defined
            if(match.options.once && currentCommand.toString() == prevCommand.signature){
              return;
            }
            
            // and store the command signature
            prevCommand = {
              instance: match,
              signature: currentCommand.toString()
            };
            // if the shortcut has on callback, execute that as well
            if(typeof match.callbacks.on == 'function'){
              match.callbacks.on.call(null, { e, Hotkey: match, on: true });
            }else {
              // call the callback
              if(typeof callback == 'function'){
                callback.call(null, { e, Hotkey: match, on: true });
              }
            }

          }
        };
        const keyUpHandler = e => {
          keys[e.code.toLowerCase()] = false; 
          if(prevCommand.instance && typeof prevCommand.instance.callbacks.off == 'function'){
            prevCommand.instance.callbacks.off.call(null, { e, Hotkey: prevCommand.instance, on: false });
          }else {
            // call the callback
            if(prevCommand.instance && typeof callback == 'function'){
              callback.call(null, { e, Hotkey: prevCommand.instance, on: false });
            }
          }


          prevCommand = {};
        };
        // 'keydown' since we want to trigger, shift, control, alt etc. 'keypress' does not
        this.__target.addEventListener('keydown', keyDownHandler);
        this.__target.addEventListener('keyup', keyUpHandler);

        // return unsubscribe method which in turn returns another subscribe method
        // to resubscribe with the same options if need be. 
        return () => {
          this.__target.removeEventListener('keyup', keyUpHandler);
          this.__target.removeEventListener('keydown', keyDownHandler);
          return _ => this.subscribe(this.__target, callback);
        }
      }
    }

    // shortcuts manager 
    const manager = new HotkeysManager(window, {
      // once: false,
    });

    // subscribe to events
    manager.subscribe(({ e, Hotkey, on }) => {
      e.preventDefault();
      if(on && Hotkey.data && actions.exist(Hotkey.data.action)){
        actions.execute(Hotkey.data.action, Hotkey.data.props);
      }
    });

    // const execute command
    const executeCommand = ({ e, Hotkey, on }) => {
      e.preventDefault();
      if(on && Hotkey.data && actions.exist(Hotkey.data.action)){
        actions.execute(Hotkey.data.action);
      }
      // programmatically call keys up state
      manager.execute(Hotkey.keys, 'off');
    };

    const writable$1 = (value, fn) => {
      const store = writable(value);
      let ret = { ...store, get: _ => get_store_value(store) };
      if(fn){
        ret = { ...ret, ...(fn.call(null, { value, store, get: ret.get } || { ...ret })) };
      }
      return Object.freeze(ret);
    };

    /* src\_components\Draggable.svelte generated by Svelte v3.31.2 */

    const { window: window_1 } = globals;
    const file$2 = "src\\_components\\Draggable.svelte";
    const get_default_slot_changes = dirty => ({ focus: dirty & /*wrapper*/ 4 });
    const get_default_slot_context = ctx => ({ focus: /*func*/ ctx[11] });

    function create_fragment$2(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "draggable svelte-1262lmj");
    			set_style(div, "left", /*left*/ ctx[1] + "px");
    			set_style(div, "top", /*top*/ ctx[0] + "px");
    			add_location(div, file$2, 62, 0, 1430);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[12](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1, "mouseup", /*stop*/ ctx[4], false, false, false),
    					listen_dev(window_1, "mousemove", /*move*/ ctx[5], true, false, false),
    					listen_dev(div, "mousedown", /*start*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, wrapper*/ 516) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			}

    			if (!current || dirty & /*left*/ 2) {
    				set_style(div, "left", /*left*/ ctx[1] + "px");
    			}

    			if (!current || dirty & /*top*/ 1) {
    				set_style(div, "top", /*top*/ ctx[0] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[12](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let zindex = 9999;
    let stack = [];

    const focus = ref => {
    	ref.zindex = zindex++;
    	ref.style.setProperty("--zindex", zindex);
    };

    const add = ref => {
    	focus(ref);
    	stack.push(ref);
    };

    const remove$1 = ref => {
    	stack = stack.filter(r => r !== ref);
    };

    const getActiveWindow = () => stack.reduce((value, acc) => acc > value.zindex ? acc : value);

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Draggable", slots, ['default']);
    	let { clamp = undefined } = $$props;
    	let { top = 0 } = $$props;
    	let { left = 0 } = $$props;
    	let { minLeft = 0 } = $$props;
    	let { minTop = 0 } = $$props;
    	top = Math.max(top, minTop);
    	left = Math.max(left, minLeft);
    	let wrapper;
    	let moving = false;

    	const start = e => {
    		focus(wrapper);
    		moving = true;
    	};

    	const stop = _ => moving = false;

    	const move = e => {
    		if (moving) {
    			$$invalidate(1, left += e.movementX);
    			$$invalidate(0, top += e.movementY);

    			if (clamp) {
    				// clamp to top left
    				const w = window.innerWidth;

    				const h = window.innerHeight;
    				$$invalidate(1, left = Math.min(Math.max(left, minLeft), w - wrapper.clientWidth - 2));
    				$$invalidate(0, top = Math.min(Math.max(top, minTop), h - wrapper.clientHeight - 2));
    			}
    		}
    	};

    	onMount(() => {
    		add(wrapper);

    		return () => {
    			remove$1(wrapper);
    		};
    	});

    	const writable_props = ["clamp", "top", "left", "minLeft", "minTop"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Draggable> was created with unknown prop '${key}'`);
    	});

    	const func = _ => focus(wrapper);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			wrapper = $$value;
    			$$invalidate(2, wrapper);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("clamp" in $$props) $$invalidate(6, clamp = $$props.clamp);
    		if ("top" in $$props) $$invalidate(0, top = $$props.top);
    		if ("left" in $$props) $$invalidate(1, left = $$props.left);
    		if ("minLeft" in $$props) $$invalidate(7, minLeft = $$props.minLeft);
    		if ("minTop" in $$props) $$invalidate(8, minTop = $$props.minTop);
    		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		zindex,
    		stack,
    		focus,
    		add,
    		remove: remove$1,
    		getActiveWindow,
    		onMount,
    		clamp,
    		top,
    		left,
    		minLeft,
    		minTop,
    		wrapper,
    		moving,
    		start,
    		stop,
    		move
    	});

    	$$self.$inject_state = $$props => {
    		if ("clamp" in $$props) $$invalidate(6, clamp = $$props.clamp);
    		if ("top" in $$props) $$invalidate(0, top = $$props.top);
    		if ("left" in $$props) $$invalidate(1, left = $$props.left);
    		if ("minLeft" in $$props) $$invalidate(7, minLeft = $$props.minLeft);
    		if ("minTop" in $$props) $$invalidate(8, minTop = $$props.minTop);
    		if ("wrapper" in $$props) $$invalidate(2, wrapper = $$props.wrapper);
    		if ("moving" in $$props) moving = $$props.moving;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		top,
    		left,
    		wrapper,
    		start,
    		stop,
    		move,
    		clamp,
    		minLeft,
    		minTop,
    		$$scope,
    		slots,
    		func,
    		div_binding
    	];
    }

    class Draggable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
    			clamp: 6,
    			top: 0,
    			left: 1,
    			minLeft: 7,
    			minTop: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Draggable",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get clamp() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clamp(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get left() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minLeft() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minLeft(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minTop() {
    		throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minTop(value) {
    		throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_components\PanelHeader.svelte generated by Svelte v3.31.2 */

    const file$3 = "src\\_components\\PanelHeader.svelte";

    function create_fragment$3(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "panel-header svelte-18pvy6o");
    			add_location(div, file$3, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PanelHeader", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PanelHeader> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class PanelHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PanelHeader",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\_singles\buttons\ActionButton.svelte generated by Svelte v3.31.2 */

    const file$4 = "src\\_singles\\buttons\\ActionButton.svelte";

    function create_fragment$4(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", "svelte-1dsxcgu");
    			toggle_class(button, "danger", /*variant*/ ctx[0] == "danger");
    			add_location(button, file$4, 4, 0, 58);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			if (dirty & /*variant*/ 1) {
    				toggle_class(button, "danger", /*variant*/ ctx[0] == "danger");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ActionButton", slots, ['default']);
    	let { variant = undefined } = $$props;
    	const writable_props = ["variant"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ActionButton> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("variant" in $$props) $$invalidate(0, variant = $$props.variant);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ variant });

    	$$self.$inject_state = $$props => {
    		if ("variant" in $$props) $$invalidate(0, variant = $$props.variant);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [variant, $$scope, slots, click_handler];
    }

    class ActionButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { variant: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ActionButton",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get variant() {
    		throw new Error("<ActionButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<ActionButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_components\ModalWindow.svelte generated by Svelte v3.31.2 */
    const file$5 = "src\\_components\\ModalWindow.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (47:12) <ActionButton on:click={_ => close(_window)}>
    function create_default_slot_2(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M24 20.188l-8.315-8.209 8.2-8.282-3.697-3.697-8.212 8.318-8.31-8.203-3.666 3.666 8.321 8.24-8.206 8.313 3.666 3.666 8.237-8.318 8.285 8.203z");
    			add_location(path, file$5, 47, 97, 1703);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "10");
    			attr_dev(svg, "height", "10");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$5, 47, 14, 1620);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(47:12) <ActionButton on:click={_ => close(_window)}>",
    		ctx
    	});

    	return block;
    }

    // (42:8) <PanelHeader>
    function create_default_slot_1(ctx) {
    	let span;
    	let t0_value = /*_window*/ ctx[3].props.label + "";
    	let t0;
    	let t1;
    	let div;
    	let actionbutton;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[1](/*_window*/ ctx[3], ...args);
    	}

    	actionbutton = new ActionButton({
    			props: {
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	actionbutton.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			create_component(actionbutton.$$.fragment);
    			attr_dev(span, "class", "label svelte-1686zzt");
    			add_location(span, file$5, 42, 10, 1438);
    			attr_dev(div, "class", "actions");
    			add_location(div, file$5, 45, 10, 1524);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(actionbutton, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*$windows*/ 1) && t0_value !== (t0_value = /*_window*/ ctx[3].props.label + "")) set_data_dev(t0, t0_value);
    			const actionbutton_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				actionbutton_changes.$$scope = { dirty, ctx };
    			}

    			actionbutton.$set(actionbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actionbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actionbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(actionbutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(42:8) <PanelHeader>",
    		ctx
    	});

    	return block;
    }

    // (56:8) {:else}
    function create_else_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No component");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(56:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (54:8) {#if _window.component}
    function create_if_block$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*_window*/ ctx[3].props];
    	var switch_value = /*_window*/ ctx[3].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$windows*/ 1)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*_window*/ ctx[3].props)])
    			: {};

    			if (switch_value !== (switch_value = /*_window*/ ctx[3].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(54:8) {#if _window.component}",
    		ctx
    	});

    	return block;
    }

    // (39:2) <Draggable minTop="40" clamp let:focus>
    function create_default_slot(ctx) {
    	let div2;
    	let div0;
    	let panelheader;
    	let t0;
    	let div1;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;

    	panelheader = new PanelHeader({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*_window*/ ctx[3].component) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function wheel_handler(...args) {
    		return /*wheel_handler*/ ctx[2](/*_window*/ ctx[3], /*focus*/ ctx[6], ...args);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(panelheader.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			if_block.c();
    			t1 = space();
    			attr_dev(div0, "class", "controls svelte-1686zzt");
    			add_location(div0, file$5, 40, 6, 1381);
    			attr_dev(div1, "class", "content-window svelte-1686zzt");
    			add_location(div1, file$5, 52, 6, 1954);
    			attr_dev(div2, "class", "window svelte-1686zzt");
    			set_style(div2, "--scale", /*_window*/ ctx[3].props.zoom);
    			set_style(div2, "--width", /*_window*/ ctx[3].props.width);
    			set_style(div2, "--height", /*_window*/ ctx[3].props.height);
    			add_location(div2, file$5, 39, 4, 1182);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(panelheader, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			if_blocks[current_block_type_index].m(div1, null);
    			insert_dev(target, t1, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "wheel", prevent_default(wheel_handler), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const panelheader_changes = {};

    			if (dirty & /*$$scope, $windows*/ 129) {
    				panelheader_changes.$$scope = { dirty, ctx };
    			}

    			panelheader.$set(panelheader_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}

    			if (!current || dirty & /*$windows*/ 1) {
    				set_style(div2, "--scale", /*_window*/ ctx[3].props.zoom);
    			}

    			if (!current || dirty & /*$windows*/ 1) {
    				set_style(div2, "--width", /*_window*/ ctx[3].props.width);
    			}

    			if (!current || dirty & /*$windows*/ 1) {
    				set_style(div2, "--height", /*_window*/ ctx[3].props.height);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(panelheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(panelheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(panelheader);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(39:2) <Draggable minTop=\\\"40\\\" clamp let:focus>",
    		ctx
    	});

    	return block;
    }

    // (38:0) {#each $windows as _window (_window)}
    function create_each_block$1(key_1, ctx) {
    	let first;
    	let draggable;
    	let current;

    	draggable = new Draggable({
    			props: {
    				minTop: "40",
    				clamp: true,
    				$$slots: {
    					default: [
    						create_default_slot,
    						({ focus }) => ({ 6: focus }),
    						({ focus }) => focus ? 64 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(draggable.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(draggable, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const draggable_changes = {};

    			if (dirty & /*$$scope, $windows*/ 129) {
    				draggable_changes.$$scope = { dirty, ctx };
    			}

    			draggable.$set(draggable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(draggable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(draggable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(draggable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(38:0) {#each $windows as _window (_window)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*$windows*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*_window*/ ctx[3];
    	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$windows, scrollBehaviour, close*/ 1) {
    				each_value = /*$windows*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const windows = writable([]);

    const push$1 = (component, props = {}) => {
    	props = {
    		width: 128,
    		height: 128,
    		zoom: 2,
    		...props
    	};

    	windows.update(store => {
    		return [...store, { component, props }];
    	});
    };

    const clear = _ => windows.set([]);

    const close = obj => {
    	windows.update(store => store.filter(_obj => _obj !== obj));
    };

    const max = 5;
    const min = 2;

    const scrollBehaviour = (e, target, focus) => {
    	if (focus) focus();

    	windows.update(store => {
    		const index = store.indexOf(target);
    		const match = store[index];
    		match.props.zoom = Math.min(Math.max(match.props.zoom + (e.deltaY > 0 ? -1 : 1), min), max);
    		return store;
    	});
    };

    function instance$5($$self, $$props, $$invalidate) {
    	let $windows;
    	validate_store(windows, "windows");
    	component_subscribe($$self, windows, $$value => $$invalidate(0, $windows = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalWindow", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ModalWindow> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (_window, _) => close(_window);
    	const wheel_handler = (_window, focus, e) => scrollBehaviour(e, _window, focus);

    	$$self.$capture_state = () => ({
    		ActionButton,
    		PanelHeader,
    		Draggable,
    		getActiveWindow,
    		writable,
    		windows,
    		push: push$1,
    		clear,
    		close,
    		max,
    		min,
    		scrollBehaviour,
    		$windows
    	});

    	return [$windows, click_handler, wheel_handler];
    }

    class ModalWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalWindow",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    const application = {
      startPage: '/graphics/spritesheets',
      // startPage: '/documentation',
      isDev: location.hostname == 'localhost' || globalThis.electron,
      initWithDemoProject: true
    };

    const subDir = !application.isDev ? '/NESBitStudio-web' : '/'; 

    const filetypes = {
      // project 
      project: {
        save: {
          mimetype: "nesbit/project",
          extension: "nesbitproject",
          version: 3
        }
      },
      // palettes 
      palettes: {
        save: {
          mimetype: "nesbit/palette",
          extension: "nesbitpalette",
          version: 2,
        },
        export: {
          mimetype: "text/plain",
          extension: "",
          version: 1
        }
      },
      // spritesheets 
      spritesheets: {
        save: {
          mimetype: "nesbit/spritesheet",
          extension: "nesbitspritesheet",
          version: 3
        },
        export: {
          mimetype: "text/plain",
          extension: "",
          version: 2
        }
      },
      // tilemaps 
      tilemaps: {
        save: {
          mimetype: "nesbit/tilemap",
          extension: "nesbittilemap",
          version: 1
        },
        export: {
          mimetype: "text/plain",
          extension: "s",
          version: 1
        }
      },

      // settings
      settings: {
        save: {
          mimetype: "nesbit/settings",
          extension: "nesbitsettings",
          version: 2
        }
      }
    };

    var config = { 
      application,
      filetypes
    };

    // shuffel an array

    // split array into chunks
    const chunk = (array, size) => {
      const length = array ? array.length : 0;
      if(length < 1){
        return [];
      }
      const result = new Array(Math.ceil(length / size));
      let index = 0, resIndex = 0;
      while(index < length){
        result[resIndex++] = array.slice(index, (index += size));
      }
      return result;
    };

    // convert the number to a binary string
    const getBinaryStringFromNumber = (n) => {
      // convert to binary
      n = Number(n >>> 0).toString(2);
      // force it's length to be 8 by padding 0's
      return '00000000'.substring(n.length)+n;
    };

    /*
      Get color definition from high low

      the chr can have 4 values. 0-3. 
      'a' has a weight of 1 and 'b' has a weight of 2. 
      a, b, result
      0, 0, 0, // both a and b are 0 so the result is 0
      1, 0, 1, // a is set to 1 so it becomes one
      0, 1, 2, // a is set to 0 and b is 1 so it becomes 2. (because b has a weight of 2)
      1, 1, 3, // a and b is set to 1 so the result becomes 3. a(1) + b(2) = 3

      @param String (binary string)
      @param String (binary string)

      @return Array
    */
    function getColorDefinitionFromHighLow(low, high){
      // this will be 0 or 1 if it does not get 
      // replaced in the following if statements
      let n = Number(low);
      // if high != 0. it's 2. since thats either 0 or 1. 
      // and if its not 0(which would be false) its 1. meaning it's 2
      if(Number(high)){
        n = 2;
      }
      // if low + high > 1(if both a and b is set. it's larger than 1. then we know it has to be 3. 1 + 2 = 3)
      if((Number(low) + Number(high)) > 1){
        n = 3;
      }
      return n;
    }

    /* 
      parse contents of a NES chr file 

      @param ArrayBuffer
      @return Array

      This function will return a 16x16 2d array of 8x8 2d array representing each tile 
    */
    const parse = (data) => {
      // split the byte array in chunks of 16. 1 row = 16 tiles.
      // a tile is 8x8. which means you have 64 pixels in each tile. 
      // each pixel has 4 available color values which ends up to (8x8) x 4(color value from 0-3) = 256.
      const chunks = chunk(new Uint8Array(data), 16);
      let tiles = [];
      for(let chunk of chunks){
        let low, high, tile = [];
        // handle all 16 bits. 
        // the first 8 bits is the low 
        // and the second 8 bits is the high
        for(let i = 8; i < 16; i++){
          low = getBinaryStringFromNumber(chunk[i-8]);
          high = getBinaryStringFromNumber(chunk[i]);
          // create the pixel definition from the low and high bits
          // this would be a row of 8 pixels. the loop will do 
          // this 8 times to form a 8x8 tile
          const pixelRow = [];
          for(let i = 0; i < 8; i++){
            const pixel = getColorDefinitionFromHighLow(low[i], high[i]);
            pixelRow.push(pixel);  
          }
          tile.push(pixelRow);
        }
        tiles.push(tile);
      }
      // split the tiles array by 16. 
      // 16 8x8 tiles per each row
      tiles = chunk(tiles, 16);
      // split the CHR data in parts of size(16 for the nes) for giving 16x16 per page
      return chunk(tiles, 16);
    };

    /*
      generate chr export
      from the pixel definition we can get the corresponding low and high bits. this could be done manually or 
      by doing a bitwise AND and right shift the high bits by 1 to get the opposite values implemented below.

      n: 0
      0x00 & 0x01 = 0
      00000000
      00000001

      n: 1
      0x55 & 0x01 = 1
      01010101
      00000001

      n: 2
      0xAA & 0x01 = 0
      10101010
      00000001
      
      n: 3
      0xFF & 0x01 = 1
      11111111
      00000001

    */
    const generateExport = (data) => {
      // mappings of 4 parts of hex value up to 255. 
      // this to be able to implement colors later 
      const map = [0x00, 0x55, 0xAA, 0xFF];
      // 4kb buffer
      const buff = new ArrayBuffer(4096);
      const output = new Uint8Array(buff);
      // store the binary string
      let bin = '';
      // loop through the nested 2d arrays
      for(let h of data){
        for(let w of h){
          // store low and high bits
          let low = '', high = '';
          for(let x of w){
            for(let n of x){
              // map current value for numbers 0-4
              const v = map[n];
              low += v & 0x01;
              high += (v >> 1) & 0x01;
            }
          }
          // add the low and high values to binary
          bin += low + high;
        }
      }
      // split binary string in 8's and append each 8 bits to the buffer
      bin.match(/.{8}/g).map((_, i) => output[i] = parseInt(_, 2));
      return output;
    };

    const createCanvas = ({ width, height }) => {
      const element = document.createElement('canvas');
      const context = element.getContext('2d');
      element.width = width;
      element.height = height;
      return { element, context, width, height };
    }; 


    // generate a new pattern
    const createCanvasPattern = ({ background, source, x, y, width, height }) => {
      // general canvas placeholder
      const canvas = createCanvas({
        width,
        height
      });
      canvas.context.clearRect(0, 0, width, height);
      if(background){
        canvas.context.fillStyle = background;
        canvas.context.fillRect(0, 0, canvas.width, canvas.height);
      }
      canvas.context.drawImage(source.element, x, y, width, height, 0, 0, width, height);
      const pattern = _ => source.context.createPattern(canvas.element, 'repeat');
      return { pattern, ...canvas };
    };


    /*
      requestanimationframe loop
      
      @param callback (Function)
      @param fps (Number) (optional)
      
      @return cancel (Function)

      Usage:
      const stop = AnimationLoop((delta, framecount, stop, time) => {
        console.log(delta, framecount);
        if(framecount > 99){
          stop();
        }
      }, 30);
    */
    const AnimationLoop = (fn, fps = null) => {
      if(typeof fn !== 'function'){
        throw new Error(`Invalid callback function.`);
      }
      let paused = false;
      let framecount = 0;
      let animation;
      let lastTime = performance.now();
      const cancel = _ => cancelAnimationFrame(animation);
      const pause = _ => paused = true;
      const play = _ => paused = false;
      const toggle = _ => paused = !paused;
      const loop = (time) => {
        animation = requestAnimationFrame(loop);
        if(paused){
          return;
        }
        const delta = time - lastTime;
        const now = performance.now();
        if(!fps || now - lastTime > 1000 / fps){
          fn.call(null,{ delta: delta / 1000, frame: ++framecount, cancel, time, pause, play });
          lastTime = time;
        }
      };
      animation = requestAnimationFrame(loop);
      return {
        unsubscribe: cancel,
        pause,
        play,
        toggle,
      };
    };

    class HistoryManager{
      constructor(){
        this.future = [];
        this.past = [];
        this.present;
      }
      get last(){
        return this.present;
      }
      setPresent(data){
        this.future = [];
        this.present = JSON.parse(JSON.stringify(data));
      }
      push(data){
        this.past.push(JSON.parse(JSON.stringify(data)));
      }
      undo(){
        if(this.past.length){
          const past = this.past.pop();
          this.future.push(this.present);
          this.present = past;
        }
        return this.present;
      }
      redo(){
        if(this.future.length){
          const future = this.future.pop();
          this.push(this.present);
          this.present = future;
        }
        return this.present;
      } 
    }

    const AttributeTable = _ => new Array(16).fill().map(_ => new Array(16).fill().map(_ => null));

    class CanvasLayer{
      constructor({ label, width, height, data, colorAttributes, uuid } = {}){
        this._isInitialized = false;
        this.uuid = uuid || Math.random() + Date.now();
        this.width = width || 128;
        this.height = height || 128;
        this.label = label || '';
        this.element = document.createElement('canvas');
        this.element.width = this.width;
        this.element.height = this.height;
        this.context = this.element.getContext('2d');
        this.image = new Image();
        this.data = data;
        
        // store history
        this.history = new HistoryManager();
        // attributes tables
        // TODO: make canvas layer be able to switch between multiple attribute tables. 
        this.colorAttributes = colorAttributes;
        if(!this.colorAttributes){
          this.colorAttributes = AttributeTable();
        }

        // generate a double nested array list. 16x16 column then inside each tile they are 8x8 pixels wide
        if(!this.data){
          this.data = new Array(16).fill().map(_ => new Array(16).fill().map(_ => new Array(8).fill().map(_ => new Array(8).fill().map(_ => 0))));
        }else {
          if(!this._isInitialized){
            // draw it on first instantiation else imports wont reveal themselves unless becoming active layers
            this.drawFromSource(Palettes.stores.activeLayer.get());
          }
        }
        
      }
      updateImageSource(){
        // a bt dodgy when there already is a function wrapper
        // tho it only returns a blob. refactor it later.
        return this.image.src = this.element.toDataURL('image/png', .1);
      }
      setPresent(data){
        this.history.setPresent(data || this.data);
      }

      forceUpdate(source){
        this.drawFromSource(Palettes.stores.activeLayer.get(), source);
      }

      async toDataURL(mimetype = 'image/png', quality){
        const blob = await fetch(this.element.toDataURL(mimetype, quality)).then(res => res.blob());
        return blob;
      }
      // get palette info from x y 
      colorIndexAtPosition(x, y){
        const data = this.data;
        const rc = {x: Math.floor(x / 8), y: Math.floor(y / 8)};
        const tile = {x: x % 8, y: y % 8};
        const colorIndex = data[rc.y][rc.x][tile.y][tile.x];
        return colorIndex;
      }
      setColorIndexAtPosition(x, y, colorIndex){
        const data = this.data;
        const rc = {x: Math.floor(x / 8), y: Math.floor(y / 8)};
        const tile = {x: x % 8, y: y % 8};
        data[rc.y][rc.x][tile.y][tile.x] = colorIndex;
      }
      saveHistory(){
        this.history.push(this.data); 
      }
      undo(){
        const present = this.history.undo();
        if(present){
          this.data = present;
          this.drawFromSource(Palettes.stores.activeLayer.get());
        } 
      }
      redo(){
        const removed = this.history.redo();
        if(removed){
          this.data = removed;
          this.drawFromSource(Palettes.stores.activeLayer.get());
        } 
      }

      drawFromSource(palette, source){
        if(!palette) return;
        if(!this._isInitialized){
          this._isInitialized = true;
        }
        // one line list of tiles... split on % 16 for new row
        this.data.map((trow, tr) => {
          trow.map((tcol, tc) => {
            this.context.save();
            this.context.translate(tc*8, tr*8);
            let attributeOverlayPalette = (source || Spritesheets.stores.activeLayer.get())?.colorAttributes[tc][tr];
            let _palette;
            if(attributeOverlayPalette){
              _palette = attributeOverlayPalette;
            }
            tcol.map((col, c) => {
              this.context.save();
              this.context.translate(0, c);
              
              col.map((row, r) => {
                this.context.save();
                this.context.translate(r, 0);
                
                let color = (_palette || palette).colors[row];
                if(!color){
                  return;
                }
                this.context.fillStyle = `rgb(${color.rgb})`;
                this.context.fillRect(0,0,1,1);
                this.context.restore();
                
              });
              
                this.context.restore();
              });

            this.context.restore();      
          });
        });
      }
      clear(){
        this.context.clearRect(0, 0, this.element.width, this.element.height);
      }
    }

    // general placeholder canvas
    const placeholderCanvas = createCanvas({ width: 128, height: 128 });

    // handle color attributes overlay on the sprites layer
    // const activePalette = derived(Palettes.stores.activeLayer, ($al, set) => set($al));
    // const ColorAttributes = writable({ activePalette, activeLayer: writable(), layers: writable([new AttributeTable()])}, ({ store, value, get }) => {
    //   return {
    //     stores: value,
    //     updateAttribute({ x, y, data }){
    //       // TODO: should dependable palettes be created? since the serialized data does not
    //       // know anything about the actual palette instance. or should there be a button which 
    //       // lets you click and 'create palettes from color attributes'.
    //       ColorAttributes.stores.activeLayer.get().data[x][y] = data;
    //     }
    //   }
    // });
    // ColorAttributes.stores.activeLayer.set(ColorAttributes.stores.layers.get()[0]);

    // { x: 0, y: 0 }
    const current = writable$1(undefined, ({ store, value, get}) => {
      return {
        set(v){
          if(!(Number.isInteger(v.x) && Number.isInteger(v.y))){
            return;
          }
          // set the new value
          store.set(v);
        }
      }
    });
    const fallback = writable$1(undefined, ({ store, value, get}) => {
      return {
        set(v){
          if(!(Number.isInteger(v.x) && Number.isInteger(v.y))){
            return;
          }
          // set the new value
          store.set(v);
        }
      }
    });

    const selectedTile = writable$1({ current, fallback }, ({ store, value, get }) => {
      return {
        stores: value
      }
    });

    const layers = writable$1([], ({ store, value, get }) => {
      return {
        // swap layers
        swapLayers(i, j){
          store.update(_store => {
            if(!_store[i] || !_store[j]){
              return _store;
            }
            [_store[i], _store[j]] = [_store[j], _store[i]]; 
            Spritesheets.stores.activeLayer.set(_store[j]);
            return _store;  
          });
        },
      }
    });

    const activeLayer = writable$1(undefined);
    const artboard$1 = writable$1({ defaultZoom: 4, zoom: 4, offset: { x: 0, y: 0 }}, ({ store, value, get }) => {
      return {
        zoom(v){
          v = value.zoom + v;
          if(v <= 0){
            v = Math.max(1, v);
          }
          artboard$1.update((store) => {
            store.zoom = v;
            return store;
          });
        },
        zoomReset(){
          artboard$1.update((store) => {
            store.zoom = store.defaultZoom;
            return store;
          });
        }
      }
    }); 
    const Spritesheets = writable$1({ activeLayer, layers, selectedTile, artboard: artboard$1 }, ({ store, value, get }) => {

      return {
        data: {
          width: 128,
          height: 128,
        },
        stores: value,
        // create a new spritesheet layer
        createLayer({ label, data, colorAttributes, uuid } = {}){
          Spritesheets.stores.layers.update(_store => {
            label = label || 'spritesheet_' + (_store.length+1);
            const CanvasLayerInstance = new CanvasLayer({ label, data, colorAttributes, uuid });
            const _store_copy = [CanvasLayerInstance, ..._store];
            // _store = [..._store, CanvasLayerInstance];
            // do we always want to make the new layer active?
            // if(_store.length <= 1){
            //   Spritesheets.makeLayerActive(CanvasLayerInstance);
            // }
            // make new layer active
            Spritesheets.makeLayerActive(CanvasLayerInstance);
            return _store_copy;
          });
        },

        // remove layer 
        removeLayer(CanvasLayerInstance){
          Spritesheets.stores.layers.update((_store) => {
            let _store_copy = [..._store];
            const index = _store_copy.indexOf(CanvasLayerInstance);
            if(CanvasLayerInstance == Spritesheets.stores.activeLayer.get()){
              // if there is a palette/layer after the currently removed, make that one the active one 
              if(_store_copy[index+1]){
                Spritesheets.makeLayerActive(_store_copy[index+1]);
              }else if(_store_copy[index-1]){
                Spritesheets.makeLayerActive(_store_copy[index-1]);
              }else {
                Spritesheets.stores.activeLayer.set(undefined);
              }
            }
            // remove object
            _store_copy = _store_copy.filter(instance => instance != CanvasLayerInstance);
            return _store_copy;
          });
        },

        // clone layer 
        cloneLayer(CanvasLayerInstance){
          // TODO: make so the index position is right above the clones layer. currently
          // it gets added to the top of the stack as the first array element, which is not ideal.
          Spritesheets.stores.layers.update((_store) => {
            let { width, height, label, data, colorAttributes } = CanvasLayerInstance;
            // we need to serialize the data else it will reference the same data
            if(Array.isArray(data)){
              data = JSON.parse(JSON.stringify(data));
              colorAttributes = JSON.parse(JSON.stringify(colorAttributes));
            }
            label = label + ' copy';
            const newLayer = new CanvasLayer({ width, height, label, data, colorAttributes });
            _store = [ newLayer, ..._store];
            Spritesheets.makeLayerActive(newLayer);
            return _store;  
          });
        },
        
        // clone active layer 
        cloneActiveLayer(){
          const active = Spritesheets.stores.activeLayer.get();
          if(active){
            Spritesheets.cloneLayer(active);
          }else {
            Spritesheets.createLayer();
          }
        },
        // make a layer active
        makeLayerActive(CanvasLayerInstance){
          if(!(CanvasLayerInstance instanceof CanvasLayer)){
            throw new Error(`Invalid 'CanvasLayerInstance' while setting 'activeLayer'`);
          }
          Spritesheets.stores.activeLayer.set(CanvasLayerInstance);
          CanvasLayerInstance.forceUpdate();
        },

        // update label
        updateLayerLabel(CanvasLayerInstance, label){
          Spritesheets.stores.layers.update((_store) => {
            CanvasLayerInstance.label = label;
            return _store;
          });
        },

        // import 
        import(data, isSerialized){
          const unserializedData = isSerialized ? data : JSON.parse(data);
          if(unserializedData.version != config.filetypes.spritesheets.save.version){
            console.warn(`Invalid file version.`);
            return;  
          }

          // import spritesheets
          for(const _spritesheet of [...unserializedData.data.spritesheets.layers].reverse()){
            Spritesheets.createLayer({ ..._spritesheet });
          }
        },

        // export 
        export(serialize){
          // get all layers
          const spritesheetsLayers = JSON.parse(JSON.stringify(Spritesheets.stores.layers.get())).map(layer => {
            return { label: layer.label, data: layer.data, colorAttributes: layer.colorAttributes, uuid: layer.uuid };
          });
          
          // build the data
          let data = { 
            version: config.filetypes.spritesheets.save.version, 
            data: { 
              spritesheets: {
                layers: spritesheetsLayers,
              },
            }
          };

          if(serialize){
            data = JSON.stringify(data);
          }
          return data;
        },

        // import chr
        importCHR(filedata){
          const result = parse(filedata);
          result.forEach(page => Spritesheets.createLayer({ data: page }));
        },

        // export chr
        exportCHR(){
          const activeLayer = Spritesheets.stores.activeLayer.get();
          if(!activeLayer || !activeLayer.data){
            throw new Error(`Unable to export CHR. No 'activeLayer'`);  
          }
          const bytearray = generateExport(activeLayer.data);
          return { label: activeLayer.label, data: bytearray };
        },
        
        // export image
        exportAsImage(callback, mimetype = 'image/png', quality = 1){
          const activeLayer = Spritesheets.stores.activeLayer.get();
          if(!(activeLayer instanceof CanvasLayer)){
            throw new Error(`Unable to export Image. No 'activeLayer'`);
          }
          const fn = (blob) => {
            const reader = new FileReader();
            reader.readAsArrayBuffer(blob);
            reader.onloadend = _ => {
              callback.call(null, { blob, buffer: reader.result, label: activeLayer.label, options: { mimetype, quality } });
            };
          };
          
          // placeholder canvas so we can scale the canvas
          const scale = 128 * Spritesheets.stores.artboard.get().zoom;
          placeholderCanvas.context.clearRect(0, 0, scale, scale);
          placeholderCanvas.element.width = scale;
          placeholderCanvas.element.height = scale;

          // this needs to be applied after any width or height changes has been made
          placeholderCanvas.context.imageSmoothingEnabled = false;

          // draw the current canvas on to the placeholder in scaled values
          placeholderCanvas.context.drawImage(
            activeLayer.element, 
            0, 0, 
            128, 128, 
            0, 0,
            scale, scale
          );
          
          return { label: activeLayer.label, image: placeholderCanvas.element.toBlob(fn, mimetype, quality), options: { type: mimetype } };
        },

        // export nametable and attributestable for current spritesheet
        // NOTE: this is more or less for debugging during development and should later be translated 
        // to work with the tilemaps. 
        exportNametableData(label = 'nametable'){
          const temp = new Array(30).fill(new Array(32).fill(0));
          const activeLayer = Spritesheets.stores.activeLayer.get();
          
          const nametable = [];
          
          let v;
          let count = 0;
          for(const i in temp){
            for(const j in temp[i]){
              if(activeLayer.data[i] && activeLayer.data[i][j]){
                v = count++;
              }else {
                v = 0;
              }
              nametable.push(dec2hex(v, 2));
            }
          }
          
          // simulate width of a tilemap. this is not correct but just for debugging. The final tilemap should be
          // 32x30 tiles wide (256x240 pixels).
          const simulated = [
            ...nametable,
          ];

          // chunk it so it's easier to read later on
          const chunked = chunk(simulated, 32);
          let output = `${label}:\n`;
          chunked.forEach((value) => {
            output += `.byte ${value.map(v => '$' + v).join(', ')}\n`;
          });

          output += `\n

; color the background tiles
attribute_table:
; 7654 3210
; |||| ||++- Color bits 3-2 for top left quadrant of this byte
; |||| ++--- Color bits 3-2 for top right quadrant of this byte
; ||++------ Color bits 3-2 for bottom left quadrant of this byte
; ++-------- Color bits 3-2 for bottom right quadrant of this byte
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000

      `; 

          return output; 
        },
        // clear all 
        clear(){
          Spritesheets.stores.activeLayer.set(undefined);
          Spritesheets.stores.layers.set([]);
        }
      }
    });

    // get the default color
    // weird but wtf is it a reference or not? i'm just making sure we doesn't mutate the nespalette so we seralize and unserialize it here.
    const findNESPalette = (hex) => {
      const palette = mappedColorList.find(o => o.hex == hex);
      if(palette){
        return palette;
      }
    };

    const colorPlaceholder = findNESPalette('0F');

    // colorpalette 
    class ColorPaletteGroup{
      constructor({ label, colors, uuid }){
        this.label = label || '';
        this.colors = [];
        this.uuid = uuid || Math.random() + Date.now();
        if(Array.isArray(colors) && colors.length == 4){
          for(const color of colors){
            this.addColor(color.hex);
          }
        }else {
          this.colors = [...Array(4).fill('').map(item => ({ ...colorPlaceholder }))];
        }
      }
      addColor(hex){
        if(!(this.colors.length < 4)){
          throw new Error(`Max 4 colors per 'ColorPaletteGroup'`);
        }
        const palette = findNESPalette(hex);
        if(palette){
          this.colors.push({...palette});
        }
      }
    }

    // selected color store
    const selectedColor = writable$1(0, ({ store, get }) => {
      return {
        // set the active color index
        setActiveColorIndex(n){
          if(!Number.isInteger(n)){
            throw new Error(`Invalid 'setActiveColorIndex' value. Expecting 'Integer'`);
          }
          if(!(n >= 0 && n <= 4)){
            throw new Error(`Invalid 'setActiveColorIndex' number range. Expecting number between '0-4'`);
          }
          store.set(n);
        },
        // get active color index
        getActiveColorIndex(){
          return get();
        },
        // get active color value
        getActiveColorValue(n){
          const activeLayer = Palettes.stores.activeLayer.get();
          if(!activeLayer){
            throw new Error(`No 'activeLayer' selected`);
          }
          if(!Number.isInteger(n)){
            n = get();
          }
          return activeLayer.colors[n];
        }
      }
    });

    // layers store
    const layers$1 = writable$1([], ({ store, value, get, update }) => {
      return {
        // clear all layers
        clear(){
          Palettes.stores.activeLayer.set(undefined);
          store.set([]);
        },
        // swap layers
        swapLayers(i, j){
          store.update(_store => {
            if(!_store[i] || !_store[j]) {
              return _store;
            }
            [_store[i], _store[j]] = [_store[j], _store[i]]; 
            Palettes.stores.activeLayer.set(_store[j]);
            return _store;  
          });
        },
        // replace color
        replaceColor(data){
          store.update((_store) => {
            const layer = _store[data.layerIndex];
            // not really required but might be easier to manage in the future
            const colorFromPalette = findNESPalette(data.hex);

            // add the new color values
            layer.colors[data.colorIndex] = {
              hex: colorFromPalette.hex,
              rgb: colorFromPalette.rgb
            };

            // make the layer active. This updates the activeLayer so we don't have to 
            // force a manual update to make main artboard palette react to the changes
            // and also it's nice to automatically change the active palette
            Palettes.makeLayerActive(_store[data.layerIndex]);
            return _store;
          });
        },

        // swap colors
        swapColors(data){
          store.update((_store) => {
            Palettes.update();
            const ref = _store[data.layerIndex].colors;
            const ref2 = _store[data.to.layerIndex].colors;
            // this is all redundant but in place if things change in the future        
            let from = ref[data.colorIndex];
            let to = ref2[data.to.colorIndex];
            
            // swap the colors
            ref[data.colorIndex] = { ...findNESPalette(to.hex) };
            ref2[data.to.colorIndex] = { ...findNESPalette(from.hex) };

            // make active just to force a reactive update and also if swapped 
            // between layers we use the new layer
            Palettes.makeLayerActive(_store[data.to.layerIndex]);

            return _store;
          });
        },
      }
    });

    const Palettes = writable$1({ selectedColor, activeLayer: writable$1(), layers: layers$1 }, ({ store, value, get }) => {
      return {
        lastChanged: writable$1(), 
        stores: value,
        // update
        update(){
          Palettes.lastChanged.set(Math.random() + Date.now()); 
        },
        // create new color palette
        createLayer({ label, colors, uuid } = {}, push = false){
          value.layers.update(_store => {
            label = label || 'palette_' + (_store.length+1);
            const paletteGroup = new ColorPaletteGroup({ label, colors, uuid });
            // if we need to add the new layer to the end of the layer stack
            // for instance on imports, else imports would become reversed
            if(push){
              _store = [..._store, paletteGroup];
            }else {
              _store = [paletteGroup, ..._store];
            }
            // make active 
            Palettes.makeLayerActive(paletteGroup);
            return _store;
          });
        },

        // remove layer
        removeLayer(ColorPaletteGroupInstance){
          value.layers.update((_store) => {
            const index = _store.indexOf(ColorPaletteGroupInstance);
            if(ColorPaletteGroupInstance == value.activeLayer.get()){
              // if there is a palette/layer after the currently removed, make that one the active one 
              if(_store[index+1]){
                Palettes.makeLayerActive(_store[index+1]);
              }else if(_store[index-1]){
                Palettes.makeLayerActive(_store[index-1]);
              }else {
                value.activeLayer.set(undefined);
              }
            }
            // remove object
            _store.splice(index, 1);
            return _store;
          });
        },

        // clone layer 
        cloneLayer(ColorPaletteGroupInstance){
          // TODO: make so the index position is right above the clones layer. currently
          // it gets added to the top of the stack as the first array element, which is not ideal.
          value.layers.update((_store) => {
            let { label, colors } = ColorPaletteGroupInstance;
            // NOTE: probably have to serialize the data so it doesn't act as a reference 
            // data = JSON.stringify(JSON.parse(data));
            label = label + ' copy';
            const newLayer = new ColorPaletteGroup(label, colors);
            _store = [ newLayer, ..._store];
            Palettes.makeLayerActive(newLayer);
            return _store;  
          });
        },
        
        // clone active layer 
        cloneActiveLayer(){
          const active = value.activeLayer.get();
          if(active){
            Palettes.cloneLayer(active);
          }else {
            Palettes.createLayer();
          }
        },

        // make a layer active
        makeLayerActive(ColorPaletteGroupInstance){
          if(!(ColorPaletteGroupInstance instanceof ColorPaletteGroup)){
            throw new Error(`Invalid 'ColorPaletteGroupInstance' while setting 'activeLayer'`);
          }
          value.activeLayer.set(ColorPaletteGroupInstance);

          // update when palette changes so the pattern preview window
          // shows the right updated colors 
          const activeLayer = Spritesheets.stores.activeLayer.get();
          if(activeLayer){
            Spritesheets.stores.activeLayer.get().forceUpdate();
          }
          
        },

        // make layer active from uuid
        makeLayerActiveFromUUID(uuid){
          const palette = Palettes.stores.layers.get().find(layer => layer.uuid == uuid);
          if(palette){
            this.makeLayerActive(palette);
          }
        },

        // layer index from source
        layerIndexFromSource(ColorPaletteGroupInstance){
          if(!(ColorPaletteGroupInstance instanceof ColorPaletteGroup)){
            throw new Error(`Invalid 'ColorPaletteGroupInstance' in 'layerIndexFromSource'`);
          }
          return value.layers.get().indexOf(ColorPaletteGroupInstance);
        },
        
        // update label
        updateLayerLabel(ColorPaletteGroupInstance, label){
          value.layers.update((_store) => {
            ColorPaletteGroupInstance.label = label;
            Palettes.makeLayerActive(ColorPaletteGroupInstance);
            return _store;
          });
        },

        // import 
        import(serializedData, isSerialized){
          const shouldMakeActive = Palettes.stores.layers.get().length <= 0;
          const unserializedData = isSerialized ? serializedData : JSON.parse(serializedData);
          if(unserializedData.version == config.filetypes.palettes.save.version){
            for(const palette of unserializedData.data){
              Palettes.createLayer({ ...palette }, true);
            }
          }
          if(shouldMakeActive && Palettes.stores.layers.length){
            Palettes.makeLayerActive(Palettes.stores.layers.get()[0]);
          }
        },

        // export
        export(serialize){
          const layers = Palettes.stores.layers.get();
          let data = { version: config.filetypes.palettes.save.version, data: [...layers] };
          if(serialize){
            data = JSON.stringify(data);
          }
          return data;
        },

        exportASMString(label = 'palettes'){
          const layers = Palettes.stores.layers.get();
          let i = 0;
          const strings = [];
          while(i < layers.length){
            const layer = layers[i];
            strings.push(`; ${layer.label}\n.byte ${layer.colors.map(c => '$' + c.hex).join(',')}`);
            i++;
          }
          return `${label}:\n${strings.join('\n')}`;
        },

        // clear all palettes 
        clear(){
          Palettes.stores.activeLayer.set(undefined);
          Palettes.stores.layers.set([]);
        }
      }
    });

    Spritesheets.stores;

    const AttributeTable$1 = _ => new Array(30).fill().map(_ => new Array(32).fill().map(_ => null));

    class TilemapLayer{
      constructor({ label, width, height, data, colorAttributes, uuid } ){
        this._isInitialized = false;
        this.uuid = uuid || Math.random() + Date.now();
        this.width = width || 256;
        this.height = height || 240;
        this.label = label || '';
        this.element = document.createElement('canvas');
        this.element.width = this.width;
        this.element.height = this.height;
        this.context = this.element.getContext('2d');
        this.image = new Image();
        this.data = data;
        
        // attributes tables
        // TODO: make canvas layer be able to switch between multiple attribute tables. 
        this.colorAttributes = colorAttributes;
        
        if(!this.colorAttributes){
          this.colorAttributes = AttributeTable$1();
        }

        // generate a double nested array list. 16x16 column then inside each tile they are 8x8 pixels wide
        if(!this.data){
          this.data = new Array(30).fill().map(_ => new Array(32).fill().map(_ => undefined));
        }
      }

      forceUpdate(source){
        this.drawFromSource(Palettes.stores.activeLayer.get(), source);
      }

      drawFromSource(){
        this.context.save();    
        for(const row in this.data){
          for(const col in this.data[row]){
            if(!this.data[row][col]){
              continue;
            }

            const { x, y, uuid } = this.data[row][col];
         
            // make sure we have values
            if(!(Number.isInteger(x) && Number.isInteger(y))){
              continue;
            }
            // draw from spritesheet
            const context = Spritesheets.stores.layers.get().find(layer => layer.uuid == uuid);
            if(!context?.element) return;

            this.context.drawImage(
              context.element,
              // position on target canvas
              x * 8, y * 8, 
              8, 8,
              // position on this canvas
              col * 8, row * 8, 
              8, 8, 
            );
            
            // remove the reference to prevent circular reference
            this.data[row][col] = { x, y, uuid };
          }
        }
      }
    }

    const layers$2 = writable$1([], ({ store, value, get }) => {
      return {
        // swap layers
        swapLayers(i, j){
          store.update(_store => {
            if(!_store[i] || !_store[j]){
              return _store;
            }
            [_store[i], _store[j]] = [_store[j], _store[i]]; 
            Tilemaps.stores.activeLayer.set(_store[j]);
            return _store;  
          });
        },
      }
    });

    const activeLayer$1 = writable$1(undefined);

    const Tilemaps = writable$1({ activeLayer: activeLayer$1, layers: layers$2 }, ({ store, value, get }) => {
      
      return {
        stores: value,

        // create new tilemap
        createLayer({ label, data, colorAttributes } = {}){
          Tilemaps.stores.layers.update(_store => {
            label = label || 'tilemap_' + (_store.length+1);
            const TilemapsLayerInstance = new TilemapLayer({ label, data, colorAttributes });
            const _store_copy = [TilemapsLayerInstance, ..._store];
            // make new layer active
            Tilemaps.makeLayerActive(TilemapsLayerInstance);
            return _store_copy;
          });
        },

        // remove layer 
        removeLayer(TilemapsLayerInstance){
          Tilemaps.stores.layers.update((_store) => {
            let _store_copy = [..._store];
            const index = _store_copy.indexOf(TilemapsLayerInstance);
            if(TilemapsLayerInstance == Tilemaps.stores.activeLayer.get()){
              // if there is a palette/layer after the currently removed, make that one the active one 
              if(_store_copy[index+1]){
                Tilemaps.makeLayerActive(_store_copy[index+1]);
              }else if(_store_copy[index-1]){
                Tilemaps.makeLayerActive(_store_copy[index-1]);
              }else {
                Tilemaps.stores.activeLayer.set(undefined);
              }
            }
            // remove object
            _store_copy = _store_copy.filter(instance => instance != TilemapsLayerInstance);
            return _store_copy;
          });
        },


        // TODO: fix everything below to work with tilemaps instead of spritesheets 

        // clone layer 
        cloneLayer(TilemapsLayerInstance){
          // TODO: make so the index position is right above the clones layer. currently
          // it gets added to the top of the stack as the first array element, which is not ideal.
          Tilemaps.stores.layers.update((_store) => {
            let { width, height, label, data, colorAttributes } = TilemapsLayerInstance;
            // we need to serialize the data else it will reference the same data
            if(Array.isArray(data)){
              data = JSON.parse(JSON.stringify(data));
              colorAttributes = JSON.parse(JSON.stringify(colorAttributes));
            }
            label = label + ' copy';
            const newLayer = new TilemapLayer({ width, height, label, data, colorAttributes });
            _store = [ newLayer, ..._store];
            Tilemaps.makeLayerActive(newLayer);
            return _store;  
          });
        },
        
        // clone active layer 
        cloneActiveLayer(){
          const active = Tilemaps.stores.activeLayer.get();
          if(active){
            Tilemaps.cloneLayer(active);
          }else {
            Tilemaps.createLayer();
          }
        },
        // make a layer active
        makeLayerActive(TilemapsLayerInstance){
          if(!(TilemapsLayerInstance instanceof TilemapLayer)){
            throw new Error(`Invalid 'TilemapsLayerInstance' while setting 'activeLayer'`);
          }
          Tilemaps.stores.activeLayer.set(TilemapsLayerInstance);
        },

        // update label
        updateLayerLabel(TilemapsLayerInstance, label){
          Tilemaps.stores.layers.update((_store) => {
            TilemapsLayerInstance.label = label;
            return _store;
          });
        },

        // import 
        import(data, isSerialized){
          const unserializedData = isSerialized ? data : JSON.parse(data);
          if(unserializedData.version != config.filetypes.tilemaps.save.version){
            console.warn(`Invalid file version.`);
            return;  
          }

          // import tilemaps
          for(const _tilemaps of [...unserializedData.data.layers].reverse()){
            Tilemaps.createLayer({ ..._tilemaps });
          }
        },

        // export 
        export(serialize){
          // get all layers
          const tilemapsLayer = JSON.parse(JSON.stringify(Tilemaps.stores.layers.get())).map(layer => {
            return { label: layer.label, data: layer.data, colorAttributes: layer.colorAttributes };
          });
          
          // build the data
          let data = { 
            version: config.filetypes.tilemaps.save.version, 
            data: { 
              layers: tilemapsLayer,
            }
          };

          if(serialize){
            data = JSON.stringify(data);
          }
          return data;
        },

        // import chr
        importCHR(filedata){
          const result = chr.parse(filedata);
          result.forEach(page => Tilemaps.createLayer({ data: page }));
        },

        // export chr
        exportCHR(){
          const activeLayer = Tilemaps.stores.activeLayer.get();
          if(!activeLayer || !activeLayer.data){
            throw new Error(`Unable to export CHR. No 'activeLayer'`);  
          }
          const bytearray = chr.generateExport(activeLayer.data);
          return { label: activeLayer.label, data: bytearray };
        },
        
        // export image
        exportAsImage(callback, mimetype = 'image/png', quality = 1){
          const activeLayer = Tilemaps.stores.activeLayer.get();
          if(!(activeLayer instanceof TilemapLayer)){
            throw new Error(`Unable to export Image. No 'activeLayer'`);
          }
          const fn = (blob) => {
            callback.call(null, { blob, label: activeLayer.label, options: { mimetype, quality } });
          };
          return { label: activeLayer.label, image: activeLayer.element.toBlob(fn, mimetype, quality), options: { type: mimetype } };
        },

        // NOTE: this is some placeholder code. needs to be sorted!
        exportNametableData(label){
          const activeLayer = Tilemaps.stores.activeLayer.get();
          label = label || activeLayer.label || 'nametable';  
          
          // NOTE: this will not work because we want to build our new chr file from all the tile references
          // that we use to create the tilemap. So the indexes has to be converted to the new position in the new 
          // chr source being generated.
          // y * 16 + x because the chr/spritesheet is 16x16 tiles
          const simulated = [...activeLayer.data].flat().map((props, i) => {
            if(!props?.x || !props?.y){
              return dec2hex(0, 2); 
            }
            return dec2hex((props.y * 16) + props.x, 2)
          });

          // chunk it so it's easier to read later on
          const chunked = chunk(simulated, 32);
          let output = `${label}:\n`;
          chunked.forEach((value) => output += `.byte ${value.map(v => '$' + v).join(', ')}\n`);
          output += `\n

; color the background tiles
attribute_table:
; 7654 3210
; |||| ||++- Color bits 3-2 for top left quadrant of this byte
; |||| ++--- Color bits 3-2 for top right quadrant of this byte
; ||++------ Color bits 3-2 for bottom left quadrant of this byte
; ++-------- Color bits 3-2 for bottom right quadrant of this byte
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000

      `; 

          return output; 
        },
        // clear all 
        clear(){
          Tilemaps.stores.activeLayer.set(undefined);
          Tilemaps.stores.layers.set([]);
        }
      }

    });

    // project store
    const Project = writable$1({ path: undefined }, ({ store, value, get, set }) => {
      return {
        create(){
          // reset the project path since there is no project anymore
          Project.set({ path: undefined });
          // clear all preview modal windows
          clear(); 
          // clear all project sections 
          Palettes.clear();
          Spritesheets.clear();
          Tilemaps.clear();
        },
        open(path, data){
          try{
            data = JSON.parse(data);
            if(data.project.version !== config.filetypes.project.save.version){
              throw new Error(`Invalid project version. Trying to load project file with version '${data.project.version}' but expecting '${config.filetypes.project.save.version}'`);
            }
            // set the path of the project
            Project.set({ path });
            // clear previous project. The check for saving should be done in the action
            // before even loading the new project data.
            Spritesheets.clear();
            Palettes.clear();
            Tilemaps.clear();
            // import new palettes 
            Palettes.import(data.palettes, true);
            // import spritesheets
            Spritesheets.import(data.spritesheets, true);
            // import new tilemaps 
            Tilemaps.import(data.tilemaps, true);

          }catch(error){
            throw new Error(error);
          }
        },
        export(serialize){
          const project = get();
          const spritesheets = Spritesheets.export();
          const palettes = Palettes.export();
          const tilemaps = Tilemaps.export();
          const data = {
            project: {
              ...project,
              version: config.filetypes.project.save.version
            },
            spritesheets,
            palettes,
            tilemaps
          };

          return serialize ? JSON.stringify(data) : data;
        }
      } 
    });

    // tools 
    const ToolTypes = new EnumerableList(
      'pointer', 
      'pen', 
      'paintbucket', 
      'eyedropper', 
      'colorswap', 
      'transform', 
      'marquee', 
      'zoom', 
      'preview', 
      'tileswap', 
      'preview_region',
      'tilecolor',
      'colorattribute',
      'brush',
      'text',
      'line',
      'circle'
    );

    class Cursor{
      constructor(props){
        this.icon = '';
        this.offset = {x: 0, y: 0};
        this.size = {width: 11, height: 11};
        this.scale = {x: 1, y: 1};
        Object.assign(this, props);
      }
    }

    class Tool{
      constructor(props){
        this.visible_in_toolbar = true;
        this.pixelIndicator = false;
        this.singleAction = false;
        this.optionsPanelComponent = undefined;
      }
      get optionsComponent(){
        return this.optionsPanelComponent;
      }
      onMount(){}
      onDestroy(){}
      primary(){}
      secondary(){}
      move(){}
      mouseup(){}
      reset(){}
    }

    class Pointer extends Tool{
      constructor(){
        super();

        this.title = 'Pointer (V)';
        this.name = 'pointer';
        this.enum = 'pointer';
        this.weight = 100;
        this.icon = 'M4 0l16 12.279-6.78 1.138 4.256 8.676-3.902 1.907-4.281-8.758-5.293 4.581z';
        this.cursor = new Cursor({});
      }
      primary({x, y, context}){}
      secondary({x, y, context}){}
      move({x, y, context}){}
    }

    class Layer{
      constructor(){
        this.canvas = document.createElement('canvas');
        this.canvas.width = 128;
        this.canvas.height = 128;
        this.context = this.canvas.getContext('2d');
      }
      render(){
        console.log('Render not implemented');
      }
    }

    class Grid extends Layer{
      constructor(...args){
        super(...args);
        this.width = 128;
        this.height = 128; 
        this.size = 8; 
        this.o1 = .05; 
        this.o2 = .005;
      }
      render(){
        this.context.clearRect(0,0,this.width, this.height);
        this.context.globalAlpha = 1;
        for(let ix = 0; ix <= (this.width/this.size); ix++){
          for(let iy = 0; iy <= (this.height/this.size); iy++){
              this.context.save();
              this.context.translate(ix*this.size, iy*this.size);
              if((ix+iy) % 2 == 0){
                this.context.globalAlpha = this.o1;
                this.context.fillStyle = 'white';
              }else {
                this.context.globalAlpha = this.o2;          
                this.context.fillStyle = 'black';
              }
              this.context.fillRect(0, 0, this.size, this.size);
              this.context.restore();
            
            // TODO: fix the gradient that occurs on each 8x8 tile.
            // also at the top, the first 8 rows is gradient shifted.
            // if(ix % this.size == 0){
            //   this.context.save();
            //   this.context.translate(ix, iy);
            //     if(((ix + iy) / this.size) % 2 == 0){
            //       this.context.fillStyle = 'white';
            //       this.context.globalAlpha = this.o1;              
            //     }else{
            //       this.context.fillStyle = 'black';
            //       // this.context.globalAlpha = this.o2;
            //     }
            //     this.context.fillRect(0,0,8,8);
            //   this.context.restore();
            // }
          }
        }
      }
    }

    class Cursor$1 extends Layer{
      constructor(...args){
        super(...args);
        this.width = 128;
        this.height = 128; 
        this.size = 1;
        this.x;
        this.y;
      }
      render(){
        if(isNaN(this.x) || isNaN(this.y)) return;
        this.context.clearRect(0, 0, this.width, this.height);
        this.context.globalAlpha = .4;
        this.context.fillStyle = 'white';
        this.context.fillRect(this.x, this.y, this.size, this.size);
      }
    }

    class TileCursor extends Layer{
      constructor(...args){
        super(...args);
        this.width = 128;
        this.height = 128; 
        this.size = 8;
        this.x;
        this.y;
        this.framecount = 0;
        this.count = 0;

        this.selected = [];
      }
      addSelectedTileItem(x, y){
        this.selected.push({ x, y });
      }
      clearSelected(){
        this.selected = [];
      }
      draw(x, y, color){
        this.context.save();
        x = Math.floor(x / 8) * this.size;
        y = Math.floor(y / 8) * this.size;
        this.context.globalAlpha = .85;
        this.context.strokeStyle = color;
        // this.context.setLineDash([8, 2]);
        this.context.strokeRect(x, y, this.size-1, this.size-1);
        this.context.restore();  
      }
      render(){
        let color = this.count % 2 == 0 ? 'rgba(255,255,255,.98)' : 'crimson';
        if(isNaN(this.x) || isNaN(this.y)) return;
        if(this.framecount++ % 16 == 0){
          this.count++;
        }
        this.context.clearRect(0, 0, this.width, this.height);
        this.context.save();
          this.context.translate(.5, .5);
          this.selected.forEach(({ x, y }) => {
            this.draw(x, y, this.count % 2 == 0 ? 'rgba(255,255,255,.98)' : 'crimson');
          });
          this.draw(this.x, this.y, color);
        this.context.restore();
      }
    }

    class MarqueeCursor extends Layer{
      constructor(...args){
        super(...args);
        this.width = 128;
        this.height = 128; 
        this.size = 8;
        this.start;
        this.end;
        this.selection;
        this.framecount = 0;
        this.count = 0;
        this.selectionIsVisible = true;
      }
      hasSelection(){
        return !!this.selection?.start && !!this.selection?.end;
      }
      removeSelection(){
        this.selection = undefined;
        this.start = undefined;
        this.end = undefined; 
      }
      addSelection({ start, end } = {}){
        if(!start || !end){
          start = this.start;
          end = this.end;
        }
        this.selection = { start, end };
      }
      draw({ start, end, color = 'crimson', dash }){
        if(!start || !end) return;
        // limit to canvas bounds
        end.x = Math.min(Math.max(end.x, 0), this.width-1);
        end.y = Math.min(Math.max(end.y, 0), this.width-1);
        this.context.save();
        this.context.translate(.5, .5);
        this.context.globalAlpha = .8;
        if(dash){
          this.context.setLineDash(dash);
        }
        this.context.strokeStyle = color;
        this.context.strokeRect(start.x, start.y, end.x - start.x, end.y - start.y);
        this.context.restore();
      }
      render(){
        if(this.framecount++ % 16 == 0){
          this.count++;
        }
        this.context.clearRect(0, 0, this.width, this.height);
        if(this.selectionIsVisible){
          // draw selection
          this.draw({ ...this.selection, color: this.count % 2 == 0 ? 'white' : 'crimson' });
        }
        // draw handler
        this.draw({ start: this.start, end: this.end, color: this.count % 2 == 0 ? 'white' : 'crimson' });
      }
    }

    const getFillStyle = rgb => `rgb(${rgb.join(',')})`;
    class ColorAttributes extends Layer{
      constructor(...args){
        super(...args);
        this.width = 128;
        this.height = 128; 
        this.size = 8;
        this.alpha = .45;
        this.visible = true;  
      }
      hide(){
        this.visible = false;
      }
      show(){
        this.visible = true;
      }
      toggle(){
        this.visible = !this.visible;
      }
      render(){
        this.context.clearRect(0, 0, this.width, this.height);
        if(!this.visible) return;
        const attributetable = Spritesheets.stores.activeLayer.get().colorAttributes;
        if(!attributetable?.length) return;
        for(let x in attributetable){
          for(let y in attributetable[x]){
            const colors = attributetable[x][y]?.colors;
            if(!colors?.length){
              continue;
            }        this.context.save();
            this.context.globalAlpha = this.alpha;
            this.context.translate(x*this.size, y*this.size);
            const [one, two, three, four] = colors;
            // top left
            this.context.fillStyle = getFillStyle(one.rgb);
            this.context.fillRect(0, 0, this.size/2, this.size/2);
            
            // top right
            this.context.fillStyle = getFillStyle(two.rgb);
            this.context.fillRect(0, 4, this.size/2, this.size/2);

            // bottom left
            this.context.fillStyle = getFillStyle(three.rgb);
            this.context.fillRect(4, 0, this.size/2, this.size/2);

            // bottom right
            this.context.fillStyle = getFillStyle(four.rgb);
            this.context.fillRect(4, 4, this.size/2, this.size/2);
            
            this.context.restore();
          }
          
        }
      }
    }

    class BrushCursor extends Layer{
      constructor(...args){
        super(...args);
        this.width = 128;
        this.height = 128; 
        this.size = 8;
        this.start;
        this.end;
        this.selection;
        this.framecount = 0;
        this.count = 0;
        this.selectionIsVisible = true;
      }
      hasSelection(){
        return !!this.selection?.start && !!this.selection?.end;
      }
      removeSelection(){
        this.selection = undefined;
        this.start = undefined;
        this.end = undefined; 
      }
      addSelection({ start, end } = {}){
        if(!start || !end){
          start = this.start;
          end = this.end;
        }
        this.selection = { start, end };
      }
      draw({ start, end, color = 'crimson', dash }){
        if(!start || !end) return;
        // limit to canvas bounds
        end.x = Math.min(Math.max(end.x, 0), this.width-1);
        end.y = Math.min(Math.max(end.y, 0), this.width-1);
        this.context.save();
        this.context.translate(.5, .5);
        this.context.globalAlpha = .8;
        if(dash){
          this.context.setLineDash(dash);
        }
        this.context.strokeStyle = color;
        this.context.strokeRect(start.x, start.y, end.x - start.x, end.y - start.y);
        this.context.restore();
      }
      render(){
        if(this.framecount++ % 16 == 0){
          this.count++;
        }
        this.context.clearRect(0, 0, this.width, this.height);
        if(this.selectionIsVisible){
          // draw selection
          this.draw({ ...this.selection, color: this.count % 2 == 0 ? 'white' : 'crimson' });
        }
        // draw handler
        this.draw({ start: this.start, end: this.end, color: this.count % 2 == 0 ? 'white' : 'crimson' });
      }
    }

    const Type = Object.freeze({ primary: 1, secondary: 2, move: 3, mouseup: 4 });

    // cursors
    const PixelCursor = new Cursor$1();
    const TileCursor$1 = new TileCursor();
    const MarqueeCursor$1 = new MarqueeCursor();
    const BrushCursor$1 = new BrushCursor();

    // overlays
    const ColorAttributesOverlay = new ColorAttributes();
    const GridOverlay = new Grid();

    const overlays = [
      GridOverlay,
    ];

    class SpritesheetEditor{
      constructor({ canvas, context, width, height }){
        this.activeLayer = undefined;
        this.activePaletteLayer = undefined;
        this.lastChanged = undefined;

        this.canvas;
        this.context;

        this.width = width;
        this.height = height;

        const fps = 120;
        this.animationLoop = AnimationLoop(this.render.bind(this), fps);
        
        this.events = {};
        this.eventHandler = {};

        const callActionType = (type, e) => {
          e.mouseIsDown = mouseIsDown;
          switch(type){
            case Type.primary:
              callEvent('primary', e);
            break;
            case Type.secondary:
              callEvent('secondary', e);
            break;
            case Type.move:
              callEvent('move', e); 
            break;
            case Type.mouseup:
              callEvent('mouseup', e); 
            break;
            default:
              console.log('hmm...');
          }
        };

        // temp to see if mouse pos handles the transform css scale
        function  getMousePos(canvas, evt) {
          if(!canvas) return {x: 0, y: 0};
          const rect = canvas.getBoundingClientRect(), // abs. size of element
            scaleX = canvas.width / rect.width,    // relationship bitmap vs. element for X
            scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for Y
        
          return {
            x: Math.floor((evt.clientX - rect.left) * scaleX),   // scale mouse coordinates after they have
            y: Math.floor((evt.clientY - rect.top) * scaleY)     // been adjusted to be relative to element
          }
        }

        const callEvent = (type, e) => {
          if(this.events[type]){
            e.realMousePosition = getMousePos(this.canvas, e); 
            this.events[type].call(null, e);
          }
        };
        // handle event actions
        let mouseIsDown = false;
        this.eventHandler.mousemove = (e) => {
          callActionType(Type.move, e);
        };
        this.eventHandler.mouseup = e => {
          mouseIsDown = false;
          callActionType(Type.mouseup, e);
        };
        this.eventHandler.mousedown = (e) => {
          mouseIsDown = true;
          let type;
          if(e.which == 1){
            type = Type.primary;
          }else if(e.which == 3){
            type = Type.secondary;
          }else {
            return;
          }
          callActionType(type, e);
        };

        // bind events
        document.addEventListener('mousemove', this.eventHandler.mousemove);
        document.addEventListener('mouseup', this.eventHandler.mouseup);
      }

      defineCanvas(canvas){
        this.canvas = canvas;
        this.context = this.canvas.getContext('2d');
        this.canvas.addEventListener('mousedown', this.eventHandler.mousedown);
      }

      on(event, fn){
        if(typeof event != 'string' && typeof fn !== 'function'){
          throw new Error(`Invalid eventlistener`);
        }
        if(this.events[event]){
          throw new Error(`Event already exists : ${event}`);
        }
        this.events[event] = fn;
      }

      // render
      render(args){
        if(!this.canvas) return;

        this.context.clearRect(0,0, 128, 128);
        const activeLayer = Spritesheets.stores.activeLayer.get();
        const activePaletteLayer = Palettes.stores.activeLayer.get();
        if(activeLayer && activePaletteLayer){
          if(this.lastChanged != Palettes.lastChanged.get() || (this.activeLayer != activeLayer || this.activePaletteLayer != activePaletteLayer)){
            // set the current active layers
            this.activeLayer = activeLayer;
            this.activePaletteLayer = activePaletteLayer;
            // draw from source
            activeLayer.drawFromSource(activePaletteLayer);
            // store last change to palettes so we can force an update
            this.lastChanged = Palettes.lastChanged.get();
          }
          // draw active layer on the canvas context
          this.context.drawImage(activeLayer.element, 0,0);
          // draw overlay layers
          overlays.forEach((layer) => {
            layer.render(args);
            this.context.drawImage(layer.canvas, 0, 0);
          });

          // draw cursors
          (Toolbar.activeTool.get().cursorLayers || []).forEach((cursor) => {
            cursor.render(args);
            this.context.drawImage(cursor.canvas, 0, 0);  
          });
          
        }
      }
      // clean up
      destroy(){
        // stop animationframe
        this.animationLoop.unsubscribe();
        // clean up events
        if(this.canvas){
          this.canvas.removeEventListener('mousedown', this.eventHandler.mousedown);
        }
        document.removeEventListener('mousemove', this.eventHandler.mousemove);
        document.removeEventListener('mouseup', this.eventHandler.mouseup);
      }
    }

    class Pen extends Tool{
      constructor(withHotkeys = true){
        super();
        this.cursorLayers = [
          PixelCursor
        ];

        if(withHotkeys){
          this.hotkeysGroups = ['pen'];
          manager.set(['AltLeft'], { groups: this.hotkeysGroups })
          .on(_ => {
            actions.execute('spritesheet_set_active_tool', 'eyedropper');
          })
          .off(_ => {
            actions.execute('spritesheet_set_active_tool', 'pen');
          });
        }

        this.title = 'Pen (B)';
        this.name = 'pen';
        this.enum = 'pen';
        this.weight = 90;
        this.icon = 'M19.769 9.923l-12.642 12.639-7.127 1.438 1.438-7.128 12.641-12.64 5.69 5.691zm1.414-1.414l2.817-2.82-5.691-5.689-2.816 2.817 5.69 5.692z';
        this.cursor = new Cursor({
          icon: 'M19.769 9.923l-12.642 12.639-7.127 1.438 1.438-7.128 12.641-12.64 5.69 5.691zm1.414-1.414l2.817-2.82-5.691-5.689-2.816 2.817 5.69 5.692z',
          size: {
            width: 46,
            height: 46,
          },
          offset: {
            x: 0, 
            y: 11
          }
        });

        this.properties = {
          size: 1,
          direction: undefined,
          drawStack: [],
          lastDraw: undefined,
          start: undefined,
        };
        // store modified pixels
        this.modifiedPixels = [];
      }

      paint(e){
        const attributesTable = Spritesheets.stores.activeLayer?.get().colorAttributes;
        const context = Spritesheets.stores.activeLayer.get()?.context;
        if(!context){
          // throw new Error('Error loading context');
          return;
        }
        // loop over the stack
        this.properties.drawStack.map(item => {
          const { x, y } = item.realMousePosition;
          
          const tilePos = { x: Math.floor(x / 8), y: Math.floor(y / 8) };
          const index = Number.isInteger(e.colorIndex) ? e.colorIndex : Palettes.stores.selectedColor.get();

          let colorData = Palettes.stores.selectedColor.getActiveColorValue(index);
          if(!colorData){
            return;
          }
          
          if(tilePos.x >= 0 && tilePos.x <= 15 && tilePos.y >= 0 && tilePos.y <= 15){
            colorData = attributesTable[tilePos.x] && attributesTable[tilePos.x][tilePos.y] && attributesTable[tilePos.x][tilePos.y].colors[index] ? attributesTable[tilePos.x][tilePos.y].colors[index] : colorData;
          }

          context.save();
            context.translate(x, y);
            context.fillStyle = `rgb(${colorData.rgb.join(',')})`;
            context.fillRect(0, 0, this.properties.size, this.properties.size);
            // NOTE: this will currently not work with anything other than 1 px size pen
            // store the modified pixels
            this.modifiedPixels.push({ x, y, colorIndex: index });
          context.restore();
        });
        this.properties.lastDraw = this.properties.drawStack.pop();
        this.properties.drawStack = [];
      }

      primary(props, notIgnore){
        props.realMousePosition;
        if(props.shiftKey){
          this.drawLineFromPoint(props, { ...props.realMousePosition });
        }else {
          this.properties.drawStack.push(props);
        }
        this.paint.call(this, props);
      }

      secondary(props){
        props.colorIndex = 0;
        this.primary(props);
      }

      drawLineFromPoint(props, end){
        if(!this.properties.start){
          return;
        }

        let { x, y } = this.properties.start;
        if(Math.abs(end.x - x) > Math.abs(end.y - y)){
          while(x != end.x){
            if(x < end.x) x++;
            if(x > end.x) x--;
            this.properties.drawStack.push({ ...props, realMousePosition: { x, y } });
          }
        }else {
          while(y != end.y){
            if(y < end.y) y++;
            if(y > end.y) y--;
            this.properties.drawStack.push({ ...props, realMousePosition: { x, y } });
          }
        }

      }
      move(props){
        let { x: _x, y: _y } = props.realMousePosition;
        // update cursor position
        PixelCursor.x = _x;
        PixelCursor.y = _y;

        if(!props.mouseIsDown){
          return;
        }else {
          this.properties.start = undefined;
        }

        // clamp the largest of x and y if shift key is 
        // down so we can draw in a straight line
        // if(props.shiftKey && this.properties.static){}
        
        const fillStack = (props) => {
          if(this.properties.lastDraw){
            let { x, y } = { ...this.properties.lastDraw.realMousePosition };
            while(x != _x || y != _y){
              if(x < _x) x++;
              if(x > _x) x--;
              if(y < _y) y++;
              if(y > _y) y--;
              this.properties.drawStack.push({...props, realMousePosition: { x, y } });
            }
          }else {
            this.properties.drawStack.push(props);
          }
        };
        
        if(props.which == 1){
          // call the primary action
          fillStack(props);
          this.primary.call(this, props, true);
        }else if(props.which == 3){
          fillStack(props);
          this.secondary.call(this, props);
        }
      }
      
      mouseup(){
        const dataRef = Spritesheets.stores.activeLayer.get()?.data;
        if(!dataRef){
          return;
        }

        // save history before drawing new
        if(this.modifiedPixels.length){
          Spritesheets.stores.activeLayer.get().saveHistory();
        }
        
        // update data with new pixelinformation
        for(const pixel of this.modifiedPixels){
          let {x, y, colorIndex } = pixel;
          const rc = {x: Math.floor(x / 8), y: Math.floor(y / 8)};
          const tile = {x: x % 8, y: y % 8};
          // wtf is this??? well whatever.. 
          if(dataRef[rc.y] && dataRef[rc.y][rc.x] && dataRef[rc.y][rc.x][tile.y] && Number.isInteger(dataRef[rc.y][rc.x][tile.y][tile.x])){
            dataRef[rc.y][rc.x][tile.y][tile.x] = colorIndex;
          }
        }    
        // same last pixel which will be the start for the next draw. if drawing line for instance
        const lastPixel = this.modifiedPixels[this.modifiedPixels.length-1];
        if(lastPixel){
          // store the last pixel as the starting position
          this.properties.start = { ...lastPixel };
          Spritesheets.stores.activeLayer.get().setPresent();
        }
        
        this.modifiedPixels = [];
      }
    }

    class Eyedropper extends Tool{
      constructor(){
        super();
        this.cursorLayers = [
          PixelCursor
        ];

        this.title = 'Eyedropper (E)';
        this.name = 'eyedropper';
        this.enum = 'eyedropper';
        this.weight = 95;
        this.icon = 'M12.142 13.178l1.506 1.318-6.83 7.6c-1.31 1.464-2.22.315-3.953 1.647-.232.178-.483.257-.724.257-.601 0-1.141-.49-1.141-1.151 0-.218.062-.455.196-.698.978-1.791-.129-2.629 1.148-4.052l6.787-7.555 1.505 1.317-3.727 4.139h2.691l2.542-2.822zm5.764-13.178c-2.434 0-4.871 1.707-4.797 5.831.021 1.167-.356 1.698-.884 1.698-.298 0-.597-.169-.877-.386-.407-.315-.99-.26-1.331.129-.374.426-.329 1.076.096 1.448l5.253 4.598c.423.371 1.067.328 1.438-.096.343-.392.32-.979-.049-1.345-.277-.275-.501-.581-.501-.913 0-.479.486-.876 1.572-1.002 3.69-.428 5.174-2.656 5.174-4.88 0-2.799-2.149-5.082-5.094-5.082z';
        this.cursor = new Cursor({
          icon: 'M12.142 13.178l1.506 1.318-6.83 7.6c-1.31 1.464-2.22.315-3.953 1.647-.232.178-.483.257-.724.257-.601 0-1.141-.49-1.141-1.151 0-.218.062-.455.196-.698.978-1.791-.129-2.629 1.148-4.052l6.787-7.555 1.505 1.317-3.727 4.139h2.691l2.542-2.822zm5.764-13.178c-2.434 0-4.871 1.707-4.797 5.831.021 1.167-.356 1.698-.884 1.698-.298 0-.597-.169-.877-.386-.407-.315-.99-.26-1.331.129-.374.426-.329 1.076.096 1.448l5.253 4.598c.423.371 1.067.328 1.438-.096.343-.392.32-.979-.049-1.345-.277-.275-.501-.581-.501-.913 0-.479.486-.876 1.572-1.002 3.69-.428 5.174-2.656 5.174-4.88 0-2.799-2.149-5.082-5.094-5.082z',
          size: {
            width: 46,
            height: 46,
          },
          offset: {
            x: 0, 
            y: 10
          }  
        });
      }
      primary(props){
        const { x, y } = props.realMousePosition;
        // set active color index
        const colorIndex = Spritesheets.stores.activeLayer.get().colorIndexAtPosition(x, y);
        if(Number.isInteger(colorIndex)){
          Palettes.stores.selectedColor.set(colorIndex);
        }
      }
      secondary(props){}
      move(props){
        // update cursor position
        PixelCursor.x = props.realMousePosition.x;
        PixelCursor.y = props.realMousePosition.y;
        
      }
    }

    class Paintbucket extends Tool{
      constructor(withHotkeys = true){
        super();
        this.cursorLayers = [
          PixelCursor
        ];

        if(withHotkeys){
          this.hotkeysGroups = ['paintbucket'];
          manager.set(['AltLeft'], { groups: this.hotkeysGroups })
          .on(_ => {
            actions.execute('spritesheet_set_active_tool', 'eyedropper');
          })
          .off(_ => {
            actions.execute('spritesheet_set_active_tool', 'paintbucket');
          });
        }
        
        this.title = 'Paintbucket (G)';
        this.name = 'paintbucket';
        this.enum = 'paintbucket';
        this.weight = 80;
        this.icon = 'M24 19.007c0-3.167-1.409-6.771-2.835-9.301l-.006-.01-.014-.026c-.732-1.392-1.914-3.052-3.619-4.757-2.976-2.976-5.476-3.912-6.785-3.913-.413 0-.708.094-.859.245l-.654.654c-1.898-.236-3.42.105-4.294.982-.876.875-1.164 2.159-.792 3.524.242.893.807 1.891 1.752 2.836.867.867 2.062 1.684 3.615 2.327.488-.839 1.654-1.019 2.359-.315.586.586.584 1.533-.002 2.119s-1.533.589-2.121 0c-.229-.229-.366-.515-.416-.812-1.646-.657-3.066-1.534-4.144-2.612-.728-.728-1.289-1.528-1.664-2.349l-2.835 2.832c-.445.447-.685 1.064-.686 1.82.001 1.635 1.122 3.915 3.714 6.506 2.764 2.764 5.58 4.243 7.431 4.243.649 0 1.181-.195 1.548-.562l8.086-8.079c.911.875-.777 3.541-.777 4.65 0 1.104.896 1.999 2 1.998 1.104 0 1.998-.895 1.998-2zm-18.912-12.974c-.236-.978-.05-1.845.554-2.444.526-.53 1.471-.791 2.656-.761l-3.21 3.205zm9.138 2.341l-.03-.029c-1.29-1.291-3.802-4.354-3.095-5.062.715-.715 3.488 1.521 5.062 3.095.862.863 2.088 2.248 2.938 3.459-1.718-1.073-3.493-1.469-4.875-1.463zm-3.875 12.348c-.547-.082-1.5-.547-1.9-.928l7.086-7.086c.351.37 1.264.931 1.753 1.075l-6.939 6.939z';
        this.cursor = new Cursor({
          icon: 'M24 19.007c0-3.167-1.409-6.771-2.835-9.301l-.006-.01-.014-.026c-.732-1.392-1.914-3.052-3.619-4.757-2.976-2.976-5.476-3.912-6.785-3.913-.413 0-.708.094-.859.245l-.654.654c-1.898-.236-3.42.105-4.294.982-.876.875-1.164 2.159-.792 3.524.242.893.807 1.891 1.752 2.836.867.867 2.062 1.684 3.615 2.327.488-.839 1.654-1.019 2.359-.315.586.586.584 1.533-.002 2.119s-1.533.589-2.121 0c-.229-.229-.366-.515-.416-.812-1.646-.657-3.066-1.534-4.144-2.612-.728-.728-1.289-1.528-1.664-2.349l-2.835 2.832c-.445.447-.685 1.064-.686 1.82.001 1.635 1.122 3.915 3.714 6.506 2.764 2.764 5.58 4.243 7.431 4.243.649 0 1.181-.195 1.548-.562l8.086-8.079c.911.875-.777 3.541-.777 4.65 0 1.104.896 1.999 2 1.998 1.104 0 1.998-.895 1.998-2zm-18.912-12.974c-.236-.978-.05-1.845.554-2.444.526-.53 1.471-.791 2.656-.761l-3.21 3.205zm9.138 2.341l-.03-.029c-1.29-1.291-3.802-4.354-3.095-5.062.715-.715 3.488 1.521 5.062 3.095.862.863 2.088 2.248 2.938 3.459-1.718-1.073-3.493-1.469-4.875-1.463zm-3.875 12.348c-.547-.082-1.5-.547-1.9-.928l7.086-7.086c.351.37 1.264.931 1.753 1.075l-6.939 6.939z',
          offset: {
            x: 3.5, 
            y: 11
          },
          size: {
            width: 46,
            height: 46,
          },
        });

        // properties 
        this.properties = {
          diagonals: false,
        };
      }
      fillPixelsInsideTile(x, y, selectedColorIndex){
        const fillValue = selectedColorIndex >= 0 && selectedColorIndex <= 3 ? selectedColorIndex :  Palettes.stores.selectedColor.get();

        const tile = {
          x: Math.floor(x / 8),
          y: Math.floor(y / 8)
        };
        
        const pixelData = Spritesheets.stores.activeLayer.get()?.data[tile.y][tile.x];
        // starting color
        const pixelValue = Spritesheets.stores.activeLayer.get().colorIndexAtPosition(x, y); 

        if(pixelData){
          // store pixels in an array
          const pixels = [{ x: x % 8, y: y % 8 }];
          while(pixels.length){
            let { x: _x, y: _y} = pixels.shift();
            let a = _y % 8;
            let b = _x % 8;

            if(_x < 0 || _x > 7){
              continue;
            }
            if(_y < 0 || _y > 7){
              continue;
            }
            const colorIndex = pixelData[_y][_x];
            // make sure it's the same colorIndex
            if(colorIndex == fillValue){
              continue;
            }
            if(colorIndex != pixelValue){
              continue;
            }
            
            // upate color index
            pixelData[a][b] = fillValue;

            // check top, down, left, right directions
            pixels.push({ x: b, y: a + 1 });
            pixels.push({ x: b, y: a - 1 });
            pixels.push({ x: b - 1, y: a });
            pixels.push({ x: b + 1, y: a });

            // if we also want diagonals
            // TODO: implement this in the sub toolbar as options where the user
            // am able to toggle this preference
            if(this.properties.diagonals){
              pixels.push({ x: b + 1, y: a + 1 });
              pixels.push({ x: b - 1, y: a - 1 });
              pixels.push({ x: b + 1, y: a - 1 });
              pixels.push({ x: b - 1, y: a + 1 });
            }
          }
        }
        Spritesheets.stores.activeLayer.get().forceUpdate();
        // throw new Error('Not implemented: fills all pixels inside a tile')
      }
      fill({x, y, selectedColorIndex, fillAllNoneZeroColoredPixels}){
        // fill value 
        const fillValue = selectedColorIndex >= 0 && selectedColorIndex <= 3 ? selectedColorIndex :  Palettes.stores.selectedColor.get();
        // starting color
        const pixelValue = Spritesheets.stores.activeLayer.get().colorIndexAtPosition(x, y); 
        // store pixels in an array
        const pixels = [{ x, y }];

        while(pixels.length){
          const { x: _x, y: _y} = pixels.shift();
          if(_y < 0 || _y > 127){
            continue;
          }
          if(_x < 0 || _x > 127){
            continue;
          }
          const colorIndex = Spritesheets.stores.activeLayer.get().colorIndexAtPosition(_x, _y);
          
          if(fillAllNoneZeroColoredPixels){
            if(colorIndex == 0){
              continue;
            }
          }else {
            // make sure it's the same colorIndex
            if(colorIndex == fillValue){
              continue;
            }
            if(colorIndex != pixelValue){
              continue;
            }
          }
          
          // upate color index
          Spritesheets.stores.activeLayer.get().setColorIndexAtPosition(_x, _y, fillAllNoneZeroColoredPixels ? 0 : fillValue);

          // check top, down, left, right directions
          pixels.push({ x: _x, y: _y + 1 });
          pixels.push({ x: _x, y: _y - 1 });
          pixels.push({ x: _x - 1, y: _y });
          pixels.push({ x: _x + 1, y: _y });

          // if we also want diagonals
          // TODO: implement this in the sub toolbar as options where the user
          // am able to toggle this preference
          if(this.properties.diagonals){
            pixels.push({ x: _x + 1, y: _y + 1 });
            pixels.push({ x: _x - 1, y: _y - 1 });
            pixels.push({ x: _x + 1, y: _y - 1 });
            pixels.push({ x: _x - 1, y: _y + 1 });
          }
        }

        
        // force a spritesheet update
        Spritesheets.stores.activeLayer.get().forceUpdate();
      }

      fillAllPixelsInASpriteSheet(x, y, selectedColorIndex){
        // fill value 
        const fillValue = selectedColorIndex >= 0 && selectedColorIndex <= 3 ? selectedColorIndex :  Palettes.stores.selectedColor.get();
        // starting color
        const pixelValue = Spritesheets.stores.activeLayer.get().colorIndexAtPosition(x, y); 

        if(fillValue == pixelValue){
          return;
        }

        // apply to all pixels
        Spritesheets.stores.activeLayer.update((store) => {
          for(let row in store.data){
            for(let col in store.data[row]){
              for(let tr in store.data[row][col]){
                for(let tc in store.data[row][col][tr]){
                  if(store.data[row][col][tr][tc] == pixelValue){
                    store.data[row][col][tr][tc] = fillValue;
                  }
                }
              }
            }
          }
          
          return store;
        });

        // update canvas
        Spritesheets.stores.activeLayer.get().forceUpdate();
      }

      fillAllPixelsInATile(tilex, tiley, x, y, selectedColorIndex){
        // fill value 
        const fillValue = selectedColorIndex >= 0 && selectedColorIndex <= 3 ? selectedColorIndex : Palettes.stores.selectedColor.get();
        // starting color
        const pixelValue = Spritesheets.stores.activeLayer.get().colorIndexAtPosition(x, y); 

        if(fillValue == pixelValue){
          return;
        }

        // apply to all pixels
        Spritesheets.stores.activeLayer.update((store) => {
          for(let tr in store.data[tiley][tilex]){
            for(let tc in store.data[tiley][tilex][tr]){
              if(store.data[tiley][tilex][tr][tc] == pixelValue){
                store.data[tiley][tilex][tr][tc] = fillValue;
              }
            }
          }
          
          return store;
        });

        // update canvas
        Spritesheets.stores.activeLayer.get().forceUpdate();
      }

      fillAllPixelsWithBackground({ x, y }){
        this.fill({ x, y, fillAllNoneZeroColoredPixels: true });
      }

      primary(props){
        // save a history before
        Spritesheets.stores.activeLayer.get().saveHistory();
        const { x, y } = props.realMousePosition;

        if(props.ctrlKey && props.shiftKey && props.altKey){
          this.fillAllPixelsWithBackground({ x, y });
        }else {
          if(props.shiftKey){
            if(props.ctrlKey){
              // fill all pixels inside a tile
              this.fillAllPixelsInATile(Math.floor(x / 8), Math.floor(y / 8), x, y);
            }else {
              this.fillAllPixelsInASpriteSheet(x, y);
            }
          }else if(props.ctrlKey){
            // TODO: fill ony pixels inside a 8x8 tile
            this.fillPixelsInsideTile(x, y);
          }else {
            this.fill({ x, y });
          }
        }

        // present is current after this draw call
        Spritesheets.stores.activeLayer.get().setPresent();
      }
      
      secondary(props){
        const { x, y } = props.realMousePosition;
        // save history before
        Spritesheets.stores.activeLayer.get().saveHistory();
        
        if(props.ctrlKey && props.shiftKey && props.altKey){
          this.fillAllPixelsWithBackground({ x, y });
        }else {
          if(props.shiftKey){
            if(props.ctrlKey){
              // fill all pixels inside a tile
              this.fillAllPixelsInATile(Math.floor(x / 8), Math.floor(y / 8), x, y, 0);
            }else {
              this.fillAllPixelsInASpriteSheet(x, y, 0);
            }
          }else if(props.ctrlKey){
            // TODO: fill ony pixels inside a 8x8 tile
            this.fillPixelsInsideTile(x, y, 0);
          }else {
            this.fill({ x, y, selectedColorIndex: 0 });
          }
        }
        // present is the current after this draw
        Spritesheets.stores.activeLayer.get().setPresent();
      }

      move(props){
        // update cursor position
        PixelCursor.x = props.realMousePosition.x;
        PixelCursor.y = props.realMousePosition.y;
      }
    }

    class Colorswap extends Tool{
      constructor(withHotkeys = true){
        super();

        if(withHotkeys){
          this.hotkeysGroups = ['colorswap'];
          manager.set(['Escape'], { data: { action: actions.action('tool_action'), props: _ => this.properties.swappedColors = [] }, groups: this.hotkeysGroups });
        }
        
        this.cursorLayers = [
          PixelCursor
        ];
        
        this.title = 'Color swap (S)';
        this.name = 'colorswap';
        this.enum = 'colorswap';
        this.weight = 60;
        this.icon = 'M1 12.155c2.256 3.97 4.55 7.918 6.879 11.845h-5.379c-.829 0-1.5-.675-1.5-1.5v-10.345zm2.85.859c3.278 1.952 12.866 7.658 13.121 7.805l-5.162 2.98c-.231.132-.49.201-.751.201-.549 0-1.037-.298-1.299-.75l-5.909-10.236zm1.9-12.813c-.23-.133-.489-.201-.75-.201-.524 0-1.026.277-1.299.75l-3.5 6.062c-.133.23-.201.489-.201.749 0 .527.278 1.028.75 1.3 2.936 1.695 14.58 8.7 17.516 10.396.718.413 1.633.168 2.048-.55l3.5-6.062c.133-.23.186-.488.186-.749 0-.52-.257-1.025-.734-1.3l-17.516-10.395m.25 3.944c1.104 0 2 .896 2 2s-.896 2-2 2-2-.896-2-2 .896-2 2-2';
        this.cursor = new Cursor({
          icon: 'M12.142 13.178l1.506 1.318-6.83 7.6c-1.31 1.464-2.22.315-3.953 1.647-.232.178-.483.257-.724.257-.601 0-1.141-.49-1.141-1.151 0-.218.062-.455.196-.698.978-1.791-.129-2.629 1.148-4.052l6.787-7.555 1.505 1.317-3.727 4.139h2.691l2.542-2.822zm5.764-13.178c-2.434 0-4.871 1.707-4.797 5.831.021 1.167-.356 1.698-.884 1.698-.298 0-.597-.169-.877-.386-.407-.315-.99-.26-1.331.129-.374.426-.329 1.076.096 1.448l5.253 4.598c.423.371 1.067.328 1.438-.096.343-.392.32-.979-.049-1.345-.277-.275-.501-.581-.501-.913 0-.479.486-.876 1.572-1.002 3.69-.428 5.174-2.656 5.174-4.88 0-2.799-2.149-5.082-5.094-5.082z',
          size: {
            width: 46,
            height: 46,
          },
          offset: {
            x: 0, 
            y: 10
          }  
        });
        this.properties = {
          swappedColors: []
        };
      }
      primary(props){
        const { x, y } = props.realMousePosition;
        // store clicked on tiles
        this.properties.swappedColors.push({
          column: Math.floor(x / 8), 
          row: Math.floor(y / 8),
          x: x % 8, 
          y: y % 8
        });
        // if color length is greater than 1 then swap the two
        if(this.properties.swappedColors.length > 1){
          const activeLayer = Spritesheets.stores.activeLayer; 
          activeLayer.get().saveHistory();
          activeLayer.update(_store => {
            const [ first, second ] = this.properties.swappedColors;
            const temp = [..._store.data];
            let a = temp[first.row][first.column][first.y][first.x];
            let b = temp[second.row][second.column][second.y][second.x];
            
            if(a == b) return _store;

            // NOTE: this will only swap in the tile where the first value got taken from
            // I think this makes sense instead fo switching on both the tiles if they 
            // would be different. 
            if(props.altKey){
              _store.data[first.row][first.column].forEach((row, r) => {
                row.forEach((col, c) => {
                  let val;
                  if(col == a){
                    val = b;
                  }else if(col == b){
                    val = a;
                  }
                  if(Number.isInteger(val)){
                    _store.data[first.row][first.column][r][c] = val;
                  }
                });
              });
            }else {
              // geezuz!! i really don't like this nested 2d array :S
              // one line list of tiles... split on % 16 for new row
              temp.forEach((trow, tr) => {
                trow.forEach((tcol, tc) => {
                  tcol.forEach((row, r) => {
                    row.forEach((col, c) => {
                      let val;
                      if(col == a){
                        val = b;
                      }else if(col == b){
                        val = a;
                      }
                      if(Number.isInteger(val)){
                        _store.data[tr][tc][r][c] = val;
                      }
                    });
                  });
                });
              });
            }
            activeLayer.get().forceUpdate();
            Spritesheets.stores.activeLayer.get().setPresent();
            return _store;
          });
          this.properties.swappedColors = [];
        }
      }
      
      secondary(props){}
      
      move(props){
        // update cursor position
        PixelCursor.x = props.realMousePosition.x;
        PixelCursor.y = props.realMousePosition.y;
      }
    }

    class Tileswap extends Tool{
      constructor(withHotkeys = true){
        super();
        
        if(withHotkeys){
          this.hotkeysGroups = ['tileswap'];
          const cancel = () => {
            this.properties = {};
            MarqueeCursor$1.removeSelection();
          };
          manager.set(['Escape'], { data: { action: actions.action('tool_action'), props: cancel }, groups: this.hotkeysGroups });
        }
        
        this.cursorLayers = [
          MarqueeCursor$1,
        ];

        this.title = 'Transpose (T)';
        this.name = 'tileswap';
        this.enum = 'tileswap';
        this.weight = 60;
        this.icon = 'M18 6v-6h-18v18h6v6h18v-18h-6zm-16 10v-14h14v4h-10v10h-4z';
        this.cursor = new Cursor({
          icon: 'M24 10h-10v-10h-4v10h-10v4h10v10h4v-10h10z',
          size: {
            width: 56,
            height: 56,
          },
          offset: {
            x: 5, 
            y: 5
          }
        });

        // props
        this.properties = {
          start: undefined,
          end: undefined
        };
        this.mouseIsDown = false;
        this.affected = [];
        this.swappedTiles = [];
      }

      primary(props){
        MarqueeCursor$1.removeSelection();

        this.mouseIsDown = props.mouseIsDown;
        let { x, y } = props.realMousePosition;
        
        const rx = Math.floor(x / 8);
        const ry = Math.floor(y / 8);

        // start marquee indicator
        const _x = Math.floor(x / 8) * 8;
        const _y = Math.floor(y / 8) * 8;
        
        this.properties.start = { x: _x, y: _y };
        MarqueeCursor$1.start = { x: _x, y: _y };
        MarqueeCursor$1.end = { x: _x + 7, y: _y + 7 };
      
        // if tiles length is greater 0 swap em all because we have a selection
        if(this.swappedTiles.length > 0){
          const activeLayer = Spritesheets.stores.activeLayer;

          // stack references to be able to save history
          let history = [];
          history.push(activeLayer.get());
          this.swappedTiles.forEach(layer => {
            if(history.indexOf(layer.ref) < 0){
              history.push(layer.ref);
            }
          });

          // save history
          history.forEach((layer) => layer.saveHistory());
      
          activeLayer.update(_store => {

            // a bit innefficient to run 2 loops but whatever. it is what it is
            // we need to clear all reference tiles before moving over the others 
            if(props.altKey){
              this.swappedTiles.forEach((tile) => {
                tile.ref.data[tile.y][tile.x] = new Array(8).fill(new Array(8).fill(0));
              });
            }

            // move tiles
            this.swappedTiles.forEach((tile) => {
              if(_store.data[ry + tile.i] && _store.data[ry + tile.i][rx + tile.j]){
                const temp = JSON.parse(JSON.stringify(_store.data[ry + tile.i][rx + tile.j]));

                // copy tile to the other
                if(props.ctrlKey){
                  _store.data[ry + tile.i][rx + tile.j] = tile.data;

                // move the tiles to new position 
                }else if(props.altKey){
                  _store.data[ry + tile.i][rx + tile.j] = tile.data;

                // swap the tiles. not working completley as expected if a region is selected
                }else {
                  tile.ref.data[tile.y][tile.x] = temp;
                  _store.data[ry + tile.i][rx + tile.j] = tile.data;
                }
              }
            });
            return _store;
          });

          // force all history references to update
          history.forEach((layer) => {
            layer.forceUpdate(layer);
            layer.setPresent();
          });
          history = [];

          this.swappedTiles = [];
          MarqueeCursor$1.removeSelection();
        }
      }
      secondary(props){
        // reset swapped tiles on secondary action to 
        // exit current swap process
        this.swappedTiles = [];
        MarqueeCursor$1.removeSelection();
        this.properties = {};
      }

      move(props){
        let { x, y } = props.realMousePosition;
        x = Math.max(0, Math.floor(x / 8) * 8);
        y = Math.max(0, Math.floor(y / 8) * 8);

        let _start = { ...this.properties.start };
        let _end = { x: x, y: y };

        if(MarqueeCursor$1.hasSelection()){
          _start = { x: x, y: y };
          _end = { x: x + MarqueeCursor$1.selection.end.x - MarqueeCursor$1.selection.start.x - 7, y: y + MarqueeCursor$1.selection.end.y - MarqueeCursor$1.selection.start.y - 7 };
        }
        const _start_x = Math.min(_end.x, _start.x);
        const _end_x = Math.max(_end.x, _start.x);
        
        const _start_y = Math.min(_end.y, _start.y);
        const _end_y = Math.max(_end.y, _start.y);
        
        this.properties.end = { x: _end_x, y: _end_y };
        MarqueeCursor$1.start = { x: _start_x, y: _start_y };
        MarqueeCursor$1.end = { x: this.properties.end.x + 7, y: this.properties.end.y + 7 };
      }

      mouseup(props){
        if(this.mouseIsDown){
          MarqueeCursor$1.addSelection({ start: MarqueeCursor$1.start, end: MarqueeCursor$1.end });
        }

        // active layer at the current action, which means you can copy between layers
        const activeLayer = Spritesheets.stores.activeLayer;
        
        if(MarqueeCursor$1.hasSelection() && !this.swappedTiles.length){
          const offset = { x: MarqueeCursor$1.selection.start.x / 8, y: MarqueeCursor$1.selection.start.y / 8 };
          if(this.properties.start && this.properties.end){
            let width = (Math.abs((MarqueeCursor$1.start.x - MarqueeCursor$1.end.x-1))/8);
            let height = (Math.abs((MarqueeCursor$1.start.y - MarqueeCursor$1.end.y-1))/8);
            const pixelData = JSON.parse(JSON.stringify(activeLayer.get().data));
            for(let i = 0; i < height; i++){
              for(let j = 0; j < width; j++){
                const tile = { x: offset.x+j, y: offset.y+i, i, j, data: pixelData[offset.y+i][offset.x+j], ref: activeLayer.get() };
                this.swappedTiles.push(tile);  
              }
            }
          }
        }else if(this.mouseIsDown){
          // force update
          const layer = Spritesheets.stores.activeLayer.get();
          layer.forceUpdate();
          layer.setPresent();
        }
        
        this.mouseIsDown = false;
        this.properties = {};
      }
      onDestroy(){
        this.secondary();
      }
    }

    class Transform extends Tool{
      constructor(withHotkeys = true){
        super();

        if(withHotkeys){
          this.hotkeysGroups = ['transform'];
          const cancel = () => {
            this.properties = {};
            MarqueeCursor$1.removeSelection();
          };
          manager.set(['Escape'], { data: { action: actions.action('tool_action'), props: cancel }, groups: this.hotkeysGroups });
        }

        this.cursorLayers = [
          MarqueeCursor$1,
        ];

        this.title = 'Transform (R)';
        this.name = 'transform';
        this.enum = 'transform';
        this.weight = 55;
        this.icon = 'M18.885 3.515c-4.617-4.618-12.056-4.676-16.756-.195l-2.129-2.258v7.938h7.484l-2.066-2.191c2.82-2.706 7.297-2.676 10.073.1 4.341 4.341 1.737 12.291-5.491 12.291v4.8c3.708 0 6.614-1.244 8.885-3.515 4.686-4.686 4.686-12.284 0-16.97z';
        this.cursor = new Cursor({
          icon: 'M24 10h-10v-10h-4v10h-10v4h10v10h4v-10h10z',
          size: {
            width: 56,
            height: 56,
          },
          offset: {
            x: 5, 
            y: 5
          }  
        });

        this.properties = {
          modifier: undefined
        };
      }

      flipX(props){
        let { x, y} = props.realMousePosition;
        const _x = Math.floor(x / 8);
        const _y = Math.floor(y / 8);
        const grid = Spritesheets.stores.activeLayer.get().data;
        grid[_y][_x] = grid[_y][_x].map((val) => val.reverse());
      }
      flipY(props){
        this.rotate(props);
        this.rotate(props);
        this.flipX(props);
      }
      rotate(props){
        let { x, y} = props.realMousePosition;
        const _x = Math.floor(x / 8);
        const _y = Math.floor(y / 8);
        const grid = Spritesheets.stores.activeLayer.get().data;
        // NOTE: we only want to rotate one direction because... only one mouse button??
        // either way it's not a big deal since it's only four directions
        grid[_y][_x] = grid[_y][_x].map((val, index) => grid[_y][_x].map(row => row[index]).reverse());
      }

      matrix(){
        // find all items in selected area 

        // apply transformation
        const transpose = array => array.reduce((r, a) => a.map((v, i) => [...(r[i] || []), v]), []),
        matrix = [[1, 2, 3], [1, 2, 3], [1, 2, 3]];
        console.log(transpose(matrix));
        // update the store with new values 
        // and force update the canvas
        
      }

      primary(props){
        this.mouseIsDown = props.mouseIsDown;
        props.realMousePosition;
        
        if(props.shiftKey){
          return
        }


        Spritesheets.stores.activeLayer.get().saveHistory();
        if(props.ctrlKey){
          this.flipX(props);
        }else if(props.altKey){
          this.flipY(props);
        }else {
          this.rotate(props);
        }
        // force a spritesheet update
        Spritesheets.stores.activeLayer.get().forceUpdate();
        Spritesheets.stores.activeLayer.get().setPresent();
      }
      clear(){
        MarqueeCursor$1.removeSelection();
        this.properties = {};
      }

      secondary(props){
        this.clear();
      }

      move(props){
        if(MarqueeCursor$1.hasSelection()){
          return;
        }

        let { x, y } = props.realMousePosition;
        x = Math.max(0, Math.floor(x / 8) * 8);
        y = Math.max(0, Math.floor(y / 8) * 8);

        let _start = { ...this.properties.start };
        let _end = { x: x, y: y };

        const _start_x = Math.min(_end.x, _start.x);
        const _end_x = Math.max(_end.x, _start.x);
        
        const _start_y = Math.min(_end.y, _start.y);
        const _end_y = Math.max(_end.y, _start.y);

        MarqueeCursor$1.start = { x: _start_x, y: _start_y };
        MarqueeCursor$1.end = { x: _end_x + 7, y: _end_y + 7 };
        // MarqueeCursor.end = { x: this.properties.end.x + 7, y: this.properties.end.y + 7 };
      }

      mouseup(props){
        if(this.mouseIsDown){
          this.mouseIsDown = false;
          this.properties = {};
          MarqueeCursor$1.addSelection({ start: MarqueeCursor$1.start, end: MarqueeCursor$1.end });
        }
      }
    }

    /* src\modules\spritesheet_editor\options\ColorAttribute.svelte generated by Svelte v3.31.2 */

    function create_fragment$6(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ColorAttribute", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ColorAttribute> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class ColorAttribute extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColorAttribute",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    class ColorAttribute$1 extends Tool{
      constructor(withHotkeys = true){
        super();
        if(withHotkeys){
          this.hotkeysGroups = ['colorattribute'];
          const toggleOverlay = manager.set(['Tab'], { groups: this.hotkeysGroups });
          toggleOverlay.on(({ e, Hotkey, on }) => ColorAttributesOverlay.toggle());
          toggleOverlay.off(({ e, Hotkey, on }) => ColorAttributesOverlay.toggle());
        }

        this.cursorLayers = [
          ColorAttributesOverlay,
          // TODO: change tilecursor to be a cursor of the 4 colors 
          TileCursor$1,
        ];

        this.optionsPanelComponent = ColorAttribute;

        this.title = 'Attribute table (A)';
        this.name = 'colorattribute';
        this.enum = 'colorattribute';
        this.weight = 80;
        this.icon = 'M4 21.832c4.587.38 2.944-4.493 7.188-4.538l1.838 1.534c.458 5.538-6.315 6.773-9.026 3.004zm14.065-7.115c1.427-2.239 5.847-9.749 5.847-9.749.352-.623-.43-1.273-.976-.813 0 0-6.572 5.714-8.511 7.525-1.532 1.432-1.539 2.086-2.035 4.447l1.68 1.4c2.227-.915 2.868-1.039 3.995-2.81zm-11.999 3.876c.666-1.134 1.748-2.977 4.447-3.262.434-2.087.607-3.3 2.547-5.112 1.373-1.282 4.938-4.409 7.021-6.229-1-2.208-4.141-4.023-8.178-3.99-6.624.055-11.956 5.465-11.903 12.092.023 2.911 1.081 5.571 2.82 7.635 1.618.429 2.376.348 3.246-1.134zm6.952-15.835c1.102-.006 2.005.881 2.016 1.983.004 1.103-.882 2.009-1.986 2.016-1.105.009-2.008-.88-2.014-1.984-.013-1.106.876-2.006 1.984-2.015zm-5.997 2.001c1.102-.01 2.008.877 2.012 1.983.012 1.106-.88 2.005-1.98 2.016-1.106.007-2.009-.881-2.016-1.988-.009-1.103.877-2.004 1.984-2.011zm-2.003 5.998c1.106-.007 2.01.882 2.016 1.985.01 1.104-.88 2.008-1.986 2.015-1.105.008-2.005-.88-2.011-1.985-.011-1.105.879-2.004 1.981-2.015zm10.031 8.532c.021 2.239-.882 3.718-1.682 4.587l-.046.044c5.255-.591 9.062-4.304 6.266-7.889-1.373 2.047-2.534 2.442-4.538 3.258z';
        this.cursor = new Cursor({
          icon: 'M17.831 7.672c1.096-1.096 2.875-1.865 3.688-3.106.892-1.362.508-3.192-.851-4.085-1.362-.892-3.187-.508-4.081.854-.842 1.286-.801 3.322-1.433 4.779-.817 1.882-3.553 2.116-6.698.474-1.727 3.352-4.075 6.949-6.456 9.874l2.263 1.484c1.018-.174 2.279-1.059 2.792-2.03-.04 1.167-.478 2.2-1.337 2.983l4.275 2.797c.546-.544 1.054-.976 1.616-1.345-.319.643-.532 1.324-.63 1.99l2.532 1.659c1.5-2.884 4.416-7.343 6.455-9.874-2.82-2.272-3.657-4.936-2.135-6.454zm1.762-5.545c.454.296.58.908.281 1.36-.294.457-.905.582-1.356.286-.456-.297-.582-.906-.284-1.36.295-.455.905-.583 1.359-.286zm-3.959 15.037l-8.225-5.386 1.616-2.469 8.221 5.387-1.612 2.468z',
          size: {
            width: 66,
            height: 66,
          },
          stroke: 1.5 ,
          offset: {
            x: 0, 
            y: 10
          }    
        });


        this.properties = {
          remove: undefined,
          previous: {
            x: undefined, 
            y: undefined
          }
        };
      }

      primary(props){
        let { x, y } = props.realMousePosition;
        if(!(x > 0 && x < 128 && y > 0 && y < 128)) return;
        x = Math.floor(x / 8);
        y = Math.floor(y / 8);

        if(props.altKey){
          const palette = this.getColorAttributeAtPosition({x, y});
          if(palette){
            Palettes.makeLayerActiveFromUUID(palette.uuid);
          }
          return;
        }

        this.properties.previous.x = x;
        this.properties.previous.y = y;
        this.setColorAttribute({ x, y });
      }
      secondary(props){
        let { x, y } = props.realMousePosition;
        x = Math.floor(x / 8);
        y = Math.floor(y / 8);
        this.properties.remove = true;
        this.setColorAttribute({ x, y });
      }
      getColorAttributeAtPosition({x, y}){
        const activeColorAttribute = Spritesheets.stores.activeLayer.get().colorAttributes;
        if(activeColorAttribute && activeColorAttribute[x] !== undefined && activeColorAttribute[x][y] !== undefined){
          return activeColorAttribute[x][y];
        }
      }
      setColorAttribute({ x, y }){
        const activePaletteLayer = Palettes.stores.activeLayer.get();
        const activeColorAttribute = Spritesheets.stores.activeLayer.get().colorAttributes;
        if(activeColorAttribute && activeColorAttribute[y] !== undefined && activeColorAttribute[y][x] !== undefined){
          activeColorAttribute[x][y] = !this.properties.remove ? activePaletteLayer : null;
        }
      }
      mouseup(){
        this.properties.remove = undefined;
        const activeLayer = Spritesheets.stores.activeLayer.get();
        if(activeLayer){
          activeLayer.forceUpdate();
        }
      }
      move(props){
        
        let { x, y } = props.realMousePosition;
        
        // update cursor position
        TileCursor$1.x = x;
        TileCursor$1.y = y;
        
        if(props.altKey) return;
        if(!props.mouseIsDown) return;

        if(!(x > 0 && x < 128 && y > 0 && y < 128)) return;
        
        x = Math.floor(x / 8);
        y = Math.floor(y / 8);

        if(props.which == 1 || props.which == 3){
          if(!(this.properties.previous.x == x && this.properties.previous.y == y)){
            this.setColorAttribute({ x, y });
          }
          this.properties.previous.x = x;
          this.properties.previous.y = y;
        }

      }
    }

    /* src\_components\graphics\CanvasPreview.svelte generated by Svelte v3.31.2 */
    const file$6 = "src\\_components\\graphics\\CanvasPreview.svelte";

    function create_fragment$7(ctx) {
    	let canvas_1;

    	const block = {
    		c: function create() {
    			canvas_1 = element("canvas");
    			attr_dev(canvas_1, "width", /*width*/ ctx[0]);
    			attr_dev(canvas_1, "height", /*height*/ ctx[1]);
    			set_style(canvas_1, "--width", /*width*/ ctx[0]);
    			set_style(canvas_1, "--height", /*height*/ ctx[1]);
    			attr_dev(canvas_1, "class", "svelte-pdl90f");
    			toggle_class(canvas_1, "clamp", /*clamp*/ ctx[2]);
    			add_location(canvas_1, file$6, 69, 0, 2317);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, canvas_1, anchor);
    			/*canvas_1_binding*/ ctx[6](canvas_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*width*/ 1) {
    				attr_dev(canvas_1, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(canvas_1, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*width*/ 1) {
    				set_style(canvas_1, "--width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				set_style(canvas_1, "--height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*clamp*/ 4) {
    				toggle_class(canvas_1, "clamp", /*clamp*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(canvas_1);
    			/*canvas_1_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CanvasPreview", slots, []);
    	let { offset = undefined } = $$props;
    	let { width = 128 } = $$props;
    	let { height = 128 } = $$props;
    	let { clamp = false } = $$props;
    	let { source } = $$props;
    	let canvas, pattern;

    	onMount(() => {
    		// if(!source) throw new Error(`Provide a canvas source for the 'CanvasPreview'`);
    		let context;

    		const fps = 120;

    		const { unsubscribe } = AnimationLoop(
    			({ cancel }) => {
    				if (!source?.element) {
    					cancel();
    					return;
    				}

    				context = canvas?.getContext("2d");
    				if (!context || !canvas) return;

    				// not efficient, at all!
    				if (offset && source) {
    					const width = offset.end.x - offset.start.x;
    					const height = offset.end.y - offset.start.y;
    					pattern = createCanvasPattern({ ...offset.start, source, width, height });

    					// NOTE: this needs to be sorted if we are to implement pixel sizes.
    					// context.drawImage(PixelCursor.canvas, PixelCursor.x, PixelCursor.y, width, height);
    					pattern.context.save();

    					pattern.context.globalCompositeOperation = "screen";

    					if (!isNaN(PixelCursor.x) && !isNaN(PixelCursor.y)) {
    						pattern.context.fillStyle = "rgba(255,255,255,.7)";

    						if (PixelCursor.x >= offset.start.x && PixelCursor.x <= offset.end.x && (PixelCursor.y >= offset.start.y && PixelCursor.y <= offset.end.y)) {
    							pattern.context.fillRect(map(PixelCursor.x, offset.start.x, offset.end.x, 0, width), map(PixelCursor.y, offset.start.y, offset.end.y, 0, height), 1, 1);
    						}
    					}

    					
    					pattern.context.restore();
    				}

    				if (pattern?.pattern) {
    					context.save();
    					context.fillStyle = pattern.pattern();
    					context.fillRect(0, 0, width, height);
    					context.restore();
    				} else {
    					context.drawImage(source.element, 0, 0, width, height);
    				}
    			},
    			fps
    		);

    		return () => {
    			if (unsubscribe) unsubscribe();
    		};
    	});

    	const writable_props = ["offset", "width", "height", "clamp", "source"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CanvasPreview> was created with unknown prop '${key}'`);
    	});

    	function canvas_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			canvas = $$value;
    			$$invalidate(3, canvas);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("offset" in $$props) $$invalidate(4, offset = $$props.offset);
    		if ("width" in $$props) $$invalidate(0, width = $$props.width);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    		if ("clamp" in $$props) $$invalidate(2, clamp = $$props.clamp);
    		if ("source" in $$props) $$invalidate(5, source = $$props.source);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createCanvasPattern,
    		map,
    		AnimationLoop,
    		PixelCursor,
    		offset,
    		width,
    		height,
    		clamp,
    		source,
    		canvas,
    		pattern
    	});

    	$$self.$inject_state = $$props => {
    		if ("offset" in $$props) $$invalidate(4, offset = $$props.offset);
    		if ("width" in $$props) $$invalidate(0, width = $$props.width);
    		if ("height" in $$props) $$invalidate(1, height = $$props.height);
    		if ("clamp" in $$props) $$invalidate(2, clamp = $$props.clamp);
    		if ("source" in $$props) $$invalidate(5, source = $$props.source);
    		if ("canvas" in $$props) $$invalidate(3, canvas = $$props.canvas);
    		if ("pattern" in $$props) pattern = $$props.pattern;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, clamp, canvas, offset, source, canvas_1_binding];
    }

    class CanvasPreview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			offset: 4,
    			width: 0,
    			height: 1,
    			clamp: 2,
    			source: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CanvasPreview",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*source*/ ctx[5] === undefined && !("source" in props)) {
    			console.warn("<CanvasPreview> was created without expected prop 'source'");
    		}
    	}

    	get offset() {
    		throw new Error("<CanvasPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set offset(value) {
    		throw new Error("<CanvasPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<CanvasPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<CanvasPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<CanvasPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<CanvasPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clamp() {
    		throw new Error("<CanvasPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clamp(value) {
    		throw new Error("<CanvasPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get source() {
    		throw new Error("<CanvasPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set source(value) {
    		throw new Error("<CanvasPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_components\graphics\SpritesheetPreview.svelte generated by Svelte v3.31.2 */

    // (7:0) {#key $activeLayer}
    function create_key_block(ctx) {
    	let canvaspreview;
    	let current;

    	canvaspreview = new CanvasPreview({
    			props: {
    				source: /*$activeLayer*/ ctx[0],
    				offset: /*$$props*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(canvaspreview.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(canvaspreview, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const canvaspreview_changes = {};
    			if (dirty & /*$activeLayer*/ 1) canvaspreview_changes.source = /*$activeLayer*/ ctx[0];
    			if (dirty & /*$$props*/ 4) canvaspreview_changes.offset = /*$$props*/ ctx[2];
    			canvaspreview.$set(canvaspreview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(canvaspreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(canvaspreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(canvaspreview, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(7:0) {#key $activeLayer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let previous_key = /*$activeLayer*/ ctx[0];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$activeLayer*/ 1 && safe_not_equal(previous_key, previous_key = /*$activeLayer*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $activeLayer;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SpritesheetPreview", slots, []);
    	const { activeLayer } = Spritesheets.stores;
    	validate_store(activeLayer, "activeLayer");
    	component_subscribe($$self, activeLayer, value => $$invalidate(0, $activeLayer = value));

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$capture_state = () => ({
    		Spritesheets,
    		CanvasPreview,
    		activeLayer,
    		$activeLayer
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$activeLayer, activeLayer, $$props];
    }

    class SpritesheetPreview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SpritesheetPreview",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    class Preview extends Tool{
      constructor(){
        super();

        this.cursorLayers = [
          MarqueeCursor$1
        ];
        this.title = 'Pattern preview (P)';
        this.name = 'preview';
        this.enum = 'preview';
        this.weight = 10;
        this.icon = 'M8 0v2h8v-2h-8zm0 24v-2h8v2h-8zm10-24h6v6h-2v-4h-4v-2zm-18 8h2v8h-2v-8zm0-2v-6h6v2h-4v4h-2zm24 10h-2v-8h2v8zm0 2v6h-6v-2h4v-4h2zm-18 6h-6v-6h2v4h4v2zm12-18h-12v12h12v-12z';
        this.cursor = new Cursor({
          icon: 'M24 10h-10v-10h-4v10h-10v4h10v10h4v-10h10z',
          size: {
            width: 56,
            height: 56,
          },
          offset: {
            x: 5, 
            y: 5
          }
        });

        // 
        this.properties = {
          start: undefined,
          end: undefined
        };
        this.mouseIsDown = false;
      }

      onMount(){}
      onDestroy(){}
      dblclick(){
        this.mouseIsDown = true;
        MarqueeCursor$1.start = {x: 0, y: 0};
        MarqueeCursor$1.end = {x: 128, y: 128};
        this.createPreview();
      }
      primary(props){
        this.mouseIsDown = props.mouseIsDown;
        MarqueeCursor$1.removeSelection();
        let { x, y } = props.realMousePosition;
        x = Math.floor(x / 8) * 8;
        y = Math.floor(y / 8) * 8;
        this.properties.start = { x, y };
        MarqueeCursor$1.start = { x, y };
        MarqueeCursor$1.end = { x: x + 7, y: y + 7 };
      }

      secondary(props){
        MarqueeCursor$1.removeSelection();
      }

      // TODO: clean up? or good enough? works for now
      move(props){
        if(!props.mouseIsDown || props.which !== 1) return;
        let { x, y } = props.realMousePosition;
        x = Math.max(0, Math.floor(x / 8) * 8);
        y = Math.max(0, Math.floor(y / 8) * 8);

        let _start = { ...this.properties.start };
        let _end = { x, y };

        const _start_x = Math.min(_end.x, _start.x);
        const _end_x = Math.max(_end.x, _start.x);

        const _start_y = Math.min(_end.y, _start.y);
        const _end_y = Math.max(_end.y, _start.y);

        MarqueeCursor$1.start = { x: _start_x, y: _start_y };
        MarqueeCursor$1.end = { x: _end_x + 7, y: _end_y + 7 };
      }
      
      mouseup(props){
        this.createPreview(props);
      }
      
      createPreview(props){
        if(MarqueeCursor$1.start && MarqueeCursor$1.end && this.mouseIsDown){
          // add this preview to preview window somehow.
          const start = {
            x: Math.floor(MarqueeCursor$1.start.x / 8),
            y: Math.floor(MarqueeCursor$1.start.y / 8)
          };
          const end = {
            x: Math.floor((MarqueeCursor$1.end.x - 7) / 8),
            y: Math.floor((MarqueeCursor$1.end.y - 7) / 8)
          };

          const props = {
            label: `start: (${start.x},${start.y}) end: (${end.x},${end.y})`,
            zoom: 2,
            start: {
              x: MarqueeCursor$1.start.x,
              y: MarqueeCursor$1.start.y,
            },
            end: {
              x: MarqueeCursor$1.end.x + 1,
              y: MarqueeCursor$1.end.y + 1,
            }
          };
          push$1(SpritesheetPreview, props);
        }
        MarqueeCursor$1.removeSelection();
        this.mouseIsDown = false;
      }
    }

    class Brush extends Tool{
      constructor(withHotkeys = true){
        super();

        this.cursorLayers = [
          BrushCursor$1
        ];

        if(withHotkeys){
          this.hotkeysGroups = ['brush'];
          const cancel = () => {
            this.mouseIsDown = false;
            this.properties.start = undefined;
            BrushCursor$1.removeSelection();
          };
          manager.set(['Escape'], { data: { action: actions.action('tool_action'), props: cancel }, groups: this.hotkeysGroups });
        }

        this.title = 'Pattern brush (D)';
        this.name = 'brush';
        this.enum = 'brush';
        this.weight = 80;
        this.icon = 'M17.831 7.672c1.096-1.096 2.875-1.865 3.688-3.106.892-1.362.508-3.192-.851-4.085-1.362-.892-3.187-.508-4.081.854-.842 1.286-.801 3.322-1.433 4.779-.817 1.882-3.553 2.116-6.698.474-1.727 3.352-4.075 6.949-6.456 9.874l2.263 1.484c1.018-.174 2.279-1.059 2.792-2.03-.04 1.167-.478 2.2-1.337 2.983l4.275 2.797c.546-.544 1.054-.976 1.616-1.345-.319.643-.532 1.324-.63 1.99l2.532 1.659c1.5-2.884 4.416-7.343 6.455-9.874-2.82-2.272-3.657-4.936-2.135-6.454zm1.762-5.545c.454.296.58.908.281 1.36-.294.457-.905.582-1.356.286-.456-.297-.582-.906-.284-1.36.295-.455.905-.583 1.359-.286zm-3.959 15.037l-8.225-5.386 1.616-2.469 8.221 5.387-1.612 2.468z';
        this.cursor = new Cursor({
          icon: 'M17.831 7.672c1.096-1.096 2.875-1.865 3.688-3.106.892-1.362.508-3.192-.851-4.085-1.362-.892-3.187-.508-4.081.854-.842 1.286-.801 3.322-1.433 4.779-.817 1.882-3.553 2.116-6.698.474-1.727 3.352-4.075 6.949-6.456 9.874l2.263 1.484c1.018-.174 2.279-1.059 2.792-2.03-.04 1.167-.478 2.2-1.337 2.983l4.275 2.797c.546-.544 1.054-.976 1.616-1.345-.319.643-.532 1.324-.63 1.99l2.532 1.659c1.5-2.884 4.416-7.343 6.455-9.874-2.82-2.272-3.657-4.936-2.135-6.454zm1.762-5.545c.454.296.58.908.281 1.36-.294.457-.905.582-1.356.286-.456-.297-.582-.906-.284-1.36.295-.455.905-.583 1.359-.286zm-3.959 15.037l-8.225-5.386 1.616-2.469 8.221 5.387-1.612 2.468z',
          size: {
            width: 66,
            height: 66,
          },
          stroke: 1.5 ,
          offset: {
            x: 0, 
            y: 10
          }    
        });

        this.mouseIsDown;
        this.properties = {
          drawStack: {},
          remove: undefined,
          previous: {
            x: undefined, 
            y: undefined
          }
        };
      }

      primary(props){
        // get the real mouse position and clamp it to the size of a tile which is 8x8 
        let { x: _x, y: _y } = props.realMousePosition;
        let x = Math.floor(_x / 8) * 8;
        let y = Math.floor(_y / 8) * 8;

        // mouse has been pressed on the canvas (move reads outside canvas)
        this.mouseIsDown = props.mouseIsDown;
        if(!(this.mouseIsDown && props.altKey)){
          // paint the first one
          if(BrushCursor$1.hasSelection()){
            if(props.shiftKey){
              let size = {
                x: Math.floor((BrushCursor$1.selection.end.x - BrushCursor$1.selection.start.x)) + 1,
                y: Math.floor((BrushCursor$1.selection.end.y - BrushCursor$1.selection.start.y)) + 1,
              };
              x = Math.floor(_x / size.x) * size.x;
              y = Math.floor(_y / size.y) * size.y;
            }
            this.paint({ x: x / 8, y: y / 8 });
          }
          return;
        }    
        // clear the old selection
        BrushCursor$1.selectionIsVisible = true;
        BrushCursor$1.removeSelection();
        
        
        // define the starting position of the selection
        this.properties.start = { x, y };
        BrushCursor$1.start = { x, y };

        // set the end as one tile size so a cick will at east select one tile
        BrushCursor$1.end = { x: x + 7, y: y + 7 };

      }

      secondary(props){
        // clear the old selection
        this.mouseIsDown = false;
        this.properties.start = undefined;
        BrushCursor$1.removeSelection();
      }
     
      mouseup(){
        if(!this.mouseIsDown) return;
        // get all tile references inside the selection
        const activeLayer = Spritesheets.stores.activeLayer;
        const activeLayerData = activeLayer.get();
        if(BrushCursor$1.start && BrushCursor$1.end && this.mouseIsDown && !BrushCursor$1.hasSelection()){
          BrushCursor$1.addSelection({ start: BrushCursor$1.start, end: BrushCursor$1.end });
          BrushCursor$1.selectionIsVisible = false;
          // store the origin layer source
          const originImage = new Image();
          originImage.src = activeLayerData.updateImageSource();
          this.properties.activeLayerSnapshot = {
            image: originImage,
            data: JSON.parse(JSON.stringify(activeLayerData.data))
          };
        }else {
          // exit early if no draw queue
          const stack = Object.entries(this.properties.drawStack);
          activeLayerData.saveHistory();
          activeLayer.update((_store) => {
            stack.forEach(([y, col]) => {
              if(_store.data[y]){
                Object.entries(col).forEach(([x, value]) => {
                  if(_store.data[y][x]){
                    _store.data[y][x] = value;
                  }
                });
              }
            });
            return _store;
          });
          // temp, do no t do this
          activeLayerData.forceUpdate();
          activeLayerData.setPresent();
        }
        this.properties.drawStack = {};
        this.properties.start = undefined;
        this.mouseIsDown = false;
      }
      
      paint(currentOffset){
        const source = this.properties.activeLayerSnapshot?.data;
        if(!source) return;
        const serializedSource = JSON.parse(JSON.stringify(source));

        const activeLayer = Spritesheets.stores.activeLayer.get();
        const width = Math.abs(BrushCursor$1.selection.end.x - BrushCursor$1.selection.start.x + 1);
        const height = Math.abs(BrushCursor$1.selection.end.y - BrushCursor$1.selection.start.y + 1);
        
        const tiles = {
          y: Math.floor(height / 8),
          x: Math.floor(width / 8)
        };
        for(let i = 0; i < tiles.y; i++){
          for(let j = 0; j < tiles.x; j++){
            const y = (currentOffset.y + i);
            const x = (currentOffset.x + j);
            // TODO: store all selected tiles not just the one that is current hardcoded
            if(!this.properties.drawStack[y]){
              this.properties.drawStack[y] = {};
            }
            this.properties.drawStack[y][x] = serializedSource[(BrushCursor$1.selection.start.y / 8) + i][(BrushCursor$1.selection.start.x / 8) + j];
            // TODO: copy the attribute table as well! so the coors macth on the new location
            if(this.properties.activeLayerSnapshot.image){
              activeLayer.context.drawImage(
                this.properties.activeLayerSnapshot.image, 
                // source
                BrushCursor$1.selection.start.x + (j * 8), 
                BrushCursor$1.selection.start.y + (i * 8), 
                8, 
                8,        
                // destination
                Math.floor(x * 8),
                Math.floor(y * 8),
                8, 
                8,
              );
            }
          }
        }
      }

      move(props){
        // get the real position and constrain it to the 8x8 tile bounds
        let { x, y } = props.realMousePosition;
        
        const rx = Math.floor(x / 8);
        const ry = Math.floor(y / 8);
        
        let _x = Math.max(0, rx * 8);
        let _y = Math.max(0, ry * 8);
        
        // trying to select a new area as a pattern
        if(BrushCursor$1.hasSelection()){
          let a = 8;
          let b = 8;
          let size = {
            x: Math.floor(BrushCursor$1.selection.end.x+1 - BrushCursor$1.selection.start.x),
            y: Math.floor(BrushCursor$1.selection.end.y+1 - BrushCursor$1.selection.start.y)
          };

          if(props.shiftKey){
            a = size.x;
            b = size.y;
          }

          const c = Math.max(0, Math.floor(x / a) * a);
          const d = Math.max(0, Math.floor(y / b) * b);
          
          BrushCursor$1.start = { 
            x: c, 
            y: d 
          };
          BrushCursor$1.end = { 
            x: c + size.x-1,
            y: d + size.y-1,
          };
          
          const currentOffset = {
            x: c / 8,
            y: d / 8
          };

          if(this.mouseIsDown){
            this.paint(currentOffset);
          }

        }else {
          if(!props.mouseIsDown || props.which !== 1) return;
          // get the start and end values so we can swap which one is start or end
          // depending on what direction the selection is being made
          let _start = { ...this.properties.start };
          let _end = { x: _x, y: _y };
          
          // determine what is start and end
          const _start_x = Math.min(_end.x, _start.x);
          const _end_x = Math.max(_end.x, _start.x);
          
          const _start_y = Math.min(_end.y, _start.y);
          const _end_y = Math.max(_end.y, _start.y);

          // apply the positions to the cursor
          BrushCursor$1.start = { x: _start_x, y: _start_y };
          BrushCursor$1.end = { x: _end_x + 7, y: _end_y + 7 };
        }
      }
    }

    class Zoom extends Tool{
      constructor(){
        super();
        this.singleAction = true;
        this.name = 'zoom';
        this.title = "Zoom (Z)";
        this.enum = 'zoom';
        this.weight = 0;
        this.icon = 'M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z';
        this.cursor = new Cursor({
          icon: 'M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z',
          size: {
            width: 56,
            height: 56,
          },
          offset: {
            x: 5, 
            y: 5
          }  
        });
      }

      primary(props){
        if(props.altKey){
          actions.execute('spritesheet_zoom_out');
          return;
        }
        actions.execute('spritesheet_zoom_in');
      }
      secondary(props){
        if(props.altKey){
          actions.execute('spritesheet_zoom_in');
          return;
        }
        actions.execute('spritesheet_zoom_out');
      }
      move(props){}
      dblclick(){
        actions.execute('spritesheet_zoom_reset');
      }
    }

    class Text extends Tool{
      constructor(){
        super();

        this.title = 'Text (W)';
        this.name = 'text';
        this.enum = 'text';
        this.weight = 10;
        this.visible_in_toolbar = false;
        this.icon = 'M22 0h-20v6h1.999c0-1.174.397-3 2.001-3h4v16.874c0 1.174-.825 2.126-2 2.126h-1v2h9.999v-2h-.999c-1.174 0-2-.952-2-2.126v-16.874h4c1.649 0 2.02 1.826 2.02 3h1.98v-6z';
        this.cursor = new Cursor({
          icon: 'M22 0h-20v6h1.999c0-1.174.397-3 2.001-3h4v16.874c0 1.174-.825 2.126-2 2.126h-1v2h9.999v-2h-.999c-1.174 0-2-.952-2-2.126v-16.874h4c1.649 0 2.02 1.826 2.02 3h1.98v-6z',
          size: {
            width: 56,
            height: 56,
          },
          offset: {
            x: 5, 
            y: 5
          }
        });
      }
      primary(props){}
      secondary(props){}
      move(props){}
    }

    class Vector{
      constructor(...args){
        // validate fn
        const validate = (...n) => n.map((_) => {
          if(typeof _ !== 'number'){
            throw new Error(`Invalid argument, expecting number, got : [${typeof _}]`);
          }
          return _;
        });    
        // special case for single arguments
        let [ x = 0, y = 0, z = 0] = args;
        if(args.length == 1){
          y = x;
          z = x;
        }
        // validate and assign
        validate(x, y, z);
        Object.assign(this, {x, y, z});
      }
      get angle(){
        return this._angle();
      }
      get degrees(){
        return this._angle(true);
      }
      _angle(deg){
        const angle = Math.atan2(this.y, this.x);   //radians
        // you need to divide by PI, and multiply by 180
        // round number, avoid decimal fragments
        const degrees = (360+Math.round(180*angle/Math.PI))%360;
        if(deg == true){
          return degrees
        }
        return degrees * Math.PI / 180;
      }
      _isVectorCheck(args){
        if(args.length == 1 && (args[0] instanceof Vector)){
          return args[0];
        }
        return new Vector(...args);
      }
      set(...vector){
        const { x, y, z } = this._isVectorCheck(vector);
        this.x = x;
        this.y = y;
        this.z = z;
      }
      add(...vector){
        const { x, y, z } = this._isVectorCheck(vector);
        this.x += x;
        this.y += y;
        this.z += z;
        return this;
      }
      sub(...vector){
        const { x, y, z } = this._isVectorCheck(vector);
        this.x -= x;
        this.y -= y;
        this.z -= z;
        return this;
      }
      div(...vector){
        const { x, y, z } = this._isVectorCheck(vector);
        this.x /= x;
        this.y /= y;
        this.z /= z;
        return this;
      }
      mul(...vector){
        const { x, y, z } = this._isVectorCheck(vector);
        this.x *= x;
        this.y *= y;
        this.z *= z;
        return this;
      }
      mag(){
        return Math.sqrt(this.magSq());
      }
      magSq(){
        let x = this.x;
        let y = this.y;
        let z = this.z;
        return x * x + y * y + z * z;
      }
      limit(max){
        var mSq = this.magSq();
        if(mSq > max * max){
          this.div(Math.sqrt(mSq)).mul(max);
        }
        return this;
      }
      copy(){
        return new Vector(this.x, this.y, this.z);
      }
      normalize(scale){
        scale = scale || 1;
        if(typeof scale !== 'number'){
          throw new Error(`Invalid normalize scaling, expecting number`);
        }
        let m = this.mag();
        if(m != 0){
          this.x = scale * this.x / m;
          this.y = scale * this.y / m;
          this.z = scale * this.z / m;
        }
        return this
      }
      dist(...vector){
        return (this._isVectorCheck(vector)).copy().sub(this);
      }
      static div(v1, v2){
        if(!(v1 instanceof Vector) || !(v2 instanceof Vector)){
          throw new Error(`Invalid argument, expecting Vector got in : Vector->div`);
        }
        let cp = v1.copy();
        return cp.div(v2);
      }
      static add(v1, v2){
        if(!(v1 instanceof Vector) || !(v2 instanceof Vector)){
          throw new Error('Invalid static vector add argument, expecting vectors');
        }
        return v1.copy().add(v2);
      }
      static sub(v1, v2){
        if(!(v1 instanceof Vector) || !(v2 instanceof Vector)){
          throw new Error('Invalid static vector sub argument, expecting vectors');
        }
        return v1.copy().sub(v2);
      }
      static mul(v1, v2){
        if(!(v1 instanceof Vector) || !(v2 instanceof Vector)){
          throw new Error('Invalid static vector div argument, expecting vectors');
        }
        let cp = v1.copy();
        return cp.mul(v2);
      }
      static dist(v1, v2){
        if(!(v1 instanceof Vector) || !(v2 instanceof Vector)){
          throw new Error('Invalid static vector div argument, expecting vectors');
        }
        return v.copy().sub(this);
      }
      static fromAngle(angle, len){
        return new VectorFromAngle(angle, len);
      }
    }


    class VectorFromAngle extends Vector{
      constructor(angle, len = 1){
        super();
        if(typeof angle !== 'number' || typeof len !== 'number'){
          throw new Error(`Expecting angle and length to be valid numbers got : a[${typeof angle}] - l[${typeof len}]`);
        }
        const { x, y, z } = this._getAngle(angle, len);
        this.x = x;
        this.y = y;
        this.z = z;
      }
      _getAngle(a, len){
        return {x: len * Math.cos(a), y: len * Math.sin(a), z: 0};
      }
    }

    // vector shorthand
    const vector = (...args) => new Vector(...args);

    class ShapeLayer extends Layer{
      constructor(...args){
        super(...args);
        this.width = 128;
        this.height = 128;
        this.selectionIsVisible = true;
      }
      clear(){
        this.context.clearRect(0, 0, this.width, this.height);
      }
      draw({x, y, color}){
        this.context.save();
          this.context.fillStyle = `rgb(${color.join(',')})`;
          this.context.translate(x, y);
          this.context.fillRect(0, 0, 1, 1);
        this.context.restore();
      }
      render(){
      }
    }

    const bresenham = (v0, v1, callback) => {
      let dx = Math.abs(v1.x - v0.x);
      let dy = Math.abs(v1.y - v0.y);
      let sx = (v0.x < v1.x) ? 1 : -1;
      let sy = (v0.y < v1.y) ? 1 : -1;
      let err = dx - dy;

      let local = {v0: {...v0}, v1: {...v1}};

      while(true){
        // do callback
        callback(local.v0.x, local.v0.y); 

        if((local.v0.x === local.v1.x) && (local.v0.y === local.v1.y)) break;
        const e2 = 2*err;
        if (e2 > -dy) { err -= dy; local.v0.x += sx; }
        if (e2 < dx) { err += dx; local.v0.y += sy; }
      }
    };

    class Line extends Tool{
      constructor(withHotkeys = true){
        super();

        if(withHotkeys){
          
          this.hotkeysGroups = ['line'];
          manager.set(['Escape'], { data: {action: actions.action('tool_action'), props: _ => this.clear() }, groups: this.hotkeysGroups });
          manager.set(['AltLeft'], { groups: this.hotkeysGroups })
          .on(_ => {
            actions.execute('spritesheet_set_active_tool', 'eyedropper');
          })
          .off(_ => {
            actions.execute('spritesheet_set_active_tool', 'line');
          });
        }

        this.ShapeLayer = new ShapeLayer();
        this.cursorLayers = [
          this.ShapeLayer,
          PixelCursor,
        ];

        this.title = 'Line (L)';
        this.name = 'line';
        this.enum = 'line';
        this.weight = 85;
        this.visible_in_toolbar = true;
        this.icon = 'M23,3.807L20.168,1L1,20.189L3.81,23L23,3.807z';
        this.cursor = new Cursor({
          icon: 'M24 10h-10v-10h-4v10h-10v4h10v10h4v-10h10z',
          size: {
            width: 56,
            height: 56,
          },
          offset: {
            x: 5, 
            y: 5
          }
        });

        // what line algorithm should be used?
        this.algorithm = bresenham;
        // points
        this.points = {
          start: undefined,
          end: undefined  
        };
        this.drawStack = {};
        // keep track on if canvas has been clicked
        // else move calls registeres outside the canvas area 
        this.mouseIsDown = false;
      }

      primary(props){
        const { x, y } = props.realMousePosition;
        if(!this.points.start){
          this.points.start = vector(x, y);
        }
        this.mouseIsDown = true;
      }
      clear(){
        this.drawStack = {};
        this.points.start = undefined;
        this.points.end = undefined;
        this.ShapeLayer.clear();  
      }
      secondary(props){
        this.clear();
      }
      move(props){
        const { x, y } = props.realMousePosition;
        // update cursor position
        PixelCursor.x = x;
        PixelCursor.y = y;
        if(!(this.points.start)) return;

        this.points.end = vector(x, y);
        // overlay canvas
        this.ShapeLayer.clear();
        this.drawStack = {};
        this.algorithm(this.points.start, this.points.end, (x, y) => {
          if(!(x >= 0 && x < 128 && y >= 0 && y < 128)) return;
          this.drawStack[`${y}-${x}`] = { x, y };
        });

        Object.entries(this.drawStack).forEach(([_, { x, y}]) => {
          this.ShapeLayer.draw({ x, y, color: Palettes.stores.activeLayer.get().colors[Palettes.stores.selectedColor.get()].rgb });
        });
      }
      mouseup(){
        if(!this.points.start || !this.points.end ) return;
        // process the information to draw the line
        const spritesheet = Spritesheets.stores.activeLayer.get();
        spritesheet.saveHistory();
        const data = spritesheet?.data;
        if(data){
          Object.entries(this.drawStack).forEach(([_, { x, y}]) => {
            const row = Math.floor(y / 8);
            const col = Math.floor(x / 8);
            const _y = Math.floor(y % 8);
            const _x = Math.floor(x % 8);
      
            data[row][col][_y][_x] = Palettes.stores.selectedColor.get();
          });
        }
        this.ShapeLayer.clear();
        // update canvas
        spritesheet.forceUpdate();
        // process the information to draw the line
        spritesheet.setPresent();
        // reset 
        this.clear();
      }
    }

    const ellipsePlotPoints = (xc,yc,  x,  y, callback) => {
      callback(xc + x, yc + y);
      callback(xc - x, yc + y);
      callback(xc + x, yc - y);
      callback(xc - x, yc - y);
    };

    const ellipse = (xc,yc,  a,  b, callback) => {
      let a2 = a * a;
      let b2 = b * b;
      let twoa2 = 2 * a2;
      let twob2 = 2 * b2;
      let p;
      let x = 0;
      let y = b;
      let px = 0;
      let py = twoa2 * y;

      /* Plot the initial point in each quadrant. */
      ellipsePlotPoints(xc,yc, x, y, callback);

      /* Region 1 */
      p = Math.round (b2 - (a2 * b) + (0.25 * a2));
      while(px < py){
        x++;
        px += twob2;
        if (p < 0){
          p += b2 + px;
        }else {
          y--;
          py -= twoa2;
          p += b2 + px - py;
        }
        ellipsePlotPoints(xc,yc, x, y, callback);
      }

      /* Region 2 */
      p = Math.round (b2 * (x+0.5) * (x+0.5) + a2 * (y-1) * (y-1) - a2 * b2);
      while (y > 0) {
        y--;
        py -= twoa2;
        if (p > 0){
          p += a2 - py;
        }else {
          x++;
          px += twob2;
          p += a2 - py + px;
        }
        ellipsePlotPoints (xc,yc, x, y, callback);
      }
    };


    class Circle extends Tool{
      constructor(withHotkeys = true){
        super();

        if(withHotkeys){
          this.hotkeysGroups = ['circle'];
          manager.set(['Escape'], { data: {action: actions.action('tool_action'), props: _ => this.clear() }, groups: this.hotkeysGroups });
          manager.set(['AltLeft'], { groups: this.hotkeysGroups })
          .on(_ => {
            actions.execute('spritesheet_set_active_tool', 'eyedropper');
          })
          .off(_ => {
            actions.execute('spritesheet_set_active_tool', 'circle');
          });
        }

        this.ShapeLayer = new ShapeLayer();
        this.cursorLayers = [
          this.ShapeLayer,
          PixelCursor
        ];

        this.title = 'Circle (C)';
        this.name = 'circle';
        this.enum = 'circle';
        this.weight = 86;
        this.visible_in_toolbar = true;
        this.icon = 'M12,0C5.373,0,0,5.373,0,12s5.373,12,12,12s12-5.373,12-12S18.627,0,12,0z M12,20.25c-4.549,0-8.25-3.701-8.25-8.25c0-4.549,3.701-8.25,8.25-8.25c4.549,0,8.25,3.701,8.25,8.25C20.25,16.549,16.549,20.25,12,20.25z';
        this.cursor = new Cursor({
          icon: 'M24 10h-10v-10h-4v10h-10v4h10v10h4v-10h10z',
          size: {
            width: 56,
            height: 56,
          },
          offset: {
            x: 5, 
            y: 5
          }
        });

        // what line algorithm should be used?
        this.algorithm = ellipse;
        // points
        this.points = {
          start: undefined,
          end: undefined  
        };
        this.drawStack = {};
        // keep track on if canvas has been clicked
        // else move calls registeres outside the canvas area 
        this.mouseIsDown = false;
      }

      primary(props){
        const { x, y } = props.realMousePosition;
        if(!this.points.start){
          this.points.start = vector(x, y);
        }
        this.mouseIsDown = true;
      }
      clear(){
        this.drawStack = {};
        this.points.start = undefined;
        this.points.end = undefined;
        this.ShapeLayer.clear();  
      }
      secondary(props){
        this.clear();
      }
      move(props){
        const { x, y } = props.realMousePosition;
        // update cursor position
        PixelCursor.x = x;
        PixelCursor.y = y;
        if(!(this.points.start)) return;
        this.points.end = vector(x, y);
        // overlay canvas
        this.ShapeLayer.clear();
        this.drawStack = {};
        let end = {
          x: Math.abs(this.points.end.x - this.points.start.x), 
          y: Math.abs(this.points.end.y - this.points.start.y) 
        };
        if(props.shiftKey){
          const size = Math.max(end.x, end.y);
          end.x = size;
          end.y = size;
        }
        this.algorithm(this.points.start.x, this.points.start.y, end.x, end.y, (x, y) => {
          this.drawStack[`${x}-${y}`] = { x, y };
        });
        Object.entries(this.drawStack).forEach(([_, { x, y }]) => {
          this.ShapeLayer.draw({ x, y, color: Palettes.stores.activeLayer.get().colors[Palettes.stores.selectedColor.get()].rgb });
        });
      }
      mouseup(){
        if(!this.points.start || !this.points.end ) return;
        // process the information to draw the line
        const spritesheet = Spritesheets.stores.activeLayer.get();
        spritesheet.saveHistory();
        const data = spritesheet?.data;
        if(data){
          Object.entries(this.drawStack).forEach(([_, { x, y}]) => {
            // this.ShapeLayer.draw({ x, y });
            const row = Math.floor(y / 8);
            const col = Math.floor(x / 8);
            const _y = Math.floor(y % 8);
            const _x = Math.floor(x % 8);
            if(data[row] && data[row][col] && data[row][col][_y] && data[row][col][_y][_x] != undefined){
              data[row][col][_y][_x] = Palettes.stores.selectedColor.get();
            }
          });
        }
        this.ShapeLayer.clear();
        // update canvas
        spritesheet.forceUpdate();
        // process the information to draw the line
        spritesheet.setPresent();

        // reset 
        // NOTE: should the end be considered the start now so we 
        // can draw a line from the last position?
        // this.points.start = this.points.end;
        this.points.start = undefined;
        this.points.end = undefined;
        this.mouseIsDown = false;
      }
    }

    const mapped = {
      pointer: new Pointer(),
      pen: new Pen(),
      eyedropper: new Eyedropper(),
      paintbucket: new Paintbucket(),
      colorswap: new Colorswap(),
      tileswap: new Tileswap(),
      transform: new Transform(),
      // marquee: new Marquee(),
      colorattribute: new ColorAttribute$1(),
      preview: new Preview(),
      brush: new Brush(), // pattern brush
      zoom: new Zoom(),
      text: new Text(),
      line: new Line(),
      circle: new Circle(),
    };

    const Toolbar = {
      tools: mapped, 
      activeTool: writable$1(undefined, ({ value, store, get }) => {
        return {
          setActive(_enum){
            if(!(_enum instanceof Enum)){
              throw new Error(`Invalid tool`);
            }
            const prev = get();
            if(prev instanceof Tool){
              prev.onDestroy();
            }
            const instance = mapped[_enum.key];
            const { cursor } = instance;
            // fallback cursor
            let type = 'default';
            // overwrite cursor if one is defined on the tool
            if(cursor && cursor.icon){
              type = `url("data:image/svg+xml,%3Csvg transform='' xmlns='http://www.w3.org/2000/svg' width='${cursor.size.width}' height='${cursor.size.height}' viewBox='0 0 100 100' xml:space='preserve'%3E %3Cpath fill='white' stroke='black' stroke-width='${cursor.stroke || 2}' d='${cursor.icon}'/%3E %3C/svg%3E") ${cursor.offset.x} ${cursor.offset.y}, auto`;
            }

            // weird hack to make the cursor change if we are not moving it. 
            // otherwise it will be the same cursor until the mouse is moved
            document.body.style.cursor = 'default';
            // set new icon to css variable
            document.documentElement.style.setProperty('--canvas-cursor', type);
            store.set(instance);

            // activate keyboard shortcuts
            if(Array.isArray(instance.hotkeysGroups)){
              // TODO: refactor this so it isn't tied to the spritesheets. We might want tools in other sections
              // but for now this will work
              manager.enableGroups('*', 'spritesheets', ...instance.hotkeysGroups);
            }
          }
        }
      })
    };

    Toolbar.activeTool.setActive(ToolTypes.get('pointer'));

    // tool actions
    const execute = (t, ...args) => {
      if(t){
        t.call(Toolbar.activeTool.get(), ...args);
      }
    };

    const primary = (...args) => execute(Toolbar.activeTool.get()?.primary, ...args);
    const secondary = (...args) => execute(Toolbar.activeTool.get()?.secondary, ...args);
    const move = (...args) => execute(Toolbar.activeTool.get()?.move, ...args);
    const mouseup = (...args) => execute(Toolbar.activeTool.get()?.mouseup, ...args);

    // electron only actions 
    if(globalThis.electron){
      // window actions
      actions.register('window_close', _ => globalThis.electron.quit());
      actions.register('window_minimize', _ => globalThis.electron.minimize());
      actions.register('window_maximize', _ => globalThis.electron.maximize());
      actions.register('window_toggle_fullscreen', _ => globalThis.electron.toggleFullscreen());

      // build project
      actions.register('project_build', () => {
        console.warn('Not implemented');
      });
      
      actions.register('project_build_run', () => {
        // NOTE: chr, nametable and attributetable should later be the level and game data 
        const chr = Spritesheets.exportCHR().data;

        //
        const nametableData = Tilemaps.exportNametableData('nametable');

        // NOTE: temporary grab the first 8 palettes
        const palettes = Palettes.exportASMString();
        globalThis.electron.spawnChildProcess({ chr, palettes, nametables: [nametableData] });
      });

      actions.register('project_run', () => {
        console.warn('Not implemented');
      });

      // project actions
      actions.register('project_save', async _ => {
        const path = Project.get().path;
        if(path){
          globalThis.electron.save(path, Project.export(true)).then((res) => {
            // TODO: dispatch modal notification that the project saved correctly
            push({
              message: `Successfully saved project`,
              variant: 'success'
            });
          });
        }else {
          actions.execute('project_save_as');
        }
      });
      
      actions.register('project_save_as', async _ => {
        const { canceled, filePath } = await globalThis.electron.openSaveDialog([config.filetypes.project.save.extension]);
        if(!canceled){
          // save project
          globalThis.electron.save(filePath, Project.export(true)).then((path) => {
            // TODO: dispatch modal notification that the project saved correctly
            Project.update((store) => {
              store.path = path;
              return store;
            });
          });
          push({
            message: `Successfully saved project`,
            variant: 'success'
          });
        }
      });

      actions.register('project_open', async (filepath) => {
        // TODO: open prompt if the current project should be saved before continuing with 
        // open the new project and replacing the old one.
        const loadProject = async (path) => {
          let { filePath, data } = await globalThis.electron.readFileDataFromPath(path, 'utf8');
          Project.open(filePath, data);
        };
        if(filepath){
          loadProject(filepath);
          return;
        }
        // get the filepath location to the project file
        const { canceled, filePaths } = await globalThis.electron.openFileDialog([config.filetypes.project.save.extension]);
        if(!canceled && Array.isArray(filePaths)){
          // read the data from the filepath
          for(const filepath of filePaths){
            loadProject(filepath);
          }

          push({
            message: `Successfully opened project`,
            variant: 'success'
          });
        }
      });

      // external links
      actions.register('external_link', href => globalThis.electron.externalLink(href));

      
      // palettes
      actions.register('palette_export', async _ => {
        const data = Palettes.export(true);    
        const { canceled, filePath } = await globalThis.electron.openSaveDialog([config.filetypes.palettes.save.extension]);
        if(!canceled && typeof filePath == 'string'){
          await globalThis.electron.saveAs(filePath, data);
          push({
            message: `Successfully exported palettes`,
            variant: 'success'
          });
        }
      });

      // import from file
      actions.register('palette_import', async _ => {
        const { canceled, filePaths } = await globalThis.electron.openFileDialog([config.filetypes.palettes.save.extension]);
        if(!canceled && Array.isArray(filePaths)){
          for(const path of filePaths){
            const { filePath, data } = await globalThis.electron.readFileDataFromPath(path, 'utf8');
            Palettes.import(data);
          }
          push({
            message: `Successfully imported palettes`,
            variant: 'success'
          });
        }
      });

      // spritesheets
      actions.register('spritesheet_import', async _ => {
        const { canceled, filePaths } = await globalThis.electron.openFileDialog([config.filetypes.spritesheets.save.extension]);
        if(!canceled && Array.isArray(filePaths)){
          for(const path of filePaths){
            const { filePath, data } = await globalThis.electron.readFileDataFromPath(path, 'utf8');
            Spritesheets.import(data);
          }
          push({
            message: `Successfully imported spritesheets`,
            variant: 'success'
          });
        }
      });

      actions.register('spritesheet_import_chr', async _ => {
        const { canceled, filePaths } = await globalThis.electron.openFileDialog(['chr']);
        if(!canceled && Array.isArray(filePaths)){
          for(const path of filePaths){
            const { filePath, data } = await globalThis.electron.readFileDataFromPath(path);
            Spritesheets.importCHR(data);
          }

          push({
            message: `Successfully imported chr`,
            variant: 'success'
          });
        }
      });

      actions.register('spritesheet_export_chr', async _ => {
        const { label, data } = Spritesheets.exportCHR();
        // saveDialog(filename(label, 'chr'), data);
        const { canceled, filePath } = await globalThis.electron.openSaveDialog(['chr']);
        if(!canceled && typeof filePath == 'string'){
          await globalThis.electron.saveAs(filePath, data);
          push({
            message: `Successfully exported chr`,
            variant: 'success'
          });
        }
      });

      actions.register('spritesheet_export', async _ => {
        const { canceled, filePath } = await globalThis.electron.openSaveDialog([config.filetypes.spritesheets.save.extension]);
        if(!canceled && typeof filePath == 'string'){
          await globalThis.electron.saveAs(filePath, Spritesheets.export(true));
          push({
            message: `Successfully exported spritesheets`,
            variant: 'success'
          });
        }
      });

      actions.register('spritesheet_export_png', async (e) => {  
        const { canceled, filePath } = await globalThis.electron.openSaveDialog(['png']);
        if(!canceled && typeof filePath == 'string'){
          Spritesheets.exportAsImage(async ({ buffer }) => {
            await globalThis.electron.saveBufferAs(filePath, buffer);
            push({
              message: `Successfully exported png`,
              variant: 'success'
            });
          });
        }
      });
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var FileSaver_min = createCommonjsModule(function (module, exports) {
    (function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});


    });

    const filename = (filename, extension) => {
      const d = new Date();
      const date = `${String(d.getFullYear())}_${String(d.getMonth()).padStart(2, '0')}_${String(d.getDay()).padStart(2, '0')}`;
      return `${date}_${filename}.${extension}`;
    };

    const fileDialog = (accept = [], callback = _ => _, options = { readAs: 'text'}) => {
      if(!Array.isArray(accept)){
        throw new Error(`Invalid 'fileDialog' accept. Expecting array of file extentions`);
      }
      if(typeof callback !== 'function'){
        throw new Error(`Invalid 'fileDialog' callback function`);
      }
      const  input = document.createElement('input');
      input.type = 'file';
      input.accept = accept.map(ext => ext.startsWith('.') ? ext : '.' + ext).join(',');
      
      input.addEventListener('change', e => { 
        // getting a hold of the file reference
        const file = e.target.files[0]; 

        // setting up the reader
        const reader = new FileReader();

        switch(options.readAs){
          case 'binary':
            reader.readAsBinaryString(file);
          break;
          case 'arraybuffer':
            reader.readAsArrayBuffer(file);
          break;
          case 'text':
          default:
            reader.readAsText(file, options.encoding || 'utf-8');
          break;
        }

        // here we tell the reader what to do when it's done reading...
        reader.addEventListener('load', (e) => {
          // call the palette import
          callback.call(null, file, e.target.result);
        });
      });
      
      // execute it
      input.click();
    };

    const saveDialog = (filename, data, options = {}) => {
      const blob = new Blob([data], { type: options.type || "application/json;charset=utf-8" });
      FileSaver_min.saveAs(blob, filename);
    };

    // webapp only actions
    if(!globalThis.electron){
      actions.register('window_close', _ => _);
      actions.register('window_minimize', _ => document.exitFullscreen());
      actions.register('window_maximize', _ => actions.execute('window_toggle_fullscreen'));
      
      actions.register('window_toggle_fullscreen', () => {
        if(!document.fullscreenElement){
          document.documentElement.requestFullscreen();
        }else {
          document.exitFullscreen();
        }
      });

      // project
      // import file programmatically in the webversion
      actions.register('project_open', (e) => {
        fileDialog([config.filetypes.project.save.extension], (file, data) => {
          // TODO: implement localstorage project management 
          // Project.open(file.name, data);
          Project.open(undefined, data);
          push({
            message: `Successfully opened project`,
            variant: 'success'
          });
        });
      });

      actions.register('project_save', (e) => {
        saveDialog(filename('insert_projectname', config.filetypes.project.save.extension), Project.export(true));
        push({
          message: `Successfully saved project`,
          variant: 'success'
        });
      });

      // palettes
      // import file programmatically in the webversion
      actions.register('palette_import', (e) => {
        fileDialog([config.filetypes.palettes.save.extension], (file, data) => {
          Palettes.import(data);
          push({
            message: `Successfully imported palettes`,
            variant: 'success'
          });
        });
      });
      // export
      actions.register('palette_export', (e) => {
        saveDialog(filename('palette', config.filetypes.palettes.save.extension), Palettes.export(true));
        push({
          message: `Successfully exported palettes`,
          variant: 'success'
        });
      });


      // spritesheets
      actions.register('spritesheet_import', (e) => {
        fileDialog([config.filetypes.spritesheets.save.extension], (file, data) => {
          Spritesheets.import(data);
          push({
            message: `Successfully imported spritesheets`,
            variant: 'success'
          });
        });
      });

      actions.register('spritesheet_export', (e) => {
        saveDialog(filename('spritesheet', config.filetypes.spritesheets.save.extension), Spritesheets.export(true));
        push({
          message: `Successfully exported spritesheets`,
          variant: 'success'
        });
      });

      actions.register('spritesheet_import_chr', (e) => {
        fileDialog(['chr'], (file, data) => {
          Spritesheets.importCHR(data);
          push({
            message: `Successfully imported chr`,
            variant: 'success'
          });
        }, { readAs: 'arraybuffer' });
      });

      actions.register('spritesheet_export_chr', (e) => {  
        const { label, data } = Spritesheets.exportCHR();
        saveDialog(filename(label, 'chr'), data);
      });

      actions.register('spritesheet_export_png', (e) => {  
        Spritesheets.exportAsImage(({ blob, label, options }) => {
          saveDialog(filename(label, 'png'), blob, { mimetype: blob.type });
          push({
            message: `Successfully exported png`,
            variant: 'success'
          });
        });
      });


      // tilemap
      actions.register('tilemap_import', (e) => {
        fileDialog([config.filetypes.tilemaps.save.extension], (file, data) => {
          Tilemaps.import(data);
        });
      });

      actions.register('tilemap_export', (e) => {
        saveDialog(filename('tilemap', config.filetypes.tilemaps.save.extension), Tilemaps.export(true));
      });

      actions.register('tilemap_export_nametable', (e) => {
        saveDialog(filename('tilemap_nametable', config.filetypes.tilemaps.export.extension), Tilemaps.exportNametableData());
      });

      actions.register('tilemap_export_png', (e) => {
        Tilemaps.exportAsImage(({ blob, label, options }) => {
          saveDialog(filename(label, 'png'), blob, { mimetype: blob.type });
        });
      });
    }

    // sub stores
    const { selectedColor: selectedColor$1 } = Palettes.stores;

    /*

      actions for both applications

    */
    // noop
    actions.register('noop', _ => _);

    // themes
    actions.register('toggle_theme', _ => document.documentElement.dataset.theme = document.documentElement.dataset.theme == 'dark' ? 'light' : 'dark');
    actions.register('light_theme', _ => document.documentElement.dataset.theme = 'light');
    actions.register('dark_theme', _ => document.documentElement.dataset.theme = 'dark');

    // project
    actions.register('project_create', _ => Project.create());
    actions.register('notification', ({ message, variant }) => {
      push({ message, variant });
    });
    // graphics general
    actions.register('graphics_center_artboard', _ => centerScrollAndCanvas());


    // palettes
    actions.register('palette_clear', _ => {Palettes.clear();});
    actions.register('palette_create', _ => Palettes.createLayer());
    actions.register('palette_remove', source => Palettes.removeLayer(source));
    actions.register('palette_clone_layer', source => Palettes.cloneLayer(source));
    actions.register('palette_clone_active_layer', _ => Palettes.cloneActiveLayer());
    actions.register('palette_make_layer_active', source => Palettes.makeLayerActive(source));
    actions.register('palette_swap_layers', ({ to, from }) => Palettes.stores.layers.swapLayers(to, from));
    actions.register('palette_update_layer_label', ({ source, label }) => Palettes.updateLayerLabel(source, label));
    actions.register('palette_active_color', n => selectedColor$1.setActiveColorIndex(n));

    // spritesheets
    actions.register('spritesheet_clear', _ => Spritesheets.clear());
    actions.register('spritesheet_create', _ => Spritesheets.createLayer());
    actions.register('spritesheet_remove', index => Spritesheets.removeLayer(index));
    actions.register('spritesheet_clone_layer', source => Spritesheets.cloneLayer(source));
    actions.register('spritesheet_clone_active_layer', _ => Spritesheets.cloneActiveLayer());
    actions.register('spritesheet_make_layer_active', source => Spritesheets.makeLayerActive(source));
    actions.register('spritesheet_swap_layers', ({ to, from }) => Spritesheets.stores.layers.swapLayers(to, from));
    actions.register('spritesheet_update_layer_label', ({ source, label }) => Spritesheets.updateLayerLabel(source, label));
    actions.register('spritesheet_zoom_in', _ => Spritesheets.stores.artboard.zoom(3));
    actions.register('spritesheet_zoom_out', _ => Spritesheets.stores.artboard.zoom(-2));
    actions.register('spritesheet_zoom_reset', _ => Spritesheets.stores.artboard.zoomReset());
    actions.register('spritesheet_set_active_tool', name => {
      // re-enable all groups before switching active tool
      manager.enableGroups('*', 'spritesheets');
      // set the new active tool
      Toolbar.activeTool.setActive(ToolTypes.get(name));
    });
    actions.register('spritesheet_tool_dblclick', _ => {
      const activeTool = Toolbar.activeTool.get();
      if(activeTool){
        if(typeof activeTool.dblclick == 'function'){
          activeTool.dblclick.call(activeTool);
        }
      }
    });
    actions.register('spritesheet_undo', _ => {
      const activeLayer = Spritesheets.stores.activeLayer.get();
      if(activeLayer){
        activeLayer.undo();
      }
    });

    actions.register('spritesheet_redo', _ => {
      const activeLayer = Spritesheets.stores.activeLayer.get();
      if(activeLayer){
        activeLayer.redo();
      }
    });

    actions.register('spritesheet_set_selected_tile', (data) => Spritesheets.stores.selectedTile.stores.current.set(data));


    // tilemaps
    actions.register('tilemap_clear', _ => Tilemaps.clear());
    actions.register('tilemap_create', () => {
      // create a new blank tilemap
      Tilemaps.createLayer();
    });

    actions.register('tilemap_remove', (source) => {
      // remove tilemap
      Tilemaps.removeLayer(source);
    });

    actions.register('tilemap_clone_layer', source => Tilemaps.cloneLayer(source));
    actions.register('tilemap_clone_active_layer', _ => Tilemaps.cloneActiveLayer());
    actions.register('tilemap_make_layer_active', source => Tilemaps.makeLayerActive(source));
    actions.register('tilemap_swap_layers', ({ to, from }) => Tilemaps.stores.layers.swapLayers(to, from));
    actions.register('tilemap_update_layer_label', ({ source, label }) => Tilemaps.updateLayerLabel(source, label));
    // ActionsManager.register('tilemap_zoom', level => view.zoom(level));
    // ActionsManager.register('tilemap_zoom_in', _ => view.zoom(get(spritesheetsStore).zoom+1));
    // ActionsManager.register('tilemap_zoom_out', _ => view.zoom(get(spritesheetsStore).zoom-1));
    // ActionsManager.register('tilemap_zoom_reset', _ => view.zoom());
    // ActionsManager.register('tilemap_set_active_tool', _enum => Toolbar.activeTool.setActive(_enum));

    // tools 
    actions.register('tool_action', (fn) => {
      if(typeof fn !== 'function'){
        throw new Error(`Invalid action call. 'tool_action' expecting a valid function.`);
      }
      fn.call(null);
    });

    const prepare = (base, route) => {
      // prefix the base to always start with a '/' and remove trailing slash
      base = '/'+base.replace(/^[\/]+|[\/]+$/g, '');
      // strip multiple occurences of '/'
      route = (`${base}/${route}`).replace(/[\/]+/g, '/');
      // remove leading and trailing slashes
      route = route.replace(/^[\/]+|[\/]+$/g, '');
      // get if it's explicit or not. could be a factor when determining route based on it's size/weight 
      // in terms of what has presedent when two routes would've matched the same url
      const explicit = /\*$/.test(route);
      // if it's implicit or explicit
      const lazy = explicit ? (route = route.replace(/[\*]+$/g, ''), ''): '/?$';
      // store parameters
      const parameters = [];
      let index = 0;
      let regexpRoute = route.replace(/(:)?([^\\/]+)/g, (parameter, colonParameter, identifier) => {
        const [ param, boundValue ] = identifier.split('->');
        if(colonParameter){
          // check for duplicates
          const duplicates = parameters.filter(old => old.identifier == boundValue); 
          if(duplicates.length > 0){
            throw new Error(`Duplicated parameter. [${duplicates.map(_=>_.identifier)}]`);
          }
          // store parameter reference
          parameters.push({
            index: index++,
            parameter,
            identifier: param,
          });
          // bound parameter
          return boundValue ? `(${boundValue})` : `([^\/]+)`;
        }
        return `${parameter}`;
      });
      regexpRoute = `^/${regexpRoute}${lazy}`;
      return {
        base,
        route,
        regexpRoute,
        parameters,
      }
    };

    class Route{
      constructor(base, route, fn, middlewares = []){
        Object.assign(this, prepare(base, route));
        this.callback = fn;
        this.middlewares = middlewares;
      }
    }

    class Middleware{
      constructor(...props){
        this.props = props;
      }
      use(fn){
        if(typeof fn != 'function'){
          throw new Error(`Invalid Middleware use argument. Expecting 'function' got : '${typeof fn}'`); 
        }
        const f = (stack) => next => stack(fn.bind(this, ...this.props, next));
        this.execute = f(this.execute);
        return this;
      }
      execute(fn){
        return fn.call(null);
      }
    }

    class Request{
      constructor(props){
        Object.assign(this, {
          base: '',
          path: '',
          route: '',
          query: {},
          params: {},
          state: {}
        }, props);
      }
    }

    class Response{
      constructor(callbacks){
        Object.assign(this, callbacks);
      }
    }

    // router
    class Router{
      constructor(props){
        // store properties and freeze them so not to be able to get modified
        Object.freeze(this.__properties = {
          initial: undefined,
          base: '',
          state: {},
          ...props
        });
        // are we subscribing?
        this.__subscribing = false;
        // store
        this.__get = new Map();
        this.__catch = new Map();
        this.__use = new Set();
      }
      _register(routes, fn, middlewares, list){
        routes.map(route => {
          const r = new Route(this.__properties.base, route, fn, middlewares);
          if(list.has(r.regexpRoute)){
            throw new Error(`Route with same endpoint already exist. [${route}, /${list.get(r.regexpRoute).route}](${r.regexpRoute})`);
          }
          list.set(r.regexpRoute, r);
        });
        return routes;
      }
      _props(...args){
        let routes, fn, middlewares = [];
        if(args.length == 1){
          [ fn ] = args;
          routes = '*';
        }else if(args.length == 2){
          [ routes, fn ] = args;
        }else if(args.length > 2){
          routes = args.shift();
          fn = args.pop();
          middlewares = args;      
        }else {
          throw new Error(`Invalid number prop arguments.`);
        }
        routes = Array.isArray(routes) ? routes : [routes];
        return { routes, fn, middlewares };
      }
      _storeInList(fnName, list, ...args){
        const { routes, fn, middlewares } = this._props(...args);
        const parentRoutes = this._register(routes, fn, middlewares, list);
        // enable chaining to group sub routes to a main route
        // not needed since the routes are store as unique strings in the end 
        // but might be a nicer way to organize the implementation
        const ret = {
          [fnName]: (...innerArgs) => {
            const { routes: innerRoutes, fn: innerFn, middlewares: innerMiddlewares } = this._props(...innerArgs);
            parentRoutes.map(route => innerRoutes.map(_ => route + _).map(_ => this[fnName](_, ...[...innerMiddlewares, innerFn])));
            return ret;
          }
        };
        return ret;
      }
      get(...args){
        return this._storeInList('get', this.__get, ...args);
      }
      use(...args){
        const { routes, fn } = this._props(args);
        routes.map(url => this.__use.add(new Route(this.__properties.base, url, ...fn)));
      }
      catch(...args){
        return this._storeInList('catch', this.__catch, ...args);
      }
      _findRoute(url, list, data){
        for(let [ regexpRoute, RouteInstance ] of list){
          const parameters = url.match(new RegExp(regexpRoute, 'i'));
          if(parameters){
            parameters.shift();
            // update Route with new parameters
            let params = {};
            if(parameters.length > 0){
              // create a parameters object
              params = RouteInstance.parameters.reduce((obj, value, index) => {
                obj[value.identifier] = parameters[index];
                return obj;
              }, params);
            }
            // query parameters
            const urlParams = new URLSearchParams(window.location.search);
            const queryParameters = {};
            for(const [key, value] of urlParams.entries()){ 
              if(queryParameters[key]){
                if(Array.isArray(queryParameters[key])){
                  queryParameters[key].push(value);
                }else {
                  queryParameters[key] = [queryParameters[key], value];
                }
              }else {
                queryParameters[key] = value;
              }
            }
            // update request object
            const returnObject = { 
              RouteInstance,
              Request: new Request({
                path: url,
                route: '/' + RouteInstance.route,
                base: RouteInstance.base,
                query: queryParameters,
                params: params,
                state: { ...data },
              })
            };
            return returnObject;
          }
        }
      }
      execute(url, data = {}){
        if(typeof url != 'string'){
          throw new Error(`Invalid 'execute' argument. Expecting 'string'`);
        }
        if(!this.__subscribing){
          return;
        }
        const response = new Response({
          send: (...props) => this.__router_callback.call(null, ...props),
          error: (props) => {
            const errorsFound = this._findRoute(url, this.__catch, data);
            if(!errorsFound){
              console.warn(`No route or catch fallbacks found for [${url}]`);
              return;
            }
            errorsFound.RouteInstance.callback.call(null, errorsFound.Request, response, props);
          }
        });
        let matchFound = this._findRoute(url, this.__get, data);
        if(!matchFound){
          response.error();
          return;
        }
        let middlewares = [];
        const middleware = new Middleware(matchFound.Request, response);
        this.__use.forEach(middlewareRoute => {
          const RouteInstance = url.match(new RegExp(middlewareRoute.regexpRoute, 'i'));
          if(RouteInstance){
            middlewares.push(middlewareRoute.callback);
          }
        });
        middlewares = [...middlewares, ...matchFound.RouteInstance.middlewares, matchFound.RouteInstance.callback];
        middlewares.map(fn => middleware.use(fn));
        // execute middleware
        middleware.execute();
      }
      subscribe(fn){
        this.__subscribing = true;
        if(typeof fn == 'function'){
          this.__router_callback = fn;
        }
        if(this.__properties.initial){
          this.execute(this.__properties.initial, this.__properties.state);
        }
        return () => {
          this.__subscribing = false;
        }
      }
    }

    class SvelteStandaloneRouterError extends Error{}
    class SvelteRouter extends Router{}

    // setting a singleton class with properties for 'global' access
    let Router$1 = new class RouterProperties{
      constructor(){
        this.__linkBase = '';
        this.__scrollReset = true;
        this.__scrollOffset = 0;
      }
      setLinkBase(value){
        if(typeof value != 'string'){
          throw new SvelteStandaloneRouterError(`Invalid 'linkBase'. Expecting value of type 'string'`);
        }
        return this.__linkBase = value.endsWith('/') ? value : value + '/';
      }
      set linkBase(value){
        return this.setLinkBase(value);
      }
      get linkBase(){
        return this.__linkBase;
      }
      
      // handle scroll reset
      setScrollReset(value){
        if(typeof value != 'boolean'){
          throw new SvelteStandaloneRouterError(`Invalid 'scrollReset'. Expecting value of type 'boolean'`);
        }
        return this.__scrollReset = value;
      }
      set scrollReset(value){
        return this.setScrollReset(value);
      }
      get scrollReset(){
        return this.__scrollReset;
      }

      // handle scroll reset
      setScrollOffset(value){
        if(typeof value != 'number'){
          throw new SvelteStandaloneRouterError(`Invalid 'scrollOffset'. Expecting value of type 'number'`);
        }
        return this.__scrollOffset = value;
      }
      set scrollOffset(value){
        return this.setScrollOffset(value);
      }
      get scrollOffset(){
        return this.__scrollOffset;
      }
    };

    // handle the linkBase in pathname
    const getPathname = (path) => {
      const re = new RegExp(`^${Router$1.linkBase}`, 'i');
      path = `/${path}/`.replace(/[\/]+/g, '/').replace(re, '').replace(/^\/|\/$/g, '');
      return '/' + path;
    };

    // dispatch custom event
    const dispatch$1 = ({ state }) => {
      dispatchEvent(new CustomEvent('popstate', { 
        detail: {
          ...state
        } 
      }));
    };

    // navigate to a new page and pushing it to the History object
    const navigate = (url, state = {}) => {
      url = cleanURL(url);
      history.pushState(state, '', url);
      dispatch$1({ url, state }); 
    };

    // redirect to a new page and replacing it on the History object
    const redirect = (url, state = {}) => {
      url = cleanURL(url);
      history.replaceState(state, '', url);
      dispatch$1({ url, state });
    };

    // change url without route change and add it to the History
    const replace = (url, state = {}) => {
      history.pushState(state, '', cleanURL(url));
    };

    // change url without route change and DON'T add it to the History
    const alter = (url, state = {}) => {
      history.replaceState(state, '', cleanURL(url));
    };

    // replace all duplicate '/' that might be going on
    const cleanURL = (url) => `/${Router$1.linkBase}/${url}`.replace(/[\/]+/g, '/');

    // internal goto helper 
    const internalGoTo = (path, e) => {
      replace(getPathname(path));
      const hash = window.location.hash.slice(1);
      if(hash){
        if(e){
          e.preventDefault();
        }
        const element = document.querySelector(`a[name="${hash}"], #${hash}`);
        if(element){
          const topPos = element.getBoundingClientRect().top + window.pageYOffset - Router$1.scrollOffset;
          window.scrollTo({ top: topPos });
        }
      }
    };

    let prev = { location: { ...window.location }, firstLoad: false };
    let contexts = new Map();
    let location$1 = writable();

    let initialized = false;
    let firstLoad = false;

    // handle internal # links
    const internalLinksHandler = (e) => {
      const target = e.target;
      if(target.tagName == 'A'){
        const href = target.getAttribute('href');
        const isHashLink = href.indexOf('#') > -1;
        if(!(/^[a-zA-Z]+\:\/\/(.*)/.test(href)) && isHashLink){
          // go to position
          internalGoTo(href.startsWith('#') ? window.location.pathname + href : href, e);
          // update the prev data
          prev.location = { ...window.location };
        }
      }
    };

    // the popstate callback handler
    const popstateHandler = async e => {
      let endEarly = false;
      const sameURL = cleanURL(window.location.pathname + '/') == cleanURL(prev.location.pathname + '/') && prev.location.search == window.location.search;
      // don't continue if we are doing internal hash linking
      if(window.location.hash != '' && sameURL && prev.firstLoad){
        endEarly = true;
      }

      // if the hash is empty and not the same as the previous and it's on the same url we 
      // don't want to load a new page, then we simply end early and scroll to the top.
      if(window.location.hash == '' && window.location.hash != prev.location.hash && sameURL){
        endEarly = true;
        window.scrollTo({ top: 0 });
      }

      // if we don't end early we want to update the router contexts
      if(!endEarly){
        // update location and execute the router contexts
        location$1.set(getPathname(window.location.pathname));
        contexts.forEach(context => context.router.execute(window.location.pathname, e.detail));
      }

      // update the prev data
      prev.location = { ...window.location };
    };

    // if the popstate listener has been destroy 'mount' re-adds the listener 
    const mount = async () => {
      if(!initialized){
        // mark it initialized and update the location store with the current pathname
        initialized = true;
        if(!firstLoad){
          firstLoad = true;
          location$1.set(getPathname(window.location.pathname));
        }
        window.addEventListener('popstate', popstateHandler);
        window.addEventListener('click', internalLinksHandler);
      }
    };

    // export the context creator "wrapper"
    var context = (options) => {
      // mount on the first load to avoid having 
      // the user doing it manually
      mount();
      // creates a new context
      const router = new SvelteRouter(options);
      contexts.set(router, {
        component: writable(),
        router
      });
      return router;
    };

    /* node_modules\svelte-standalone-router\router.svelte generated by Svelte v3.31.2 */

    const { Error: Error_1 } = globals;

    const get_default_slot_changes$1 = dirty => ({
    	component: dirty & /*$component*/ 1,
    	props: dirty & /*$component*/ 1,
    	decorator: dirty & /*$component*/ 1,
    	decoratorProps: dirty & /*$component*/ 1
    });

    const get_default_slot_context$1 = ctx => ({
    	component: /*$component*/ ctx[0].context,
    	props: /*$component*/ ctx[0].props,
    	decorator: /*$component*/ ctx[0].decorator,
    	decoratorProps: /*$component*/ ctx[0].decoratorProps
    });

    // (54:0) {#if $component}
    function create_if_block$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], get_default_slot_context$1);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, $component*/ 17) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_default_slot_changes$1, get_default_slot_context$1);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*$component*/ 1) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(54:0) {#if $component}",
    		ctx
    	});

    	return block;
    }

    // (60:4) {:else}
    function create_else_block$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*$component*/ ctx[0].props];
    	var switch_value = /*$component*/ ctx[0].context;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$component*/ 1)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*$component*/ ctx[0].props)])
    			: {};

    			if (switch_value !== (switch_value = /*$component*/ ctx[0].context)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(60:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (56:4) {#if $component.decorator}
    function create_if_block_1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		/*$component*/ ctx[0].decoratorProps
    		? /*$component*/ ctx[0].decoratorProps
    		: {}
    	];

    	var switch_value = /*$component*/ ctx[0].decorator;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot$1] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$component*/ 1)
    			? get_spread_update(switch_instance_spread_levels, [
    					get_spread_object(/*$component*/ ctx[0].decoratorProps
    					? /*$component*/ ctx[0].decoratorProps
    					: {})
    				])
    			: {};

    			if (dirty & /*$$scope, $component*/ 17) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*$component*/ ctx[0].decorator)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(56:4) {#if $component.decorator}",
    		ctx
    	});

    	return block;
    }

    // (57:6) <svelte:component this={$component.decorator} {...($component.decoratorProps ? $component.decoratorProps : {})}>
    function create_default_slot$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*$component*/ ctx[0].props];
    	var switch_value = /*$component*/ ctx[0].context;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$component*/ 1)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*$component*/ ctx[0].props)])
    			: {};

    			if (switch_value !== (switch_value = /*$component*/ ctx[0].context)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(57:6) <svelte:component this={$component.decorator} {...($component.decoratorProps ? $component.decoratorProps : {})}>",
    		ctx
    	});

    	return block;
    }

    // (55:140)       
    function fallback_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$component*/ ctx[0].decorator) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(55:140)       ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$component*/ ctx[0] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$component*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$component*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $component;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, ['default']);
    	let { context = contexts.keys().next().value } = $$props;

    	if (!context || !(context instanceof SvelteRouter)) {
    		throw new Error(`Invalid Router context. Did you initialize the component with a valid context?`);
    	}

    	const { component } = contexts.get(context);
    	validate_store(component, "component");
    	component_subscribe($$self, component, value => $$invalidate(0, $component = value));

    	context.subscribe(async (callback, props = {}, decorator = {}) => {
    		// a dirty check to see it is a "component". Since there is not way to check if it is a svelte component
    		// this would atleast force it to be a function and will catch most errors where a svelte component isn't passed
    		if (typeof callback != "function") {
    			throw new SvelteStandaloneRouterError(`Unable to load component. Did you pass a valid svelte component to the 'send' response?`);
    		}

    		// reset the scroll position depending on the static scrollReset value
    		if (Router$1.scrollReset) {
    			// always start from the top of the page
    			window.scrollTo({ top: 0 });
    		}

    		// update the writable store
    		component.set({
    			context: decorator
    			? callback
    			: class extends callback {
    					
    				},
    			decorator: !decorator.component
    			? undefined
    			: class extends decorator.component {
    					
    				},
    			decoratorProps: decorator.props || undefined,
    			props
    		});

    		// if we have visited a a url with a hash in it
    		// we need to await a tick so the component is loaded
    		// before we can scroll to that place in the dom
    		if (window.location.hash) {
    			await tick();

    			// but we also have this weird behaviour where the location pathname is
    			// not accessible so we need to pass it manually.
    			setTimeout(
    				() => {
    					internalGoTo(window.location.pathname + window.location.hash);
    				},
    				0
    			);
    		}

    		// flag that we have a first load
    		if (!prev.firstLoad) {
    			prev.firstLoad = true;
    		}
    	});

    	const writable_props = ["context"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("context" in $$props) $$invalidate(2, context = $$props.context);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		RouterContext: SvelteRouter,
    		Router: Router$1,
    		SvelteStandaloneRouterError,
    		contexts,
    		prev,
    		internalGoTo,
    		context,
    		component,
    		$component
    	});

    	$$self.$inject_state = $$props => {
    		if ("context" in $$props) $$invalidate(2, context = $$props.context);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$component, component, context, slots, $$scope];
    }

    class Router_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { context: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router_1",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get context() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set context(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var link = (element, props) => {
      props = {
        type: 'navigate',
        state: {},
        title: '',
        ...props
      };

      if(Router$1.linkBase){
        // first we need to clean the url and add the linkbase. Thats so one can right click and
        // open the page in a new tab or window and go to the right url
        const clean = cleanURL(element.getAttribute('href') || '');
        element.setAttribute('href', clean);
      }
      
      const clickHandler = (e) => {
        // make the check before preventing default behaviour since we should not block 
        // the default behaviour if we don't supply the required url string
        let url = props.to || props.href || e.currentTarget.getAttribute('href') || e.currentTarget.getAttribute('data-href');
        if(!url){
          return;
        }
        // here we need to only get the pathname without any linkbase
        // because that is handled in the navigational helpers
        url = getPathname(url);
        e.preventDefault();
        if(props.type == 'navigate'){
          navigate(url, props.state, props.title);
        }else if(props.type == 'redirect'){
          redirect(url, props.state, props.title);
        }else if(props.type == 'replace'){
          replace(url, props.state, props.title);
        }else if(props.type == 'alter'){
          alter(url, props.state, props.title);
        }else {
          console.warn(`Invalid 'use:link' type. Expecting 'navigate'(default), 'redirect', 'replace' or 'alter'`);
          return;
        }
      };
      element.addEventListener('click', clickHandler);
      return {
        update(parameters){
          props = {
            ...props,
            ...parameters
          };
        },
        destroy(){element.removeEventListener('click', clickHandler);}
      }
    };

    var decorator = (context, ...middleware) => {
      let decorator;
      // if no context is provided
      if(!(context instanceof SvelteRouter)){
        // then the context is actually the decorator
        decorator = context;
        // and so we get the first context from the context Map
        context = contexts.keys().next().value;
      }else {
        // but if we have a context the decorator is located at the first position
        // of the middlewares so we need to remove it and define it as the decorator
        decorator = middleware.shift();
      }
      if(!context){
        throw new Error(`Invalid Router context. Did you initialize the decorator with a valid context? or made sure to call it after one has been created?`);
      }
      // we need to keep track of the root url else 
      // everything would become nested one level deeper
      let root = '';
      const wrappedCall = (url, ...fns) => {
        // define the root of the chaining
        if(!root) root = url;
        let decoratorProps;
        let decoratorPropsCallback = (props) => {
          decoratorProps = { ...props };
        };
        const callback = fns.pop();
        context.get(url, ...[...middleware, ...fns], (req, res) => {
          callback(req, {
            send: (component, props) => {
              res.send(component, props, { component: decorator, props: decoratorProps });
            },
            error: res.error
          }, decoratorPropsCallback);
        });
        return {
          get: (_url, ...args) => wrappedCall(`${root}/${_url}`, ...args)
        };
      };
      return wrappedCall;
    };

    /* src\_views\GeneralError.svelte generated by Svelte v3.31.2 */

    const file$7 = "src\\_views\\GeneralError.svelte";

    function create_fragment$a(ctx) {
    	let div;
    	let h1;
    	let t1;
    	let p;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			h1.textContent = "This page is not available";
    			t1 = space();
    			p = element("p");
    			p.textContent = "Currently not available in this version of the application.";
    			add_location(h1, file$7, 1, 2, 27);
    			add_location(p, file$7, 2, 2, 66);
    			attr_dev(div, "class", "checkered svelte-19ubedp");
    			add_location(div, file$7, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(div, t1);
    			append_dev(div, p);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GeneralError", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GeneralError> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class GeneralError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GeneralError",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    // no sub dir for localhost
    {
      Router$1.linkBase = subDir;
    }

    // router context
    const app = context({ initial: window.location.pathname, base: Router$1.linkBase });

    // general fallback
    app.catch((req, res) => {
      res.send(GeneralError);
    });

    /* src\_components\Tabmenu.svelte generated by Svelte v3.31.2 */

    const file$8 = "src\\_components\\Tabmenu.svelte";

    function create_fragment$b(ctx) {
    	let div;
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "id", "areanav");
    			attr_dev(ul, "class", "svelte-1vnr3x8");
    			add_location(ul, file$8, 1, 2, 21);
    			attr_dev(div, "id", "tabnav");
    			attr_dev(div, "class", "svelte-1vnr3x8");
    			add_location(div, file$8, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tabmenu", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tabmenu> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Tabmenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabmenu",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src\_components\documentation\SectionNavigation.svelte generated by Svelte v3.31.2 */
    const file$9 = "src\\_components\\documentation\\SectionNavigation.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (13:2) {#each list as prop}
    function create_each_block$2(ctx) {
    	let li;
    	let button;
    	let t0_value = /*prop*/ ctx[2].label + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "href", /*prop*/ ctx[2].href);
    			attr_dev(button, "label", /*prop*/ ctx[2].label);
    			attr_dev(button, "class", "svelte-1p6gkk9");
    			add_location(button, file$9, 14, 6, 434);
    			attr_dev(li, "class", "no-drag");
    			toggle_class(li, "active", /*prop*/ ctx[2].href == /*$location*/ ctx[0]);
    			add_location(li, file$9, 13, 4, 368);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, button));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list, $location*/ 3) {
    				toggle_class(li, "active", /*prop*/ ctx[2].href == /*$location*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(13:2) {#each list as prop}",
    		ctx
    	});

    	return block;
    }

    // (12:0) <Tabmenu>
    function create_default_slot$2(ctx) {
    	let each_1_anchor;
    	let each_value = /*list*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list, $location*/ 3) {
    				each_value = /*list*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(12:0) <Tabmenu>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let tabmenu;
    	let current;

    	tabmenu = new Tabmenu({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabmenu.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabmenu_changes = {};

    			if (dirty & /*$$scope, $location*/ 33) {
    				tabmenu_changes.$$scope = { dirty, ctx };
    			}

    			tabmenu.$set(tabmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $location;
    	validate_store(location$1, "location");
    	component_subscribe($$self, location$1, $$value => $$invalidate(0, $location = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SectionNavigation", slots, []);

    	let list = [
    		{
    			href: "/documentation",
    			label: "Documentation"
    		},
    		{
    			href: "/documentation/roadmap",
    			label: "Roadmap"
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SectionNavigation> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		application,
    		link,
    		location: location$1,
    		Tabmenu,
    		list,
    		$location
    	});

    	$$self.$inject_state = $$props => {
    		if ("list" in $$props) $$invalidate(1, list = $$props.list);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$location, list];
    }

    class SectionNavigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SectionNavigation",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src\_decorators\_Documentation.svelte generated by Svelte v3.31.2 */
    const file$a = "src\\_decorators\\_Documentation.svelte";

    function create_fragment$d(ctx) {
    	let section;
    	let div0;
    	let sectionnavigation;
    	let t0;
    	let div1;
    	let article;
    	let header;
    	let h1;
    	let t2;
    	let p;
    	let t4;
    	let current;
    	sectionnavigation = new SectionNavigation({ $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			create_component(sectionnavigation.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			article = element("article");
    			header = element("header");
    			h1 = element("h1");
    			h1.textContent = "Documentation";
    			t2 = space();
    			p = element("p");
    			p.textContent = "This documentation is under development and will change frequently. If something is behaving unexpectedly or \r\n        you think you've found a bug, please get in touch over discord. Thanks :)";
    			t4 = space();
    			if (default_slot) default_slot.c();
    			add_location(div0, file$a, 5, 2, 157);
    			add_location(h1, file$a, 11, 8, 265);
    			add_location(header, file$a, 10, 6, 247);
    			add_location(p, file$a, 13, 6, 312);
    			attr_dev(article, "class", "svelte-owv9to");
    			add_location(article, file$a, 9, 4, 230);
    			attr_dev(div1, "class", "content svelte-owv9to");
    			add_location(div1, file$a, 8, 2, 203);
    			attr_dev(section, "class", "documentation checkered svelte-owv9to");
    			add_location(section, file$a, 4, 0, 112);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			mount_component(sectionnavigation, div0, null);
    			append_dev(section, t0);
    			append_dev(section, div1);
    			append_dev(div1, article);
    			append_dev(article, header);
    			append_dev(header, h1);
    			append_dev(article, t2);
    			append_dev(article, p);
    			append_dev(article, t4);

    			if (default_slot) {
    				default_slot.m(article, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sectionnavigation.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sectionnavigation.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(sectionnavigation);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Documentation", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Documentation> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ SectionNavigation });
    	return [$$scope, slots];
    }

    class Documentation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Documentation",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src\_singles\buttons\ToolButton.svelte generated by Svelte v3.31.2 */

    const file$b = "src\\_singles\\buttons\\ToolButton.svelte";

    function create_fragment$e(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "title", /*title*/ ctx[1]);
    			attr_dev(button, "class", "svelte-1j1cp6x");
    			toggle_class(button, "selected", /*selected*/ ctx[0]);
    			add_location(button, file$b, 5, 0, 80);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "dblclick", /*dblclick_handler*/ ctx[4], false, false, false),
    					listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*title*/ 2) {
    				attr_dev(button, "title", /*title*/ ctx[1]);
    			}

    			if (dirty & /*selected*/ 1) {
    				toggle_class(button, "selected", /*selected*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ToolButton", slots, ['default']);
    	let { selected } = $$props;
    	let { title = undefined } = $$props;
    	const writable_props = ["selected", "title"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ToolButton> was created with unknown prop '${key}'`);
    	});

    	function dblclick_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ selected, title });

    	$$self.$inject_state = $$props => {
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selected, title, $$scope, slots, dblclick_handler, click_handler];
    }

    class ToolButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { selected: 0, title: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToolButton",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*selected*/ ctx[0] === undefined && !("selected" in props)) {
    			console.warn("<ToolButton> was created without expected prop 'selected'");
    		}
    	}

    	get selected() {
    		throw new Error("<ToolButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<ToolButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<ToolButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ToolButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_views\documentation\Spritesheets.md generated by Svelte v3.31.2 */
    const file$c = "src\\_views\\documentation\\Spritesheets.md";

    // (75:2) <ToolButton selected>
    function create_default_slot_12(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Pointer.icon);
    			add_location(path, file$c, 76, 6, 2840);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 75, 4, 2750);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(75:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (85:2) <ToolButton selected>
    function create_default_slot_11(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Eyedropper.icon);
    			add_location(path, file$c, 86, 6, 3141);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 85, 4, 3051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(85:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (95:2) <ToolButton selected>
    function create_default_slot_10(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Pen.icon);
    			add_location(path, file$c, 96, 6, 3438);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 95, 4, 3348);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(95:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (107:2) <ToolButton selected>
    function create_default_slot_9(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Circle.icon);
    			add_location(path, file$c, 108, 6, 3837);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 107, 4, 3747);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(107:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (119:2) <ToolButton selected>
    function create_default_slot_8(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Line.icon);
    			add_location(path, file$c, 120, 6, 4224);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 119, 4, 4134);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(119:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (130:2) <ToolButton selected>
    function create_default_slot_7(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Paintbucket.icon);
    			add_location(path, file$c, 131, 6, 4540);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 130, 4, 4450);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(130:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (145:2) <ToolButton selected>
    function create_default_slot_6(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Brush.icon);
    			add_location(path, file$c, 146, 6, 5288);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 145, 4, 5198);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(145:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (157:2) <ToolButton selected>
    function create_default_slot_5(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Colorattribute.icon);
    			add_location(path, file$c, 158, 6, 5828);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 157, 4, 5738);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(157:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (168:2) <ToolButton selected>
    function create_default_slot_4(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Colorswap.icon);
    			add_location(path, file$c, 169, 6, 6297);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 168, 4, 6207);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(168:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (179:2) <ToolButton selected>
    function create_default_slot_3(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Transpose.icon);
    			add_location(path, file$c, 180, 6, 6664);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 179, 4, 6574);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(179:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (191:2) <ToolButton selected>
    function create_default_slot_2$1(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Transform.icon);
    			add_location(path, file$c, 192, 6, 7077);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 191, 4, 6987);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(191:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (203:2) <ToolButton selected>
    function create_default_slot_1$1(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Patternpreview.icon);
    			add_location(path, file$c, 204, 6, 7460);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 203, 4, 7370);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(203:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    // (214:2) <ToolButton selected>
    function create_default_slot$3(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tools*/ ctx[0].Zoom.icon);
    			add_location(path, file$c, 215, 6, 7865);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 214, 4, 7775);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(214:2) <ToolButton selected>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let h20;
    	let t1;
    	let p0;
    	let t3;
    	let h40;
    	let t5;
    	let ul0;
    	let li0;
    	let strong0;
    	let t7;
    	let t8;
    	let li1;
    	let strong1;
    	let t10;
    	let t11;
    	let li2;
    	let strong2;
    	let t13;
    	let t14;
    	let li3;
    	let strong3;
    	let t16;
    	let t17;
    	let h41;
    	let t19;
    	let ul1;
    	let li4;
    	let strong4;
    	let t21;
    	let t22;
    	let li5;
    	let strong5;
    	let t24;
    	let t25;
    	let h21;
    	let t27;
    	let p1;
    	let t29;
    	let p2;
    	let t31;
    	let h5;
    	let t33;
    	let div0;
    	let toolbutton0;
    	let t34;
    	let p3;
    	let strong6;
    	let t36;
    	let t37;
    	let div1;
    	let toolbutton1;
    	let t38;
    	let p4;
    	let strong7;
    	let t40;
    	let t41;
    	let div2;
    	let toolbutton2;
    	let t42;
    	let p5;
    	let strong8;
    	let t44;
    	let br0;
    	let em0;
    	let strong9;
    	let t46;
    	let t47;
    	let br1;
    	let em1;
    	let strong10;
    	let t49;
    	let t50;
    	let div3;
    	let toolbutton3;
    	let t51;
    	let p6;
    	let strong11;
    	let t53;
    	let br2;
    	let em2;
    	let strong12;
    	let t55;
    	let t56;
    	let br3;
    	let em3;
    	let strong13;
    	let t58;
    	let t59;
    	let div4;
    	let toolbutton4;
    	let t60;
    	let p7;
    	let strong14;
    	let t62;
    	let br4;
    	let em4;
    	let strong15;
    	let t64;
    	let t65;
    	let div5;
    	let toolbutton5;
    	let t66;
    	let p8;
    	let strong16;
    	let t68;
    	let br5;
    	let em5;
    	let strong17;
    	let t70;
    	let t71;
    	let br6;
    	let em6;
    	let strong18;
    	let t73;
    	let t74;
    	let br7;
    	let em7;
    	let strong19;
    	let t76;
    	let t77;
    	let br8;
    	let em8;
    	let strong20;
    	let t79;
    	let t80;
    	let br9;
    	let em9;
    	let strong21;
    	let t82;
    	let t83;
    	let div6;
    	let toolbutton6;
    	let t84;
    	let p9;
    	let strong22;
    	let t86;
    	let br10;
    	let em10;
    	let strong23;
    	let t88;
    	let t89;
    	let br11;
    	let em11;
    	let strong24;
    	let t91;
    	let t92;
    	let div7;
    	let toolbutton7;
    	let t93;
    	let p10;
    	let strong25;
    	let t95;
    	let t96;
    	let div8;
    	let toolbutton8;
    	let t97;
    	let p11;
    	let strong26;
    	let t99;
    	let br12;
    	let em12;
    	let strong27;
    	let t101;
    	let t102;
    	let div9;
    	let toolbutton9;
    	let t103;
    	let p12;
    	let strong28;
    	let t105;
    	let br13;
    	let em13;
    	let strong29;
    	let t107;
    	let t108;
    	let br14;
    	let em14;
    	let strong30;
    	let t110;
    	let t111;
    	let div10;
    	let toolbutton10;
    	let t112;
    	let p13;
    	let strong31;
    	let t114;
    	let br15;
    	let em15;
    	let strong32;
    	let t116;
    	let t117;
    	let br16;
    	let em16;
    	let strong33;
    	let t119;
    	let t120;
    	let div11;
    	let toolbutton11;
    	let t121;
    	let p14;
    	let strong34;
    	let t123;
    	let br17;
    	let em17;
    	let strong35;
    	let t125;
    	let t126;
    	let div12;
    	let toolbutton12;
    	let t127;
    	let p15;
    	let strong36;
    	let t129;
    	let br18;
    	let em18;
    	let strong37;
    	let t131;
    	let current;

    	toolbutton0 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton1 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton2 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton3 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton4 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton5 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton6 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton7 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton8 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton9 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton10 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton11 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton12 = new ToolButton({
    			props: {
    				selected: true,
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h20 = element("h2");
    			h20.textContent = "General";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "There is shortcuts for most of everything for an intuitive native feel. Sometimes shortcuts overlapping depending on what section of the application one is currently on.";
    			t3 = space();
    			h40 = element("h4");
    			h40.textContent = "Global shortcuts";
    			t5 = space();
    			ul0 = element("ul");
    			li0 = element("li");
    			strong0 = element("strong");
    			strong0.textContent = "f11";
    			t7 = text(" Toggle fullscreen");
    			t8 = space();
    			li1 = element("li");
    			strong1 = element("strong");
    			strong1.textContent = "alt + enter";
    			t10 = text(" Toggle fullscreen");
    			t11 = space();
    			li2 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "ctrl + o";
    			t13 = text(" Open a new project");
    			t14 = space();
    			li3 = element("li");
    			strong3 = element("strong");
    			strong3.textContent = "ctrl + s";
    			t16 = text(" Save project");
    			t17 = space();
    			h41 = element("h4");
    			h41.textContent = "Spritesheet shortcuts";
    			t19 = space();
    			ul1 = element("ul");
    			li4 = element("li");
    			strong4 = element("strong");
    			strong4.textContent = "1,2,3,4";
    			t21 = text(" Change color value");
    			t22 = space();
    			li5 = element("li");
    			strong5 = element("strong");
    			strong5.textContent = "ctrl + d";
    			t24 = text(" Duplicate active layer/create new layer of none exist");
    			t25 = space();
    			h21 = element("h2");
    			h21.textContent = "Spritesheet";
    			t27 = space();
    			p1 = element("p");
    			p1.textContent = "All the different tools of the spritsheet editor.";
    			t29 = space();
    			p2 = element("p");
    			p2.textContent = "A small warning. Only drawing(in general everything except the color attributes at the time of this writing) on the screen is at this time hooked up to history, so\nits not possible to undo and redo color attributes.";
    			t31 = space();
    			h5 = element("h5");
    			h5.textContent = "Tools";
    			t33 = space();
    			div0 = element("div");
    			create_component(toolbutton0.$$.fragment);
    			t34 = space();
    			p3 = element("p");
    			strong6 = element("strong");
    			strong6.textContent = "Default pointer(V):";
    			t36 = text(" Does not currently have any functionality");
    			t37 = space();
    			div1 = element("div");
    			create_component(toolbutton1.$$.fragment);
    			t38 = space();
    			p4 = element("p");
    			strong7 = element("strong");
    			strong7.textContent = "Eyedropper(E):";
    			t40 = text(" Get the current color value from pixel");
    			t41 = space();
    			div2 = element("div");
    			create_component(toolbutton2.$$.fragment);
    			t42 = space();
    			p5 = element("p");
    			strong8 = element("strong");
    			strong8.textContent = "Pen(B):";
    			t44 = text(" Pixel brush\n    ");
    			br0 = element("br");
    			em0 = element("em");
    			strong9 = element("strong");
    			strong9.textContent = "shift:";
    			t46 = text(" fills a straight line from previous point");
    			t47 = space();
    			br1 = element("br");
    			em1 = element("em");
    			strong10 = element("strong");
    			strong10.textContent = "alt:";
    			t49 = text(" hotswap to eyedropper");
    			t50 = space();
    			div3 = element("div");
    			create_component(toolbutton3.$$.fragment);
    			t51 = space();
    			p6 = element("p");
    			strong11 = element("strong");
    			strong11.textContent = "Circle(C):";
    			t53 = text(" Ellipse/circle tool\n    ");
    			br2 = element("br");
    			em2 = element("em");
    			strong12 = element("strong");
    			strong12.textContent = "shift:";
    			t55 = text(" forced circular");
    			t56 = space();
    			br3 = element("br");
    			em3 = element("em");
    			strong13 = element("strong");
    			strong13.textContent = "alt:";
    			t58 = text(" hotswap to eyedropper");
    			t59 = space();
    			div4 = element("div");
    			create_component(toolbutton4.$$.fragment);
    			t60 = space();
    			p7 = element("p");
    			strong14 = element("strong");
    			strong14.textContent = "Line(L):";
    			t62 = text(" Line tool\n    ");
    			br4 = element("br");
    			em4 = element("em");
    			strong15 = element("strong");
    			strong15.textContent = "alt:";
    			t64 = text(" hotswap to eyedropper");
    			t65 = space();
    			div5 = element("div");
    			create_component(toolbutton5.$$.fragment);
    			t66 = space();
    			p8 = element("p");
    			strong16 = element("strong");
    			strong16.textContent = "Paintbucket(G):";
    			t68 = text(" Fill a colored area with a different color\n    ");
    			br5 = element("br");
    			em5 = element("em");
    			strong17 = element("strong");
    			strong17.textContent = "alt:";
    			t70 = text(" hotswap to eyedropper");
    			t71 = space();
    			br6 = element("br");
    			em6 = element("em");
    			strong18 = element("strong");
    			strong18.textContent = "shift:";
    			t73 = text(" fill all pixels on the canvas with the new color");
    			t74 = space();
    			br7 = element("br");
    			em7 = element("em");
    			strong19 = element("strong");
    			strong19.textContent = "ctrl:";
    			t76 = text(" fill pixels inside that 8x8 tile");
    			t77 = space();
    			br8 = element("br");
    			em8 = element("em");
    			strong20 = element("strong");
    			strong20.textContent = "shift + ctrl:";
    			t79 = text(" fill all pixels inside that 8x8 tile");
    			t80 = space();
    			br9 = element("br");
    			em9 = element("em");
    			strong21 = element("strong");
    			strong21.textContent = "shift + ctrl + alt:";
    			t82 = text(" Fill all non 0(background) pixels with 0 value. In other words a flood fill remove");
    			t83 = space();
    			div6 = element("div");
    			create_component(toolbutton6.$$.fragment);
    			t84 = space();
    			p9 = element("p");
    			strong22 = element("strong");
    			strong22.textContent = "Pattern brush(D):";
    			t86 = text(" Select an area to create a custom brush to paint with\n    ");
    			br10 = element("br");
    			em10 = element("em");
    			strong23 = element("strong");
    			strong23.textContent = "shift:";
    			t88 = text(" conform to the size of the selected area(a caveat that it does not start from the current position currently but will be fixed)");
    			t89 = space();
    			br11 = element("br");
    			em11 = element("em");
    			strong24 = element("strong");
    			strong24.textContent = "alt:";
    			t91 = text(" drag to select an area");
    			t92 = space();
    			div7 = element("div");
    			create_component(toolbutton7.$$.fragment);
    			t93 = space();
    			p10 = element("p");
    			strong25 = element("strong");
    			strong25.textContent = "Color attribute(A):";
    			t95 = text(" Apply a color attribute per 8x8 tile. So it does not conform with the nes 16x16 attribute table, by design.\n    Name and attribute tables is/will be handled separate in a different tilemap section.");
    			t96 = space();
    			div8 = element("div");
    			create_component(toolbutton8.$$.fragment);
    			t97 = space();
    			p11 = element("p");
    			strong26 = element("strong");
    			strong26.textContent = "Color swap(S):";
    			t99 = text(" Swap between two colors on the canvas.\n    ");
    			br12 = element("br");
    			em12 = element("em");
    			strong27 = element("strong");
    			strong27.textContent = "alt:";
    			t101 = text(" swap colors within that 8x8 tile");
    			t102 = space();
    			div9 = element("div");
    			create_component(toolbutton9.$$.fragment);
    			t103 = space();
    			p12 = element("p");
    			strong28 = element("strong");
    			strong28.textContent = "Transpose(T):";
    			t105 = text(" Select an area and place it somewhere else\n    ");
    			br13 = element("br");
    			em13 = element("em");
    			strong29 = element("strong");
    			strong29.textContent = "ctrl:";
    			t107 = text(" copy selected area");
    			t108 = space();
    			br14 = element("br");
    			em14 = element("em");
    			strong30 = element("strong");
    			strong30.textContent = "alt:";
    			t110 = text(" move and replace");
    			t111 = space();
    			div10 = element("div");
    			create_component(toolbutton10.$$.fragment);
    			t112 = space();
    			p13 = element("p");
    			strong31 = element("strong");
    			strong31.textContent = "Transform(R):";
    			t114 = text(" Change orientation(rotate) of a tile\n    ");
    			br15 = element("br");
    			em15 = element("em");
    			strong32 = element("strong");
    			strong32.textContent = "ctrl:";
    			t116 = text(" flipX");
    			t117 = space();
    			br16 = element("br");
    			em16 = element("em");
    			strong33 = element("strong");
    			strong33.textContent = "alt:";
    			t119 = text(" flipY");
    			t120 = space();
    			div11 = element("div");
    			create_component(toolbutton11.$$.fragment);
    			t121 = space();
    			p14 = element("p");
    			strong34 = element("strong");
    			strong34.textContent = "Pattern preview(P)";
    			t123 = text(" Repeatedly preview a selected area on the canvas.\n    ");
    			br17 = element("br");
    			em17 = element("em");
    			strong35 = element("strong");
    			strong35.textContent = "doubleclick(icon):";
    			t125 = text(" create a preview of the whole canvas");
    			t126 = space();
    			div12 = element("div");
    			create_component(toolbutton12.$$.fragment);
    			t127 = space();
    			p15 = element("p");
    			strong36 = element("strong");
    			strong36.textContent = "Zoom(Z):";
    			t129 = text(" Zoom the canvas\n    ");
    			br18 = element("br");
    			em18 = element("em");
    			strong37 = element("strong");
    			strong37.textContent = "doubleclick(icon):";
    			t131 = text(" reset zoom");
    			add_location(h20, file$c, 54, 0, 1762);
    			add_location(p0, file$c, 55, 0, 1779);
    			add_location(h40, file$c, 56, 0, 1956);
    			add_location(strong0, file$c, 58, 4, 1991);
    			add_location(li0, file$c, 58, 0, 1987);
    			add_location(strong1, file$c, 59, 4, 2039);
    			add_location(li1, file$c, 59, 0, 2035);
    			add_location(strong2, file$c, 60, 4, 2095);
    			add_location(li2, file$c, 60, 0, 2091);
    			add_location(strong3, file$c, 61, 4, 2149);
    			add_location(li3, file$c, 61, 0, 2145);
    			add_location(ul0, file$c, 57, 0, 1982);
    			add_location(h41, file$c, 63, 0, 2200);
    			add_location(strong4, file$c, 65, 4, 2240);
    			add_location(li4, file$c, 65, 0, 2236);
    			add_location(strong5, file$c, 66, 4, 2293);
    			add_location(li5, file$c, 66, 0, 2289);
    			add_location(ul1, file$c, 64, 0, 2231);
    			add_location(h21, file$c, 68, 0, 2384);
    			add_location(p1, file$c, 69, 0, 2405);
    			add_location(p2, file$c, 70, 0, 2464);
    			add_location(h5, file$c, 72, 0, 2688);
    			add_location(strong6, file$c, 80, 4, 2911);
    			attr_dev(p3, "class", "svelte-1p2t3ya");
    			add_location(p3, file$c, 79, 2, 2903);
    			attr_dev(div0, "class", "tool svelte-1p2t3ya");
    			add_location(div0, file$c, 73, 0, 2703);
    			add_location(strong7, file$c, 90, 4, 3215);
    			attr_dev(p4, "class", "svelte-1p2t3ya");
    			add_location(p4, file$c, 89, 2, 3207);
    			attr_dev(div1, "class", "tool svelte-1p2t3ya");
    			add_location(div1, file$c, 83, 0, 3004);
    			add_location(strong8, file$c, 100, 4, 3505);
    			add_location(br0, file$c, 101, 4, 3546);
    			add_location(strong9, file$c, 101, 12, 3554);
    			add_location(em0, file$c, 101, 8, 3550);
    			add_location(br1, file$c, 102, 4, 3629);
    			add_location(strong10, file$c, 102, 12, 3637);
    			add_location(em1, file$c, 102, 8, 3633);
    			attr_dev(p5, "class", "svelte-1p2t3ya");
    			add_location(p5, file$c, 99, 2, 3497);
    			attr_dev(div2, "class", "tool svelte-1p2t3ya");
    			add_location(div2, file$c, 93, 0, 3301);
    			add_location(strong11, file$c, 112, 4, 3907);
    			add_location(br2, file$c, 113, 4, 3959);
    			add_location(strong12, file$c, 113, 12, 3967);
    			add_location(em2, file$c, 113, 8, 3963);
    			add_location(br3, file$c, 114, 4, 4016);
    			add_location(strong13, file$c, 114, 12, 4024);
    			add_location(em3, file$c, 114, 8, 4020);
    			attr_dev(p6, "class", "svelte-1p2t3ya");
    			add_location(p6, file$c, 111, 2, 3899);
    			attr_dev(div3, "class", "tool svelte-1p2t3ya");
    			add_location(div3, file$c, 105, 0, 3700);
    			add_location(strong14, file$c, 124, 4, 4292);
    			add_location(br4, file$c, 125, 4, 4332);
    			add_location(strong15, file$c, 125, 12, 4340);
    			add_location(em4, file$c, 125, 8, 4336);
    			attr_dev(p7, "class", "svelte-1p2t3ya");
    			add_location(p7, file$c, 123, 2, 4284);
    			attr_dev(div4, "class", "tool svelte-1p2t3ya");
    			add_location(div4, file$c, 117, 0, 4087);
    			add_location(strong16, file$c, 135, 4, 4615);
    			add_location(br5, file$c, 136, 4, 4695);
    			add_location(strong17, file$c, 136, 12, 4703);
    			add_location(em5, file$c, 136, 8, 4699);
    			add_location(br6, file$c, 137, 4, 4756);
    			add_location(strong18, file$c, 137, 12, 4764);
    			add_location(em6, file$c, 137, 8, 4760);
    			add_location(br7, file$c, 138, 4, 4846);
    			add_location(strong19, file$c, 138, 12, 4854);
    			add_location(em7, file$c, 138, 8, 4850);
    			add_location(br8, file$c, 139, 4, 4919);
    			add_location(strong20, file$c, 139, 12, 4927);
    			add_location(em8, file$c, 139, 8, 4923);
    			add_location(br9, file$c, 140, 4, 5004);
    			add_location(strong21, file$c, 140, 12, 5012);
    			add_location(em9, file$c, 140, 8, 5008);
    			attr_dev(p8, "class", "svelte-1p2t3ya");
    			add_location(p8, file$c, 134, 2, 4607);
    			attr_dev(div5, "class", "tool svelte-1p2t3ya");
    			add_location(div5, file$c, 128, 0, 4403);
    			add_location(strong22, file$c, 150, 4, 5357);
    			add_location(br10, file$c, 151, 4, 5450);
    			add_location(strong23, file$c, 151, 12, 5458);
    			add_location(em10, file$c, 151, 8, 5454);
    			add_location(br11, file$c, 152, 4, 5619);
    			add_location(strong24, file$c, 152, 12, 5627);
    			add_location(em11, file$c, 152, 8, 5623);
    			attr_dev(p9, "class", "svelte-1p2t3ya");
    			add_location(p9, file$c, 149, 2, 5349);
    			attr_dev(div6, "class", "tool svelte-1p2t3ya");
    			add_location(div6, file$c, 143, 0, 5151);
    			add_location(strong25, file$c, 162, 4, 5906);
    			attr_dev(p10, "class", "svelte-1p2t3ya");
    			add_location(p10, file$c, 161, 2, 5898);
    			attr_dev(div7, "class", "tool svelte-1p2t3ya");
    			add_location(div7, file$c, 155, 0, 5691);
    			add_location(strong26, file$c, 173, 4, 6370);
    			add_location(br12, file$c, 174, 4, 6445);
    			add_location(strong27, file$c, 174, 12, 6453);
    			add_location(em12, file$c, 174, 8, 6449);
    			attr_dev(p11, "class", "svelte-1p2t3ya");
    			add_location(p11, file$c, 172, 2, 6362);
    			attr_dev(div8, "class", "tool svelte-1p2t3ya");
    			add_location(div8, file$c, 166, 0, 6160);
    			add_location(strong28, file$c, 184, 4, 6737);
    			add_location(br13, file$c, 185, 4, 6815);
    			add_location(strong29, file$c, 185, 12, 6823);
    			add_location(em13, file$c, 185, 8, 6819);
    			add_location(br14, file$c, 186, 4, 6874);
    			add_location(strong30, file$c, 186, 12, 6882);
    			add_location(em14, file$c, 186, 8, 6878);
    			attr_dev(p12, "class", "svelte-1p2t3ya");
    			add_location(p12, file$c, 183, 2, 6729);
    			attr_dev(div9, "class", "tool svelte-1p2t3ya");
    			add_location(div9, file$c, 177, 0, 6527);
    			add_location(strong31, file$c, 196, 4, 7150);
    			add_location(br15, file$c, 197, 4, 7222);
    			add_location(strong32, file$c, 197, 12, 7230);
    			add_location(em15, file$c, 197, 8, 7226);
    			add_location(br16, file$c, 198, 4, 7268);
    			add_location(strong33, file$c, 198, 12, 7276);
    			add_location(em16, file$c, 198, 8, 7272);
    			attr_dev(p13, "class", "svelte-1p2t3ya");
    			add_location(p13, file$c, 195, 2, 7142);
    			attr_dev(div10, "class", "tool svelte-1p2t3ya");
    			add_location(div10, file$c, 189, 0, 6940);
    			add_location(strong34, file$c, 208, 4, 7538);
    			add_location(br17, file$c, 209, 4, 7628);
    			add_location(strong35, file$c, 209, 12, 7636);
    			add_location(em17, file$c, 209, 8, 7632);
    			attr_dev(p14, "class", "svelte-1p2t3ya");
    			add_location(p14, file$c, 207, 2, 7530);
    			attr_dev(div11, "class", "tool svelte-1p2t3ya");
    			add_location(div11, file$c, 201, 0, 7323);
    			add_location(strong36, file$c, 219, 4, 7933);
    			add_location(br18, file$c, 220, 4, 7979);
    			add_location(strong37, file$c, 220, 12, 7987);
    			add_location(em18, file$c, 220, 8, 7983);
    			attr_dev(p15, "class", "svelte-1p2t3ya");
    			add_location(p15, file$c, 218, 2, 7925);
    			attr_dev(div12, "class", "tool svelte-1p2t3ya");
    			add_location(div12, file$c, 212, 0, 7728);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, h40, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, ul0, anchor);
    			append_dev(ul0, li0);
    			append_dev(li0, strong0);
    			append_dev(li0, t7);
    			append_dev(ul0, t8);
    			append_dev(ul0, li1);
    			append_dev(li1, strong1);
    			append_dev(li1, t10);
    			append_dev(ul0, t11);
    			append_dev(ul0, li2);
    			append_dev(li2, strong2);
    			append_dev(li2, t13);
    			append_dev(ul0, t14);
    			append_dev(ul0, li3);
    			append_dev(li3, strong3);
    			append_dev(li3, t16);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, h41, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, ul1, anchor);
    			append_dev(ul1, li4);
    			append_dev(li4, strong4);
    			append_dev(li4, t21);
    			append_dev(ul1, t22);
    			append_dev(ul1, li5);
    			append_dev(li5, strong5);
    			append_dev(li5, t24);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t27, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t29, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t31, anchor);
    			insert_dev(target, h5, anchor);
    			insert_dev(target, t33, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(toolbutton0, div0, null);
    			append_dev(div0, t34);
    			append_dev(div0, p3);
    			append_dev(p3, strong6);
    			append_dev(p3, t36);
    			insert_dev(target, t37, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(toolbutton1, div1, null);
    			append_dev(div1, t38);
    			append_dev(div1, p4);
    			append_dev(p4, strong7);
    			append_dev(p4, t40);
    			insert_dev(target, t41, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(toolbutton2, div2, null);
    			append_dev(div2, t42);
    			append_dev(div2, p5);
    			append_dev(p5, strong8);
    			append_dev(p5, t44);
    			append_dev(p5, br0);
    			append_dev(p5, em0);
    			append_dev(em0, strong9);
    			append_dev(em0, t46);
    			append_dev(p5, t47);
    			append_dev(p5, br1);
    			append_dev(p5, em1);
    			append_dev(em1, strong10);
    			append_dev(em1, t49);
    			insert_dev(target, t50, anchor);
    			insert_dev(target, div3, anchor);
    			mount_component(toolbutton3, div3, null);
    			append_dev(div3, t51);
    			append_dev(div3, p6);
    			append_dev(p6, strong11);
    			append_dev(p6, t53);
    			append_dev(p6, br2);
    			append_dev(p6, em2);
    			append_dev(em2, strong12);
    			append_dev(em2, t55);
    			append_dev(p6, t56);
    			append_dev(p6, br3);
    			append_dev(p6, em3);
    			append_dev(em3, strong13);
    			append_dev(em3, t58);
    			insert_dev(target, t59, anchor);
    			insert_dev(target, div4, anchor);
    			mount_component(toolbutton4, div4, null);
    			append_dev(div4, t60);
    			append_dev(div4, p7);
    			append_dev(p7, strong14);
    			append_dev(p7, t62);
    			append_dev(p7, br4);
    			append_dev(p7, em4);
    			append_dev(em4, strong15);
    			append_dev(em4, t64);
    			insert_dev(target, t65, anchor);
    			insert_dev(target, div5, anchor);
    			mount_component(toolbutton5, div5, null);
    			append_dev(div5, t66);
    			append_dev(div5, p8);
    			append_dev(p8, strong16);
    			append_dev(p8, t68);
    			append_dev(p8, br5);
    			append_dev(p8, em5);
    			append_dev(em5, strong17);
    			append_dev(em5, t70);
    			append_dev(p8, t71);
    			append_dev(p8, br6);
    			append_dev(p8, em6);
    			append_dev(em6, strong18);
    			append_dev(em6, t73);
    			append_dev(p8, t74);
    			append_dev(p8, br7);
    			append_dev(p8, em7);
    			append_dev(em7, strong19);
    			append_dev(em7, t76);
    			append_dev(p8, t77);
    			append_dev(p8, br8);
    			append_dev(p8, em8);
    			append_dev(em8, strong20);
    			append_dev(em8, t79);
    			append_dev(p8, t80);
    			append_dev(p8, br9);
    			append_dev(p8, em9);
    			append_dev(em9, strong21);
    			append_dev(em9, t82);
    			insert_dev(target, t83, anchor);
    			insert_dev(target, div6, anchor);
    			mount_component(toolbutton6, div6, null);
    			append_dev(div6, t84);
    			append_dev(div6, p9);
    			append_dev(p9, strong22);
    			append_dev(p9, t86);
    			append_dev(p9, br10);
    			append_dev(p9, em10);
    			append_dev(em10, strong23);
    			append_dev(em10, t88);
    			append_dev(p9, t89);
    			append_dev(p9, br11);
    			append_dev(p9, em11);
    			append_dev(em11, strong24);
    			append_dev(em11, t91);
    			insert_dev(target, t92, anchor);
    			insert_dev(target, div7, anchor);
    			mount_component(toolbutton7, div7, null);
    			append_dev(div7, t93);
    			append_dev(div7, p10);
    			append_dev(p10, strong25);
    			append_dev(p10, t95);
    			insert_dev(target, t96, anchor);
    			insert_dev(target, div8, anchor);
    			mount_component(toolbutton8, div8, null);
    			append_dev(div8, t97);
    			append_dev(div8, p11);
    			append_dev(p11, strong26);
    			append_dev(p11, t99);
    			append_dev(p11, br12);
    			append_dev(p11, em12);
    			append_dev(em12, strong27);
    			append_dev(em12, t101);
    			insert_dev(target, t102, anchor);
    			insert_dev(target, div9, anchor);
    			mount_component(toolbutton9, div9, null);
    			append_dev(div9, t103);
    			append_dev(div9, p12);
    			append_dev(p12, strong28);
    			append_dev(p12, t105);
    			append_dev(p12, br13);
    			append_dev(p12, em13);
    			append_dev(em13, strong29);
    			append_dev(em13, t107);
    			append_dev(p12, t108);
    			append_dev(p12, br14);
    			append_dev(p12, em14);
    			append_dev(em14, strong30);
    			append_dev(em14, t110);
    			insert_dev(target, t111, anchor);
    			insert_dev(target, div10, anchor);
    			mount_component(toolbutton10, div10, null);
    			append_dev(div10, t112);
    			append_dev(div10, p13);
    			append_dev(p13, strong31);
    			append_dev(p13, t114);
    			append_dev(p13, br15);
    			append_dev(p13, em15);
    			append_dev(em15, strong32);
    			append_dev(em15, t116);
    			append_dev(p13, t117);
    			append_dev(p13, br16);
    			append_dev(p13, em16);
    			append_dev(em16, strong33);
    			append_dev(em16, t119);
    			insert_dev(target, t120, anchor);
    			insert_dev(target, div11, anchor);
    			mount_component(toolbutton11, div11, null);
    			append_dev(div11, t121);
    			append_dev(div11, p14);
    			append_dev(p14, strong34);
    			append_dev(p14, t123);
    			append_dev(p14, br17);
    			append_dev(p14, em17);
    			append_dev(em17, strong35);
    			append_dev(em17, t125);
    			insert_dev(target, t126, anchor);
    			insert_dev(target, div12, anchor);
    			mount_component(toolbutton12, div12, null);
    			append_dev(div12, t127);
    			append_dev(div12, p15);
    			append_dev(p15, strong36);
    			append_dev(p15, t129);
    			append_dev(p15, br18);
    			append_dev(p15, em18);
    			append_dev(em18, strong37);
    			append_dev(em18, t131);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const toolbutton0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton0_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton0.$set(toolbutton0_changes);
    			const toolbutton1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton1_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton1.$set(toolbutton1_changes);
    			const toolbutton2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton2_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton2.$set(toolbutton2_changes);
    			const toolbutton3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton3_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton3.$set(toolbutton3_changes);
    			const toolbutton4_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton4_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton4.$set(toolbutton4_changes);
    			const toolbutton5_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton5_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton5.$set(toolbutton5_changes);
    			const toolbutton6_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton6_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton6.$set(toolbutton6_changes);
    			const toolbutton7_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton7_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton7.$set(toolbutton7_changes);
    			const toolbutton8_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton8_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton8.$set(toolbutton8_changes);
    			const toolbutton9_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton9_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton9.$set(toolbutton9_changes);
    			const toolbutton10_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton10_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton10.$set(toolbutton10_changes);
    			const toolbutton11_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton11_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton11.$set(toolbutton11_changes);
    			const toolbutton12_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				toolbutton12_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton12.$set(toolbutton12_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toolbutton0.$$.fragment, local);
    			transition_in(toolbutton1.$$.fragment, local);
    			transition_in(toolbutton2.$$.fragment, local);
    			transition_in(toolbutton3.$$.fragment, local);
    			transition_in(toolbutton4.$$.fragment, local);
    			transition_in(toolbutton5.$$.fragment, local);
    			transition_in(toolbutton6.$$.fragment, local);
    			transition_in(toolbutton7.$$.fragment, local);
    			transition_in(toolbutton8.$$.fragment, local);
    			transition_in(toolbutton9.$$.fragment, local);
    			transition_in(toolbutton10.$$.fragment, local);
    			transition_in(toolbutton11.$$.fragment, local);
    			transition_in(toolbutton12.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toolbutton0.$$.fragment, local);
    			transition_out(toolbutton1.$$.fragment, local);
    			transition_out(toolbutton2.$$.fragment, local);
    			transition_out(toolbutton3.$$.fragment, local);
    			transition_out(toolbutton4.$$.fragment, local);
    			transition_out(toolbutton5.$$.fragment, local);
    			transition_out(toolbutton6.$$.fragment, local);
    			transition_out(toolbutton7.$$.fragment, local);
    			transition_out(toolbutton8.$$.fragment, local);
    			transition_out(toolbutton9.$$.fragment, local);
    			transition_out(toolbutton10.$$.fragment, local);
    			transition_out(toolbutton11.$$.fragment, local);
    			transition_out(toolbutton12.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h40);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(ul0);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(h41);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(ul1);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t27);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t31);
    			if (detaching) detach_dev(h5);
    			if (detaching) detach_dev(t33);
    			if (detaching) detach_dev(div0);
    			destroy_component(toolbutton0);
    			if (detaching) detach_dev(t37);
    			if (detaching) detach_dev(div1);
    			destroy_component(toolbutton1);
    			if (detaching) detach_dev(t41);
    			if (detaching) detach_dev(div2);
    			destroy_component(toolbutton2);
    			if (detaching) detach_dev(t50);
    			if (detaching) detach_dev(div3);
    			destroy_component(toolbutton3);
    			if (detaching) detach_dev(t59);
    			if (detaching) detach_dev(div4);
    			destroy_component(toolbutton4);
    			if (detaching) detach_dev(t65);
    			if (detaching) detach_dev(div5);
    			destroy_component(toolbutton5);
    			if (detaching) detach_dev(t83);
    			if (detaching) detach_dev(div6);
    			destroy_component(toolbutton6);
    			if (detaching) detach_dev(t92);
    			if (detaching) detach_dev(div7);
    			destroy_component(toolbutton7);
    			if (detaching) detach_dev(t96);
    			if (detaching) detach_dev(div8);
    			destroy_component(toolbutton8);
    			if (detaching) detach_dev(t102);
    			if (detaching) detach_dev(div9);
    			destroy_component(toolbutton9);
    			if (detaching) detach_dev(t111);
    			if (detaching) detach_dev(div10);
    			destroy_component(toolbutton10);
    			if (detaching) detach_dev(t120);
    			if (detaching) detach_dev(div11);
    			destroy_component(toolbutton11);
    			if (detaching) detach_dev(t126);
    			if (detaching) detach_dev(div12);
    			destroy_component(toolbutton12);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Spritesheets", slots, []);

    	const tools = {
    		Pointer: new Pointer(false),
    		Eyedropper: new Eyedropper(false),
    		Circle: new Circle(false),
    		Line: new Line(false),
    		Pen: new Pen(false),
    		Paintbucket: new Paintbucket(false),
    		Brush: new Brush(false),
    		Colorattribute: new ColorAttribute$1(false),
    		Colorswap: new Colorswap(false),
    		Transpose: new Tileswap(false),
    		Transform: new Transform(false),
    		Patternpreview: new Preview(false),
    		Zoom: new Zoom(false)
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spritesheets> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		ToolButton,
    		Pointer,
    		Eyedropper,
    		Pen,
    		Circle,
    		Line,
    		Paintbucket,
    		Brush,
    		Colorattribute: ColorAttribute$1,
    		Colorswap,
    		Transpose: Tileswap,
    		Transform,
    		Patternpreview: Preview,
    		Zoom,
    		tools
    	});

    	return [tools];
    }

    class Spritesheets$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spritesheets",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src\_views\documentation\Roadmap.md generated by Svelte v3.31.2 */

    const file$d = "src\\_views\\documentation\\Roadmap.md";

    function create_fragment$g(ctx) {
    	let h2;
    	let t1;
    	let p;
    	let t3;
    	let h40;
    	let t5;
    	let ul0;
    	let li0;
    	let t7;
    	let li1;
    	let t9;
    	let h41;
    	let t11;
    	let ul1;
    	let li2;
    	let t13;
    	let h42;
    	let t15;
    	let ul2;
    	let li3;
    	let t17;
    	let h43;
    	let t19;
    	let ul3;
    	let li4;
    	let t21;
    	let h44;
    	let t23;
    	let ul4;
    	let li5;
    	let t25;
    	let li6;
    	let t27;
    	let li7;
    	let t29;
    	let li8;
    	let t31;
    	let li9;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Roadmap";
    			t1 = space();
    			p = element("p");
    			p.textContent = "Whats planned or potential future implementations.";
    			t3 = space();
    			h40 = element("h4");
    			h40.textContent = "Project";
    			t5 = space();
    			ul0 = element("ul");
    			li0 = element("li");
    			li0.textContent = "Import selected parts(spritesheet/palettes/fonts) from a project file for the current project";
    			t7 = space();
    			li1 = element("li");
    			li1.textContent = "In browser project management and not have to download a new file every time a project is saved";
    			t9 = space();
    			h41 = element("h4");
    			h41.textContent = "Palettes";
    			t11 = space();
    			ul1 = element("ul");
    			li2 = element("li");
    			li2.textContent = "Create custom palette groups to easily toggle between color combinations";
    			t13 = space();
    			h42 = element("h4");
    			h42.textContent = "Sprites";
    			t15 = space();
    			ul2 = element("ul");
    			li3 = element("li");
    			li3.textContent = "Ability to create sprites/metasprites";
    			t17 = space();
    			h43 = element("h4");
    			h43.textContent = "Tilemaps";
    			t19 = space();
    			ul3 = element("ul");
    			li4 = element("li");
    			li4.textContent = "Tilemap editor with name and attributes table export";
    			t21 = space();
    			h44 = element("h4");
    			h44.textContent = "Spritesheets";
    			t23 = space();
    			ul4 = element("ul");
    			li5 = element("li");
    			li5.textContent = "select area to apply color attribute information to apply on larger blocks and removing larger blocks";
    			t25 = space();
    			li6 = element("li");
    			li6.textContent = "Work out transform origin when zooming canvas. Current behaviour is always centered and it feels clunky when its offset from its initial position";
    			t27 = space();
    			li7 = element("li");
    			li7.textContent = "Text tool and custom font creation. Create custom font from tiles mapped to input/keyboard characters. (saved standalone in the project, not relying on a spritesheet once created)";
    			t29 = space();
    			li8 = element("li");
    			li8.textContent = "Marquee/selection tool to select and modify selected area";
    			t31 = space();
    			li9 = element("li");
    			li9.textContent = "Attach custom sprites as overlay over spritesheets for mocking screens to get a feel of the finished product";
    			add_location(h2, file$d, 1, 0, 1);
    			add_location(p, file$d, 2, 0, 18);
    			add_location(h40, file$d, 3, 0, 77);
    			add_location(li0, file$d, 5, 0, 99);
    			add_location(li1, file$d, 6, 0, 202);
    			add_location(ul0, file$d, 4, 0, 94);
    			add_location(h41, file$d, 8, 0, 313);
    			add_location(li2, file$d, 10, 0, 336);
    			add_location(ul1, file$d, 9, 0, 331);
    			add_location(h42, file$d, 12, 0, 425);
    			add_location(li3, file$d, 14, 0, 447);
    			add_location(ul2, file$d, 13, 0, 442);
    			add_location(h43, file$d, 16, 0, 500);
    			add_location(li4, file$d, 18, 0, 523);
    			add_location(ul3, file$d, 17, 0, 518);
    			add_location(h44, file$d, 20, 0, 591);
    			add_location(li5, file$d, 22, 0, 618);
    			add_location(li6, file$d, 23, 0, 729);
    			add_location(li7, file$d, 24, 0, 886);
    			add_location(li8, file$d, 25, 0, 1078);
    			add_location(li9, file$d, 26, 0, 1145);
    			add_location(ul4, file$d, 21, 0, 613);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, h40, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, ul0, anchor);
    			append_dev(ul0, li0);
    			append_dev(ul0, t7);
    			append_dev(ul0, li1);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h41, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, ul1, anchor);
    			append_dev(ul1, li2);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, h42, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, ul2, anchor);
    			append_dev(ul2, li3);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, h43, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, ul3, anchor);
    			append_dev(ul3, li4);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, h44, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, ul4, anchor);
    			append_dev(ul4, li5);
    			append_dev(ul4, t25);
    			append_dev(ul4, li6);
    			append_dev(ul4, t27);
    			append_dev(ul4, li7);
    			append_dev(ul4, t29);
    			append_dev(ul4, li8);
    			append_dev(ul4, t31);
    			append_dev(ul4, li9);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h40);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(ul0);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h41);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(ul1);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(h42);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(ul2);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(h43);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(ul3);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(h44);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(ul4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Roadmap", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Roadmap> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Roadmap extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Roadmap",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    // sections 
    const documentation = decorator(Documentation);

    // catch all /gfx/:section subroutes
    documentation('/documentation', (req, res) => {
      // send the component to the view
      try{
        res.send(Spritesheets$1);
      }catch(error){
        res.error();
      }
    });

    documentation('/documentation/roadmap', (req, res) => {
      // send the component to the view
      try{
        res.send(Roadmap);
      }catch(error){
        res.error();
      }
    });

    /* src\_components\graphics\SectionNavigation.svelte generated by Svelte v3.31.2 */
    const file$e = "src\\_components\\graphics\\SectionNavigation.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (22:2) {#each list as prop}
    function create_each_block$3(ctx) {
    	let li;
    	let button;
    	let t0_value = /*prop*/ ctx[2].label + "";
    	let t0;
    	let button_href_value;
    	let button_label_value;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "href", button_href_value = /*prop*/ ctx[2].href);
    			attr_dev(button, "label", button_label_value = /*prop*/ ctx[2].label);
    			attr_dev(button, "class", "svelte-1p6gkk9");
    			add_location(button, file$e, 23, 6, 680);
    			attr_dev(li, "class", "no-drag");
    			toggle_class(li, "active", /*prop*/ ctx[2].href == /*$location*/ ctx[1]);
    			add_location(li, file$e, 22, 4, 614);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, button));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list*/ 1 && t0_value !== (t0_value = /*prop*/ ctx[2].label + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*list*/ 1 && button_href_value !== (button_href_value = /*prop*/ ctx[2].href)) {
    				attr_dev(button, "href", button_href_value);
    			}

    			if (dirty & /*list*/ 1 && button_label_value !== (button_label_value = /*prop*/ ctx[2].label)) {
    				attr_dev(button, "label", button_label_value);
    			}

    			if (dirty & /*list, $location*/ 3) {
    				toggle_class(li, "active", /*prop*/ ctx[2].href == /*$location*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(22:2) {#each list as prop}",
    		ctx
    	});

    	return block;
    }

    // (21:0) <Tabmenu>
    function create_default_slot$4(ctx) {
    	let each_1_anchor;
    	let each_value = /*list*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list, $location*/ 3) {
    				each_value = /*list*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(21:0) <Tabmenu>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let tabmenu;
    	let current;

    	tabmenu = new Tabmenu({
    			props: {
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabmenu.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabmenu_changes = {};

    			if (dirty & /*$$scope, list, $location*/ 35) {
    				tabmenu_changes.$$scope = { dirty, ctx };
    			}

    			tabmenu.$set(tabmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $location;
    	validate_store(location$1, "location");
    	component_subscribe($$self, location$1, $$value => $$invalidate(1, $location = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SectionNavigation", slots, []);

    	let list = [
    		{
    			href: "/graphics/palettes",
    			label: "Palettes"
    		},
    		{
    			href: "/graphics/spritesheets",
    			label: "Spritesheets"
    		}
    	];

    	if (application.isDev) {
    		list = [
    			...list,
    			{
    				href: "/graphics/spritesets",
    				label: "Sprites"
    			},
    			{
    				href: "/graphics/metatiles",
    				label: "Metatiles"
    			},
    			{
    				href: "/graphics/tilemaps",
    				label: "Tilemaps"
    			}
    		];
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SectionNavigation> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		application,
    		link,
    		location: location$1,
    		Tabmenu,
    		list,
    		$location
    	});

    	$$self.$inject_state = $$props => {
    		if ("list" in $$props) $$invalidate(0, list = $$props.list);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [list, $location];
    }

    class SectionNavigation$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SectionNavigation",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\_decorators\_Spritesheets.svelte generated by Svelte v3.31.2 */
    const file$f = "src\\_decorators\\_Spritesheets.svelte";

    function create_fragment$i(ctx) {
    	let section;
    	let div0;
    	let sectionnavigation;
    	let t;
    	let div1;
    	let current;
    	sectionnavigation = new SectionNavigation$1({ $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			create_component(sectionnavigation.$$.fragment);
    			t = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			add_location(div0, file$f, 5, 2, 138);
    			attr_dev(div1, "class", "main svelte-1eju9fl");
    			add_location(div1, file$f, 8, 2, 184);
    			attr_dev(section, "id", "spritesheets");
    			attr_dev(section, "class", "svelte-1eju9fl");
    			add_location(section, file$f, 4, 0, 107);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			mount_component(sectionnavigation, div0, null);
    			append_dev(section, t);
    			append_dev(section, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sectionnavigation.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sectionnavigation.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(sectionnavigation);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Spritesheets", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spritesheets> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ SectionNavigation: SectionNavigation$1 });
    	return [$$scope, slots];
    }

    class Spritesheets$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spritesheets",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src\_decorators\_Palettes.svelte generated by Svelte v3.31.2 */
    const file$g = "src\\_decorators\\_Palettes.svelte";

    function create_fragment$j(ctx) {
    	let section;
    	let div0;
    	let sectionnavigation;
    	let t;
    	let div1;
    	let current;
    	sectionnavigation = new SectionNavigation$1({ $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			create_component(sectionnavigation.$$.fragment);
    			t = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			add_location(div0, file$g, 5, 2, 134);
    			attr_dev(div1, "class", "main svelte-1husw0i");
    			add_location(div1, file$g, 8, 2, 180);
    			attr_dev(section, "id", "palettes");
    			attr_dev(section, "class", "svelte-1husw0i");
    			add_location(section, file$g, 4, 0, 107);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			mount_component(sectionnavigation, div0, null);
    			append_dev(section, t);
    			append_dev(section, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sectionnavigation.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sectionnavigation.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(sectionnavigation);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Palettes", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Palettes> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ SectionNavigation: SectionNavigation$1 });
    	return [$$scope, slots];
    }

    class Palettes$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Palettes",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src\_decorators\_Tilemaps.svelte generated by Svelte v3.31.2 */
    const file$h = "src\\_decorators\\_Tilemaps.svelte";

    function create_fragment$k(ctx) {
    	let section;
    	let div0;
    	let sectionnavigation;
    	let t;
    	let div1;
    	let current;
    	sectionnavigation = new SectionNavigation$1({ $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			create_component(sectionnavigation.$$.fragment);
    			t = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			add_location(div0, file$h, 5, 2, 138);
    			attr_dev(div1, "class", "main svelte-ju14kw");
    			add_location(div1, file$h, 8, 2, 184);
    			attr_dev(section, "id", "spritesheets");
    			attr_dev(section, "class", "svelte-ju14kw");
    			add_location(section, file$h, 4, 0, 107);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			mount_component(sectionnavigation, div0, null);
    			append_dev(section, t);
    			append_dev(section, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sectionnavigation.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sectionnavigation.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(sectionnavigation);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tilemaps", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tilemaps> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ SectionNavigation: SectionNavigation$1 });
    	return [$$scope, slots];
    }

    class Tilemaps$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tilemaps",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src\_singles\buttons\ColorSelectButton.svelte generated by Svelte v3.31.2 */

    const file$i = "src\\_singles\\buttons\\ColorSelectButton.svelte";

    function create_fragment$l(ctx) {
    	let button;
    	let div;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			div = element("div");
    			t = text("");
    			set_style(div, "--color", /*color*/ ctx[0]);
    			attr_dev(div, "class", "svelte-10hh6bt");
    			add_location(div, file$i, 6, 2, 140);
    			attr_dev(button, "class", "color-selector svelte-10hh6bt");
    			toggle_class(button, "selected", /*selected*/ ctx[1]);
    			add_location(button, file$i, 5, 0, 81);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, div);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 1) {
    				set_style(div, "--color", /*color*/ ctx[0]);
    			}

    			if (dirty & /*selected*/ 2) {
    				toggle_class(button, "selected", /*selected*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ColorSelectButton", slots, []);
    	let { color } = $$props;
    	let { selected = undefined } = $$props;
    	const writable_props = ["color", "selected"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ColorSelectButton> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("color" in $$props) $$invalidate(0, color = $$props.color);
    		if ("selected" in $$props) $$invalidate(1, selected = $$props.selected);
    	};

    	$$self.$capture_state = () => ({ color, selected });

    	$$self.$inject_state = $$props => {
    		if ("color" in $$props) $$invalidate(0, color = $$props.color);
    		if ("selected" in $$props) $$invalidate(1, selected = $$props.selected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [color, selected, click_handler];
    }

    class ColorSelectButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { color: 0, selected: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColorSelectButton",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*color*/ ctx[0] === undefined && !("color" in props)) {
    			console.warn("<ColorSelectButton> was created without expected prop 'color'");
    		}
    	}

    	get color() {
    		throw new Error("<ColorSelectButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ColorSelectButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<ColorSelectButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<ColorSelectButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_components\graphics\ColorSelection.svelte generated by Svelte v3.31.2 */
    const file$j = "src\\_components\\graphics\\ColorSelection.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (8:0) {#if $activeLayer}
    function create_if_block$3(ctx) {
    	let ul;
    	let current;
    	let each_value = /*$activeLayer*/ ctx[0].colors;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(ul, file$j, 8, 2, 309);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$activeLayer, $selectedColor, ActionsManager*/ 3) {
    				each_value = /*$activeLayer*/ ctx[0].colors;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(8:0) {#if $activeLayer}",
    		ctx
    	});

    	return block;
    }

    // (10:4) {#each $activeLayer.colors as color, i}
    function create_each_block$4(ctx) {
    	let li;
    	let colorselectbutton;
    	let t;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[4](/*i*/ ctx[7], ...args);
    	}

    	colorselectbutton = new ColorSelectButton({
    			props: {
    				color: /*color*/ ctx[5].rgb,
    				selected: /*$selectedColor*/ ctx[1] === /*i*/ ctx[7]
    			},
    			$$inline: true
    		});

    	colorselectbutton.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(colorselectbutton.$$.fragment);
    			t = space();
    			add_location(li, file$j, 10, 6, 366);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(colorselectbutton, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const colorselectbutton_changes = {};
    			if (dirty & /*$activeLayer*/ 1) colorselectbutton_changes.color = /*color*/ ctx[5].rgb;
    			if (dirty & /*$selectedColor*/ 2) colorselectbutton_changes.selected = /*$selectedColor*/ ctx[1] === /*i*/ ctx[7];
    			colorselectbutton.$set(colorselectbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(colorselectbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(colorselectbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(colorselectbutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(10:4) {#each $activeLayer.colors as color, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$activeLayer*/ ctx[0] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$activeLayer*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$activeLayer*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $activeLayer;
    	let $selectedColor;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ColorSelection", slots, []);
    	const { activeLayer, selectedColor } = Palettes.stores;
    	validate_store(activeLayer, "activeLayer");
    	component_subscribe($$self, activeLayer, value => $$invalidate(0, $activeLayer = value));
    	validate_store(selectedColor, "selectedColor");
    	component_subscribe($$self, selectedColor, value => $$invalidate(1, $selectedColor = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ColorSelection> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (i, _) => actions.execute("palette_active_color", i);

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		ColorSelectButton,
    		Palettes,
    		activeLayer,
    		selectedColor,
    		$activeLayer,
    		$selectedColor
    	});

    	return [$activeLayer, $selectedColor, activeLayer, selectedColor, click_handler];
    }

    class ColorSelection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColorSelection",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src\_components\graphics\ToolbarSelection.svelte generated by Svelte v3.31.2 */

    const { Object: Object_1 } = globals;
    const file$k = "src\\_components\\graphics\\ToolbarSelection.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (15:4) {#if tool.visible_in_toolbar}
    function create_if_block$4(ctx) {
    	let li;
    	let toolbutton;
    	let t;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[4](/*tool*/ ctx[6], ...args);
    	}

    	toolbutton = new ToolButton({
    			props: {
    				title: /*tool*/ ctx[6].title,
    				selected: /*$activeTool*/ ctx[0] === /*tool*/ ctx[6],
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbutton.$on("dblclick", /*dblclick_handler*/ ctx[3]);
    	toolbutton.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(toolbutton.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "svelte-1hv5cjm");
    			add_location(li, file$k, 15, 6, 484);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(toolbutton, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const toolbutton_changes = {};
    			if (dirty & /*$activeTool*/ 1) toolbutton_changes.selected = /*$activeTool*/ ctx[0] === /*tool*/ ctx[6];

    			if (dirty & /*$$scope*/ 512) {
    				toolbutton_changes.$$scope = { dirty, ctx };
    			}

    			toolbutton.$set(toolbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toolbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toolbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(toolbutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(15:4) {#if tool.visible_in_toolbar}",
    		ctx
    	});

    	return block;
    }

    // (17:8) <ToolButton title={tool.title} on:dblclick={_ => ActionsManager.execute('spritesheet_tool_dblclick')} on:click={_ => ActionsManager.execute('spritesheet_set_active_tool', tool.enum)} selected={$activeTool === tool}>
    function create_default_slot$5(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", /*tool*/ ctx[6].icon);
    			add_location(path, file$k, 17, 93, 808);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-1hv5cjm");
    			add_location(svg, file$k, 17, 10, 725);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(17:8) <ToolButton title={tool.title} on:dblclick={_ => ActionsManager.execute('spritesheet_tool_dblclick')} on:click={_ => ActionsManager.execute('spritesheet_set_active_tool', tool.enum)} selected={$activeTool === tool}>",
    		ctx
    	});

    	return block;
    }

    // (14:2) {#each toolsList as tool}
    function create_each_block$5(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*tool*/ ctx[6].visible_in_toolbar && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*tool*/ ctx[6].visible_in_toolbar) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(14:2) {#each toolsList as tool}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let ul;
    	let current;
    	let each_value = /*toolsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(ul, file$k, 12, 0, 408);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*toolsList, $activeTool, ActionsManager*/ 5) {
    				each_value = /*toolsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $activeTool;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ToolbarSelection", slots, []);
    	const { tools, activeTool } = Toolbar;
    	validate_store(activeTool, "activeTool");
    	component_subscribe($$self, activeTool, value => $$invalidate(0, $activeTool = value));

    	// get the values and sort after weight 
    	const toolsList = Object.values(tools);

    	toolsList.sort((a, b) => b.weight - a.weight);
    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ToolbarSelection> was created with unknown prop '${key}'`);
    	});

    	const dblclick_handler = _ => actions.execute("spritesheet_tool_dblclick");
    	const click_handler = (tool, _) => actions.execute("spritesheet_set_active_tool", tool.enum);

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		ToolButton,
    		Toolbar,
    		tools,
    		activeTool,
    		toolsList,
    		$activeTool
    	});

    	return [$activeTool, activeTool, toolsList, dblclick_handler, click_handler];
    }

    class ToolbarSelection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToolbarSelection",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src\_components\graphics\SpritesheetToolbar.svelte generated by Svelte v3.31.2 */
    const file$l = "src\\_components\\graphics\\SpritesheetToolbar.svelte";

    function create_fragment$o(ctx) {
    	let section2;
    	let section0;
    	let toolbarselection;
    	let t;
    	let section1;
    	let colorselection;
    	let current;
    	toolbarselection = new ToolbarSelection({ $$inline: true });
    	colorselection = new ColorSelection({ $$inline: true });

    	const block = {
    		c: function create() {
    			section2 = element("section");
    			section0 = element("section");
    			create_component(toolbarselection.$$.fragment);
    			t = space();
    			section1 = element("section");
    			create_component(colorselection.$$.fragment);
    			attr_dev(section0, "class", "toolbar-section svelte-t490rv");
    			add_location(section0, file$l, 6, 2, 170);
    			attr_dev(section1, "class", "color-selector-section svelte-t490rv");
    			add_location(section1, file$l, 10, 2, 249);
    			attr_dev(section2, "class", "toolbar svelte-t490rv");
    			add_location(section2, file$l, 5, 0, 141);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section2, anchor);
    			append_dev(section2, section0);
    			mount_component(toolbarselection, section0, null);
    			append_dev(section2, t);
    			append_dev(section2, section1);
    			mount_component(colorselection, section1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toolbarselection.$$.fragment, local);
    			transition_in(colorselection.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toolbarselection.$$.fragment, local);
    			transition_out(colorselection.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section2);
    			destroy_component(toolbarselection);
    			destroy_component(colorselection);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SpritesheetToolbar", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SpritesheetToolbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ ColorSelection, ToolbarSelection });
    	return [];
    }

    class SpritesheetToolbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SpritesheetToolbar",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src\_singles\buttons\Button.svelte generated by Svelte v3.31.2 */
    const file$m = "src\\_singles\\buttons\\Button.svelte";

    // (18:93) placeholder
    function fallback_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("placeholder");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(18:93) placeholder",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);
    	let button_levels = [{ role: "button" }, /*$$props*/ ctx[2]];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(button, button_data);
    			toggle_class(button, "danger", /*variant*/ ctx[0] == "danger");
    			toggle_class(button, "svelte-vh27lv", true);
    			add_location(button, file$m, 17, 0, 573);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [{ role: "button" }, dirty & /*$$props*/ 4 && /*$$props*/ ctx[2]]));
    			toggle_class(button, "danger", /*variant*/ ctx[0] == "danger");
    			toggle_class(button, "svelte-vh27lv", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Button", slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { variant = undefined } = $$props;

    	const click = e => {
    		if (variant == "danger" && !(e.ctrlKey || e.altKey)) {
    			actions.execute("notification", {
    				message: `Irreversible operations requires as a safety measure yout to ctrl or alt + click to execute it's action`,
    				variant: "warning"
    			});

    			return;
    		}

    		dispatch("click");
    	};

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("variant" in $$new_props) $$invalidate(0, variant = $$new_props.variant);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		createEventDispatcher,
    		dispatch,
    		variant,
    		click
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ("variant" in $$props) $$invalidate(0, variant = $$new_props.variant);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [variant, click, $$props, $$scope, slots];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { variant: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get variant() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
        Shorten string to max amount of characters at nearest space

        @param String
        @param Number
        @param String
        @param Function

        @return String

        // Usage: 
        // const string = "Lorem ipsum dolor sit amet consectetur adipisicing elit.";
        // const paragraph = slim(string, 40, ' ', _ => _ + '...');
        // console.log(paragraph);
      */
     const slim = (s, n, char, fn) => {
      const o = s;
      if(n < o.length){
        const max = s.slice(0, n);
        s = max.slice(0, max.lastIndexOf(char));
      }
      if(typeof fn === 'function'){
        s = fn.call(null, s, o, char);
      }
      return s;
    };

    /*
      basename 

      get the last part of a string path

      @param String
      @return String

      Usage:
      basename('base/path/to/file.json');
    */
    const basename = _ => _.split(/[\\/]/).pop();

    /* src\_components\LabelHeading.svelte generated by Svelte v3.31.2 */
    const file$n = "src\\_components\\LabelHeading.svelte";

    // (100:8) Label
    function fallback_block$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Label");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(100:8) Label",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(div, "class", "heading svelte-ekw9ql");
    			attr_dev(div, "spellcheck", "false");
    			toggle_class(div, "active", /*active*/ ctx[0]);
    			add_location(div, file$n, 98, 0, 2460);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div, null);
    			}

    			/*div_binding*/ ctx[11](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*edit*/ ctx[1], false, false, false),
    					listen_dev(div, "focus", /*focus*/ ctx[3], false, false, false),
    					listen_dev(div, "blur", /*blur*/ ctx[5], false, false, false),
    					listen_dev(div, "keydown", /*validateInput*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 512) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
    				}
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div, "active", /*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*div_binding*/ ctx[11](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LabelHeading", slots, ['default']);
    	let { editable = true } = $$props;
    	let { active } = $$props;
    	let { label } = $$props;
    	let { iconIndicator } = $$props;
    	const dispatch = createEventDispatcher();

    	// local properties
    	let element;

    	let previous = null;

    	const edit = e => {
    		if (!editable) return;
    		e.preventDefault();
    		let once = false;

    		// handle single and doubleclicks. if detail is undefined assume it's called programatically
    		if (e.detail == 1 && e.target == element) {
    			dispatch("makeActive");

    			if (!once) {
    				once = true;
    				setTimeout(_ => once = false, 60);
    			}
    		} else {
    			$$invalidate(6, iconIndicator = false);
    			$$invalidate(2, element.contentEditable = true, element);
    			element.focus();
    		}
    	};

    	// on focusing label heading
    	const focus = _ => {
    		_.target.textContent = label;
    		const range = document.createRange();
    		const selection = window.getSelection();
    		range.selectNodeContents(_.target);
    		selection.removeAllRanges();
    		selection.addRange(range);
    	};

    	// on key down validate input
    	const validateInput = e => {
    		if (!previous) {
    			previous = e.currentTarget.textContent;
    		}

    		e.stopPropagation();
    		e.stopImmediatePropagation();

    		// escape
    		if (e.which == 27) {
    			e.currentTarget.textContent = previous;
    			e.preventDefault();
    			element.blur();
    			return;
    		}

    		// enter
    		if (e.which == 13) {
    			e.preventDefault();
    			element.blur();
    		}

    		// backspace, delete, left arrow, right arrow
    		if (e.which == 8 || e.which == 46 || e.which == 37 || e.which == 39) {
    			return;
    		}

    		// check valid character
    		const isValidCharacter = (/^[a-z\s0-8\-\_]$/i).test(e.key);

    		if (!isValidCharacter && e.key !== "Backspace") {
    			e.preventDefault();
    			return;
    		}

    		// prevent to long labels
    		if (e.currentTarget.textContent.length > 20) {
    			e.preventDefault();
    		}
    	};

    	// on blurring
    	const blur = _ => {
    		previous = null;
    		$$invalidate(6, iconIndicator = true);
    		const v = _.target.textContent;
    		_.target.textContent = slim(v, 15, "", (n, o) => n != o ? n + "..." : n);
    		window.getSelection().removeAllRanges();
    		_.target.contentEditable = false;

    		// update the store entry with the new heading
    		dispatch("change", v);
    	};

    	const writable_props = ["editable", "active", "label", "iconIndicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LabelHeading> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			element = $$value;
    			$$invalidate(2, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("editable" in $$props) $$invalidate(7, editable = $$props.editable);
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    		if ("label" in $$props) $$invalidate(8, label = $$props.label);
    		if ("iconIndicator" in $$props) $$invalidate(6, iconIndicator = $$props.iconIndicator);
    		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		slim,
    		editable,
    		active,
    		label,
    		iconIndicator,
    		dispatch,
    		element,
    		previous,
    		edit,
    		focus,
    		validateInput,
    		blur
    	});

    	$$self.$inject_state = $$props => {
    		if ("editable" in $$props) $$invalidate(7, editable = $$props.editable);
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    		if ("label" in $$props) $$invalidate(8, label = $$props.label);
    		if ("iconIndicator" in $$props) $$invalidate(6, iconIndicator = $$props.iconIndicator);
    		if ("element" in $$props) $$invalidate(2, element = $$props.element);
    		if ("previous" in $$props) previous = $$props.previous;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		edit,
    		element,
    		focus,
    		validateInput,
    		blur,
    		iconIndicator,
    		editable,
    		label,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class LabelHeading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
    			editable: 7,
    			active: 0,
    			label: 8,
    			iconIndicator: 6,
    			edit: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LabelHeading",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*active*/ ctx[0] === undefined && !("active" in props)) {
    			console.warn("<LabelHeading> was created without expected prop 'active'");
    		}

    		if (/*label*/ ctx[8] === undefined && !("label" in props)) {
    			console.warn("<LabelHeading> was created without expected prop 'label'");
    		}

    		if (/*iconIndicator*/ ctx[6] === undefined && !("iconIndicator" in props)) {
    			console.warn("<LabelHeading> was created without expected prop 'iconIndicator'");
    		}
    	}

    	get editable() {
    		throw new Error("<LabelHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editable(value) {
    		throw new Error("<LabelHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<LabelHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<LabelHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<LabelHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<LabelHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconIndicator() {
    		throw new Error("<LabelHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconIndicator(value) {
    		throw new Error("<LabelHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get edit() {
    		return this.$$.ctx[1];
    	}

    	set edit(value) {
    		throw new Error("<LabelHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // drag directive
    const drag = (node, props) => {
      if(!props || typeof props.type != 'string'){
        throw new Error(`Invalid 'drag' actions properties. Expecting 'type' of type 'string'`)
      }

      if(!props.value){
        throw new Error(`Invalid 'drag' actions value.`)
      }

      // enable the drag and drop api
      node.draggable = true;
      node.classList.add('draggable');
      const dragStart = (e) => {
        // don't let event propagate if we have possible nested drags
        e.stopImmediatePropagation();
        e.dataTransfer.setData(props.type, JSON.stringify(props.value || ''));
        // this is some hacky stuff. since on the canvas we listen for windows mouse events but dragdrop never fires
        // mouseup on release. so force it here if we start dragging something.
        window.dispatchEvent(new Event('mouseup'));
      };
      node.addEventListener('dragstart', dragStart);
      
    	return {
        destroy() {
          // remove listener
          node.removeEventListener('dragstart', dragStart);
        }
    	};
    };


    // drop directive
    const drop = (node, props) => {
      if(!props){
        throw new Error(`Invalid 'drop' actions props.`);
      }
      const callback = (key, pass) => {
        if(!props[key] && typeof props[key] != 'function'){
          if(!pass){
            throw new Error(`Invalid 'drop' callback : [${key}]`);
          }
          return;
        }
        return props[key];
      };
      // handle dragover
      const dragOver = (e) => {
        e.preventDefault();
        callback('over', true).call(null, e, node);
      };
      node.addEventListener('dragover', dragOver);
      const dragLeave = (e) => {
        callback('leave', true).call(null, e, node);    
      };
      node.addEventListener('dragleave', dragLeave);
      // handle dropping of items
      const drop = (e) => {
        callback('drop').call(null, { e, node, value: props.value });
      };
      node.addEventListener('drop', drop);

    	return {
    		destroy() {
          // remove listener
          node.removeEventListener('dragover', dragOver);
          node.removeEventListener('drop', drop);
        }
    	};
    };

    /* src\_components\Layer.svelte generated by Svelte v3.31.2 */
    const file$o = "src\\_components\\Layer.svelte";

    // (61:4) <LabelHeading         {active}         label={source.label}         bind:iconIndicator         bind:this={heading}         on:makeActive={ e => dispatch('makeActive', source)}        on:change={e => dispatch('updateLabel', { source, value: e.detail })}>
    function create_default_slot_4$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[5]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 32) set_data_dev(t, /*label*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(61:4) <LabelHeading         {active}         label={source.label}         bind:iconIndicator         bind:this={heading}         on:makeActive={ e => dispatch('makeActive', source)}        on:change={e => dispatch('updateLabel', { source, value: e.detail })}>",
    		ctx
    	});

    	return block;
    }

    // (70:4) {#if iconIndicator}
    function create_if_block$5(ctx) {
    	let div;
    	let actionbutton;
    	let t;
    	let current;

    	actionbutton = new ActionButton({
    			props: {
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	actionbutton.$on("click", /*click_handler*/ ctx[19]);
    	let if_block = /*showEditButtons*/ ctx[2] && create_if_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(actionbutton.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "icon-indicator svelte-18jtf9z");
    			add_location(div, file$o, 70, 6, 2288);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(actionbutton, div, null);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actionbutton_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				actionbutton_changes.$$scope = { dirty, ctx };
    			}

    			actionbutton.$set(actionbutton_changes);

    			if (/*showEditButtons*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showEditButtons*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actionbutton.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actionbutton.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(actionbutton);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(70:4) {#if iconIndicator}",
    		ctx
    	});

    	return block;
    }

    // (72:8) <ActionButton on:click={e => heading.edit(e)}>
    function create_default_slot_3$1(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M19.769 9.923l-12.642 12.639-7.127 1.438 1.438-7.128 12.641-12.64 5.69 5.691zm1.414-1.414l2.817-2.82-5.691-5.689-2.816 2.817 5.69 5.692z");
    			attr_dev(path, "class", "svelte-18jtf9z");
    			add_location(path, file$o, 72, 93, 2467);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "12");
    			attr_dev(svg, "height", "12");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-18jtf9z");
    			add_location(svg, file$o, 72, 10, 2384);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(72:8) <ActionButton on:click={e => heading.edit(e)}>",
    		ctx
    	});

    	return block;
    }

    // (75:10) {#if showEditButtons}
    function create_if_block_1$1(ctx) {
    	let actionbutton0;
    	let t;
    	let actionbutton1;
    	let current;

    	actionbutton0 = new ActionButton({
    			props: {
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	actionbutton0.$on("click", /*cloneLayer*/ ctx[11]);

    	actionbutton1 = new ActionButton({
    			props: {
    				variant: "danger",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	actionbutton1.$on("click", /*removeLayer*/ ctx[10]);

    	const block = {
    		c: function create() {
    			create_component(actionbutton0.$$.fragment);
    			t = space();
    			create_component(actionbutton1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(actionbutton0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(actionbutton1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const actionbutton0_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				actionbutton0_changes.$$scope = { dirty, ctx };
    			}

    			actionbutton0.$set(actionbutton0_changes);
    			const actionbutton1_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				actionbutton1_changes.$$scope = { dirty, ctx };
    			}

    			actionbutton1.$set(actionbutton1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(actionbutton0.$$.fragment, local);
    			transition_in(actionbutton1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(actionbutton0.$$.fragment, local);
    			transition_out(actionbutton1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(actionbutton0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(actionbutton1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(75:10) {#if showEditButtons}",
    		ctx
    	});

    	return block;
    }

    // (76:12) <ActionButton on:click={cloneLayer}>
    function create_default_slot_2$2(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M18 6v-6h-18v18h6v6h18v-18h-6zm-12 10h-4v-14h14v4h-10v10zm16 6h-14v-14h14v14zm-3-8h-3v-3h-2v3h-3v2h3v3h2v-3h3v-2z");
    			attr_dev(path, "class", "svelte-18jtf9z");
    			add_location(path, file$o, 76, 97, 2828);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "12");
    			attr_dev(svg, "height", "12");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-18jtf9z");
    			add_location(svg, file$o, 76, 14, 2745);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(76:12) <ActionButton on:click={cloneLayer}>",
    		ctx
    	});

    	return block;
    }

    // (79:12) <ActionButton on:click={removeLayer} variant="danger">
    function create_default_slot_1$2(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M3 6v18h18v-18h-18zm5 14c0 .552-.448 1-1 1s-1-.448-1-1v-10c0-.552.448-1 1-1s1 .448 1 1v10zm5 0c0 .552-.448 1-1 1s-1-.448-1-1v-10c0-.552.448-1 1-1s1 .448 1 1v10zm5 0c0 .552-.448 1-1 1s-1-.448-1-1v-10c0-.552.448-1 1-1s1 .448 1 1v10zm4-18v2h-20v-2h5.711c.9 0 1.631-1.099 1.631-2h5.315c0 .901.73 2 1.631 2h5.712z");
    			attr_dev(path, "class", "svelte-18jtf9z");
    			add_location(path, file$o, 79, 97, 3155);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "12");
    			attr_dev(svg, "height", "12");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-18jtf9z");
    			add_location(svg, file$o, 79, 14, 3072);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(79:12) <ActionButton on:click={removeLayer} variant=\\\"danger\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:2) <PanelHeader>
    function create_default_slot$6(ctx) {
    	let labelheading;
    	let updating_iconIndicator;
    	let t;
    	let if_block_anchor;
    	let current;

    	function labelheading_iconIndicator_binding(value) {
    		/*labelheading_iconIndicator_binding*/ ctx[15].call(null, value);
    	}

    	let labelheading_props = {
    		active: /*active*/ ctx[8],
    		label: /*source*/ ctx[0].label,
    		$$slots: { default: [create_default_slot_4$1] },
    		$$scope: { ctx }
    	};

    	if (/*iconIndicator*/ ctx[4] !== void 0) {
    		labelheading_props.iconIndicator = /*iconIndicator*/ ctx[4];
    	}

    	labelheading = new LabelHeading({
    			props: labelheading_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(labelheading, "iconIndicator", labelheading_iconIndicator_binding));
    	/*labelheading_binding*/ ctx[16](labelheading);
    	labelheading.$on("makeActive", /*makeActive_handler*/ ctx[17]);
    	labelheading.$on("change", /*change_handler*/ ctx[18]);
    	let if_block = /*iconIndicator*/ ctx[4] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			create_component(labelheading.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(labelheading, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const labelheading_changes = {};
    			if (dirty & /*active*/ 256) labelheading_changes.active = /*active*/ ctx[8];
    			if (dirty & /*source*/ 1) labelheading_changes.label = /*source*/ ctx[0].label;

    			if (dirty & /*$$scope, label*/ 1048608) {
    				labelheading_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_iconIndicator && dirty & /*iconIndicator*/ 16) {
    				updating_iconIndicator = true;
    				labelheading_changes.iconIndicator = /*iconIndicator*/ ctx[4];
    				add_flush_callback(() => updating_iconIndicator = false);
    			}

    			labelheading.$set(labelheading_changes);

    			if (/*iconIndicator*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*iconIndicator*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(labelheading.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(labelheading.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*labelheading_binding*/ ctx[16](null);
    			destroy_component(labelheading, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(60:2) <PanelHeader>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let div;
    	let panelheader;
    	let t;
    	let drag_action;
    	let drop_action;
    	let current;
    	let mounted;
    	let dispose;

    	panelheader = new PanelHeader({
    			props: {
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(panelheader.$$.fragment);
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "layer-item svelte-18jtf9z");
    			toggle_class(div, "over", /*over*/ ctx[7]);
    			toggle_class(div, "active", /*active*/ ctx[8]);
    			add_location(div, file$o, 58, 0, 1785);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(panelheader, div, null);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(drag_action = drag.call(null, div, {
    						type: "flipPalette",
    						value: { layerIndex: /*layerIndex*/ ctx[3] }
    					})),
    					action_destroyer(drop_action = drop.call(null, div, {
    						.../*dropDirective*/ ctx[12],
    						value: { layerIndex: /*layerIndex*/ ctx[3] }
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const panelheader_changes = {};

    			if (dirty & /*$$scope, showEditButtons, heading, iconIndicator, active, source, label*/ 1048949) {
    				panelheader_changes.$$scope = { dirty, ctx };
    			}

    			panelheader.$set(panelheader_changes);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
    				}
    			}

    			if (drag_action && is_function(drag_action.update) && dirty & /*layerIndex*/ 8) drag_action.update.call(null, {
    				type: "flipPalette",
    				value: { layerIndex: /*layerIndex*/ ctx[3] }
    			});

    			if (drop_action && is_function(drop_action.update) && dirty & /*layerIndex*/ 8) drop_action.update.call(null, {
    				.../*dropDirective*/ ctx[12],
    				value: { layerIndex: /*layerIndex*/ ctx[3] }
    			});

    			if (dirty & /*over*/ 128) {
    				toggle_class(div, "over", /*over*/ ctx[7]);
    			}

    			if (dirty & /*active*/ 256) {
    				toggle_class(div, "active", /*active*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(panelheader.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(panelheader.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(panelheader);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let active;

    	let $activeLayer,
    		$$unsubscribe_activeLayer = noop,
    		$$subscribe_activeLayer = () => ($$unsubscribe_activeLayer(), $$unsubscribe_activeLayer = subscribe(activeLayer, $$value => $$invalidate(13, $activeLayer = $$value)), activeLayer);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_activeLayer());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Layer", slots, ['default']);
    	let { source = undefined } = $$props;
    	let { activeLayer = undefined } = $$props;
    	validate_store(activeLayer, "activeLayer");
    	$$subscribe_activeLayer();
    	let { showEditButtons = true } = $$props;
    	let { layerIndex = undefined } = $$props;
    	let iconIndicator = true;

    	// edit heading 
    	let label, heading;

    	const dispatch = createEventDispatcher();

    	// don't allow left-click remove
    	const removeLayer = e => {
    		if (e.ctrlKey || e.altKey) {
    			dispatch("remove", source);
    		} else {
    			// send notification modal that one has to use right-click or ctrl + click
    			actions.execute("notification", {
    				message: `Irreversible operations requires as a safety measure yout to ctrl or alt + click to execute it's action`,
    				variant: "warning"
    			});
    		}
    	};

    	// dispatch clone event
    	const cloneLayer = e => dispatch("clone", source);

    	let over;

    	const dropDirective = {
    		over: _ => $$invalidate(7, over = true),
    		leave: _ => $$invalidate(7, over = false),
    		drop: ({ e, value }) => {
    			$$invalidate(7, over = false);
    			const flip = e.dataTransfer.getData("flipPalette");

    			if (flip) {
    				const n = Number(JSON.parse(flip).layerIndex);
    				dispatch("swapLayers", { to: n, from: value.layerIndex });
    			}
    		}
    	};

    	const writable_props = ["source", "activeLayer", "showEditButtons", "layerIndex"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layer> was created with unknown prop '${key}'`);
    	});

    	function labelheading_iconIndicator_binding(value) {
    		iconIndicator = value;
    		$$invalidate(4, iconIndicator);
    	}

    	function labelheading_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			heading = $$value;
    			$$invalidate(6, heading);
    		});
    	}

    	const makeActive_handler = e => dispatch("makeActive", source);
    	const change_handler = e => dispatch("updateLabel", { source, value: e.detail });
    	const click_handler = e => heading.edit(e);

    	$$self.$$set = $$props => {
    		if ("source" in $$props) $$invalidate(0, source = $$props.source);
    		if ("activeLayer" in $$props) $$subscribe_activeLayer($$invalidate(1, activeLayer = $$props.activeLayer));
    		if ("showEditButtons" in $$props) $$invalidate(2, showEditButtons = $$props.showEditButtons);
    		if ("layerIndex" in $$props) $$invalidate(3, layerIndex = $$props.layerIndex);
    		if ("$$scope" in $$props) $$invalidate(20, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		ActionsManager: actions,
    		PanelHeader,
    		LabelHeading,
    		ActionButton,
    		slim,
    		drag,
    		drop,
    		source,
    		activeLayer,
    		showEditButtons,
    		layerIndex,
    		iconIndicator,
    		label,
    		heading,
    		dispatch,
    		removeLayer,
    		cloneLayer,
    		over,
    		dropDirective,
    		active,
    		$activeLayer
    	});

    	$$self.$inject_state = $$props => {
    		if ("source" in $$props) $$invalidate(0, source = $$props.source);
    		if ("activeLayer" in $$props) $$subscribe_activeLayer($$invalidate(1, activeLayer = $$props.activeLayer));
    		if ("showEditButtons" in $$props) $$invalidate(2, showEditButtons = $$props.showEditButtons);
    		if ("layerIndex" in $$props) $$invalidate(3, layerIndex = $$props.layerIndex);
    		if ("iconIndicator" in $$props) $$invalidate(4, iconIndicator = $$props.iconIndicator);
    		if ("label" in $$props) $$invalidate(5, label = $$props.label);
    		if ("heading" in $$props) $$invalidate(6, heading = $$props.heading);
    		if ("over" in $$props) $$invalidate(7, over = $$props.over);
    		if ("active" in $$props) $$invalidate(8, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*source*/ 1) {
    			// reactive statements
    			 $$invalidate(5, label = slim(source.label, 15, "", (n, o) => n != o ? n + "..." : n));
    		}

    		if ($$self.$$.dirty & /*source, $activeLayer*/ 8193) {
    			 $$invalidate(8, active = source == $activeLayer);
    		}
    	};

    	return [
    		source,
    		activeLayer,
    		showEditButtons,
    		layerIndex,
    		iconIndicator,
    		label,
    		heading,
    		over,
    		active,
    		dispatch,
    		removeLayer,
    		cloneLayer,
    		dropDirective,
    		$activeLayer,
    		slots,
    		labelheading_iconIndicator_binding,
    		labelheading_binding,
    		makeActive_handler,
    		change_handler,
    		click_handler,
    		$$scope
    	];
    }

    class Layer$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
    			source: 0,
    			activeLayer: 1,
    			showEditButtons: 2,
    			layerIndex: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layer",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get source() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set source(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeLayer() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeLayer(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showEditButtons() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showEditButtons(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layerIndex() {
    		throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layerIndex(value) {
    		throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_components\graphics\SpritesheetLayer.svelte generated by Svelte v3.31.2 */

    // (12:0) <Layer {...$$restProps} on:swapLayers={swapLayers} on:remove={removeLayer} on:updateLabel={updateLabel} on:makeActive={makeLayerActive} on:clone={cloneLayer}>
    function create_default_slot$7(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(12:0) <Layer {...$$restProps} on:swapLayers={swapLayers} on:remove={removeLayer} on:updateLabel={updateLabel} on:makeActive={makeLayerActive} on:clone={cloneLayer}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let layer;
    	let current;
    	const layer_spread_levels = [/*$$restProps*/ ctx[5]];

    	let layer_props = {
    		$$slots: { default: [create_default_slot$7] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < layer_spread_levels.length; i += 1) {
    		layer_props = assign(layer_props, layer_spread_levels[i]);
    	}

    	layer = new Layer$1({ props: layer_props, $$inline: true });
    	layer.$on("swapLayers", /*swapLayers*/ ctx[4]);
    	layer.$on("remove", /*removeLayer*/ ctx[0]);
    	layer.$on("updateLabel", /*updateLabel*/ ctx[1]);
    	layer.$on("makeActive", /*makeLayerActive*/ ctx[2]);
    	layer.$on("clone", /*cloneLayer*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const layer_changes = (dirty & /*$$restProps*/ 32)
    			? get_spread_update(layer_spread_levels, [get_spread_object(/*$$restProps*/ ctx[5])])
    			: {};

    			if (dirty & /*$$scope*/ 128) {
    				layer_changes.$$scope = { dirty, ctx };
    			}

    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SpritesheetLayer", slots, ['default']);
    	const removeLayer = e => actions.execute("spritesheet_remove", e.detail);

    	const updateLabel = e => actions.execute("spritesheet_update_layer_label", {
    		source: e.detail.source,
    		label: e.detail.value
    	});

    	const makeLayerActive = e => actions.execute("spritesheet_make_layer_active", e.detail);
    	const cloneLayer = e => actions.execute("spritesheet_clone_layer", e.detail);
    	const swapLayers = e => actions.execute("spritesheet_swap_layers", e.detail);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		Layer: Layer$1,
    		removeLayer,
    		updateLabel,
    		makeLayerActive,
    		cloneLayer,
    		swapLayers
    	});

    	return [
    		removeLayer,
    		updateLabel,
    		makeLayerActive,
    		cloneLayer,
    		swapLayers,
    		$$restProps,
    		slots,
    		$$scope
    	];
    }

    class SpritesheetLayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SpritesheetLayer",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src\_components\graphics\SpritesheetLayers.svelte generated by Svelte v3.31.2 */
    const file$p = "src\\_components\\graphics\\SpritesheetLayers.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (26:4) {:else}
    function create_else_block$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No spritesheets";
    			attr_dev(div, "class", "center svelte-1xx5how");
    			add_location(div, file$p, 26, 6, 841);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(26:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if $layers.length}
    function create_if_block$6(ctx) {
    	let previous_key = /*$layers*/ ctx[0];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$1(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$layers*/ 1 && safe_not_equal(previous_key, previous_key = /*$layers*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$1(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(16:4) {#if $layers.length}",
    		ctx
    	});

    	return block;
    }

    // (19:10) <Layer source={canvas} activeLayer={activeLayer} {layerIndex}>
    function create_default_slot_1$3(ctx) {
    	let div;
    	let canvaspreview;
    	let t;
    	let current;

    	canvaspreview = new CanvasPreview({
    			props: { source: /*canvas*/ ctx[4], clamp: true },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(canvaspreview.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "canvas-preview-wrapper svelte-1xx5how");
    			add_location(div, file$p, 19, 12, 658);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(canvaspreview, div, null);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const canvaspreview_changes = {};
    			if (dirty & /*$layers*/ 1) canvaspreview_changes.source = /*canvas*/ ctx[4];
    			canvaspreview.$set(canvaspreview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(canvaspreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(canvaspreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(canvaspreview);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(19:10) <Layer source={canvas} activeLayer={activeLayer} {layerIndex}>",
    		ctx
    	});

    	return block;
    }

    // (18:8) {#each $layers as canvas, layerIndex}
    function create_each_block$6(ctx) {
    	let layer;
    	let current;

    	layer = new SpritesheetLayer({
    			props: {
    				source: /*canvas*/ ctx[4],
    				activeLayer: /*activeLayer*/ ctx[1],
    				layerIndex: /*layerIndex*/ ctx[6],
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const layer_changes = {};
    			if (dirty & /*$layers*/ 1) layer_changes.source = /*canvas*/ ctx[4];

    			if (dirty & /*$$scope, $layers*/ 129) {
    				layer_changes.$$scope = { dirty, ctx };
    			}

    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(18:8) {#each $layers as canvas, layerIndex}",
    		ctx
    	});

    	return block;
    }

    // (17:6) {#key $layers}
    function create_key_block$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$layers*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$layers, activeLayer*/ 3) {
    				each_value = /*$layers*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$1.name,
    		type: "key",
    		source: "(17:6) {#key $layers}",
    		ctx
    	});

    	return block;
    }

    // (34:4) <Button on:click={_ => ActionsManager.execute('spritesheet_create')}>
    function create_default_slot$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create spritesheet");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(34:4) <Button on:click={_ => ActionsManager.execute('spritesheet_create')}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div2;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div1;
    	let button;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$layers*/ ctx[0].length) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "layers svelte-1xx5how");
    			add_location(div0, file$p, 14, 2, 455);
    			attr_dev(div1, "class", "center svelte-1xx5how");
    			add_location(div1, file$p, 32, 2, 927);
    			attr_dev(div2, "class", "palette-layer svelte-1xx5how");
    			add_location(div2, file$p, 12, 0, 422);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $layers;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SpritesheetLayers", slots, []);
    	const { activeLayer, layers } = Spritesheets.stores;
    	validate_store(layers, "layers");
    	component_subscribe($$self, layers, value => $$invalidate(0, $layers = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SpritesheetLayers> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => actions.execute("spritesheet_create");

    	$$self.$capture_state = () => ({
    		Button,
    		Layer: SpritesheetLayer,
    		CanvasPreview,
    		ActionsManager: actions,
    		Spritesheets,
    		activeLayer,
    		layers,
    		$layers
    	});

    	return [$layers, activeLayer, layers, click_handler];
    }

    class SpritesheetLayers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SpritesheetLayers",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* src\_components\graphics\PaletteLayer.svelte generated by Svelte v3.31.2 */

    // (12:0) <Layer {...$$restProps} on:swapLayers={swapLayers} on:remove={removeLayer} on:updateLabel={updateLabel} on:makeActive={makeLayerActive} on:clone={cloneLayer}>
    function create_default_slot$9(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(12:0) <Layer {...$$restProps} on:swapLayers={swapLayers} on:remove={removeLayer} on:updateLabel={updateLabel} on:makeActive={makeLayerActive} on:clone={cloneLayer}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let layer;
    	let current;
    	const layer_spread_levels = [/*$$restProps*/ ctx[5]];

    	let layer_props = {
    		$$slots: { default: [create_default_slot$9] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < layer_spread_levels.length; i += 1) {
    		layer_props = assign(layer_props, layer_spread_levels[i]);
    	}

    	layer = new Layer$1({ props: layer_props, $$inline: true });
    	layer.$on("swapLayers", /*swapLayers*/ ctx[4]);
    	layer.$on("remove", /*removeLayer*/ ctx[0]);
    	layer.$on("updateLabel", /*updateLabel*/ ctx[1]);
    	layer.$on("makeActive", /*makeLayerActive*/ ctx[2]);
    	layer.$on("clone", /*cloneLayer*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const layer_changes = (dirty & /*$$restProps*/ 32)
    			? get_spread_update(layer_spread_levels, [get_spread_object(/*$$restProps*/ ctx[5])])
    			: {};

    			if (dirty & /*$$scope*/ 128) {
    				layer_changes.$$scope = { dirty, ctx };
    			}

    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PaletteLayer", slots, ['default']);
    	const removeLayer = e => actions.execute("palette_remove", e.detail);

    	const updateLabel = e => actions.execute("palette_update_layer_label", {
    		source: e.detail.source,
    		label: e.detail.value
    	});

    	const makeLayerActive = e => actions.execute("palette_make_layer_active", e.detail);
    	const cloneLayer = e => actions.execute("palette_clone_layer", e.detail);
    	const swapLayers = e => actions.execute("palette_swap_layers", e.detail);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		Layer: Layer$1,
    		removeLayer,
    		updateLabel,
    		makeLayerActive,
    		cloneLayer,
    		swapLayers
    	});

    	return [
    		removeLayer,
    		updateLabel,
    		makeLayerActive,
    		cloneLayer,
    		swapLayers,
    		$$restProps,
    		slots,
    		$$scope
    	];
    }

    class PaletteLayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaletteLayer",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src\_singles\Color.svelte generated by Svelte v3.31.2 */
    const file$q = "src\\_singles\\Color.svelte";

    // (22:10) 0x
    function fallback_block$3(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("0x");
    			t1 = text(/*hex*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*hex*/ 2) set_data_dev(t1, /*hex*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$3.name,
    		type: "fallback",
    		source: "(22:10) 0x",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div;
    	let span;
    	let drag_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	const default_slot_or_fallback = default_slot || fallback_block$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_style(span, "pointer-events", "none");
    			attr_dev(span, "class", "svelte-1j057y7");
    			add_location(span, file$q, 20, 2, 625);
    			attr_dev(div, "class", "color svelte-1j057y7");
    			attr_dev(div, "data-hex", /*hex*/ ctx[1]);
    			set_style(div, "--rgb", "rgb(" + /*rgb*/ ctx[0].join(",") + ")");
    			toggle_class(div, "active", /*$activeLayer*/ ctx[5] && /*colorIndex*/ ctx[4] == /*$selectedColor*/ ctx[6] && /*layerIndex*/ ctx[3] == Palettes.layerIndexFromSource(/*$activeLayer*/ ctx[5]));
    			add_location(div, file$q, 13, 0, 324);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*click_handler*/ ctx[11], false, false, false),
    					action_destroyer(drag_action = drag.call(null, div, {
    						type: /*type*/ ctx[2],
    						value: {
    							rgb: /*rgb*/ ctx[0],
    							hex: /*hex*/ ctx[1],
    							type: /*type*/ ctx[2],
    							layerIndex: /*layerIndex*/ ctx[3],
    							colorIndex: /*colorIndex*/ ctx[4]
    						}
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 512) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*hex*/ 2) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*hex*/ 2) {
    				attr_dev(div, "data-hex", /*hex*/ ctx[1]);
    			}

    			if (!current || dirty & /*rgb*/ 1) {
    				set_style(div, "--rgb", "rgb(" + /*rgb*/ ctx[0].join(",") + ")");
    			}

    			if (drag_action && is_function(drag_action.update) && dirty & /*type, rgb, hex, layerIndex, colorIndex*/ 31) drag_action.update.call(null, {
    				type: /*type*/ ctx[2],
    				value: {
    					rgb: /*rgb*/ ctx[0],
    					hex: /*hex*/ ctx[1],
    					type: /*type*/ ctx[2],
    					layerIndex: /*layerIndex*/ ctx[3],
    					colorIndex: /*colorIndex*/ ctx[4]
    				}
    			});

    			if (dirty & /*$activeLayer, colorIndex, $selectedColor, layerIndex, Palettes*/ 120) {
    				toggle_class(div, "active", /*$activeLayer*/ ctx[5] && /*colorIndex*/ ctx[4] == /*$selectedColor*/ ctx[6] && /*layerIndex*/ ctx[3] == Palettes.layerIndexFromSource(/*$activeLayer*/ ctx[5]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $activeLayer;
    	let $selectedColor;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Color", slots, ['default']);
    	let { rgb } = $$props;
    	let { hex } = $$props;
    	let { type } = $$props;
    	let { layerIndex = undefined } = $$props;
    	let { colorIndex = undefined } = $$props;
    	const { selectedColor, activeLayer } = Palettes.stores;
    	validate_store(selectedColor, "selectedColor");
    	component_subscribe($$self, selectedColor, value => $$invalidate(6, $selectedColor = value));
    	validate_store(activeLayer, "activeLayer");
    	component_subscribe($$self, activeLayer, value => $$invalidate(5, $activeLayer = value));
    	const writable_props = ["rgb", "hex", "type", "layerIndex", "colorIndex"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Color> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("rgb" in $$props) $$invalidate(0, rgb = $$props.rgb);
    		if ("hex" in $$props) $$invalidate(1, hex = $$props.hex);
    		if ("type" in $$props) $$invalidate(2, type = $$props.type);
    		if ("layerIndex" in $$props) $$invalidate(3, layerIndex = $$props.layerIndex);
    		if ("colorIndex" in $$props) $$invalidate(4, colorIndex = $$props.colorIndex);
    		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Palettes,
    		drag,
    		rgb,
    		hex,
    		type,
    		layerIndex,
    		colorIndex,
    		selectedColor,
    		activeLayer,
    		$activeLayer,
    		$selectedColor
    	});

    	$$self.$inject_state = $$props => {
    		if ("rgb" in $$props) $$invalidate(0, rgb = $$props.rgb);
    		if ("hex" in $$props) $$invalidate(1, hex = $$props.hex);
    		if ("type" in $$props) $$invalidate(2, type = $$props.type);
    		if ("layerIndex" in $$props) $$invalidate(3, layerIndex = $$props.layerIndex);
    		if ("colorIndex" in $$props) $$invalidate(4, colorIndex = $$props.colorIndex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		rgb,
    		hex,
    		type,
    		layerIndex,
    		colorIndex,
    		$activeLayer,
    		$selectedColor,
    		selectedColor,
    		activeLayer,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class Color extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			rgb: 0,
    			hex: 1,
    			type: 2,
    			layerIndex: 3,
    			colorIndex: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Color",
    			options,
    			id: create_fragment$v.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*rgb*/ ctx[0] === undefined && !("rgb" in props)) {
    			console.warn("<Color> was created without expected prop 'rgb'");
    		}

    		if (/*hex*/ ctx[1] === undefined && !("hex" in props)) {
    			console.warn("<Color> was created without expected prop 'hex'");
    		}

    		if (/*type*/ ctx[2] === undefined && !("type" in props)) {
    			console.warn("<Color> was created without expected prop 'type'");
    		}
    	}

    	get rgb() {
    		throw new Error("<Color>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rgb(value) {
    		throw new Error("<Color>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hex() {
    		throw new Error("<Color>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hex(value) {
    		throw new Error("<Color>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Color>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Color>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layerIndex() {
    		throw new Error("<Color>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layerIndex(value) {
    		throw new Error("<Color>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorIndex() {
    		throw new Error("<Color>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorIndex(value) {
    		throw new Error("<Color>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_components\graphics\PaletteLayers.svelte generated by Svelte v3.31.2 */

    const file$r = "src\\_components\\graphics\\PaletteLayers.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (50:4) {:else}
    function create_else_block$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No palettes";
    			attr_dev(div, "class", "center svelte-njkqod");
    			add_location(div, file$r, 50, 6, 1606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(50:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:4) {#if $layers && $layers.length}
    function create_if_block_1$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$layers*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$layers, showEditButtons, activeLayer, colorDirective*/ 23) {
    				each_value = /*$layers*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(38:4) {#if $layers && $layers.length}",
    		ctx
    	});

    	return block;
    }

    // (44:16) <Color hex={color.hex} rgb={color.rgb} {layerIndex} {colorIndex} type="swap">
    function create_default_slot_2$3(ctx) {
    	let t0;
    	let t1_value = /*color*/ ctx[10].hex + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("0x");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$layers*/ 2 && t1_value !== (t1_value = /*color*/ ctx[10].hex + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(44:16) <Color hex={color.hex} rgb={color.rgb} {layerIndex} {colorIndex} type=\\\"swap\\\">",
    		ctx
    	});

    	return block;
    }

    // (42:12) {#each palette.colors as color, colorIndex (colorIndex)}
    function create_each_block_1(key_1, ctx) {
    	let li;
    	let color;
    	let t;
    	let drop_action;
    	let current;
    	let mounted;
    	let dispose;

    	color = new Color({
    			props: {
    				hex: /*color*/ ctx[10].hex,
    				rgb: /*color*/ ctx[10].rgb,
    				layerIndex: /*layerIndex*/ ctx[9],
    				colorIndex: /*colorIndex*/ ctx[12],
    				type: "swap",
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			create_component(color.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "svelte-njkqod");
    			add_location(li, file$r, 42, 14, 1306);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(color, li, null);
    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(drop_action = drop.call(null, li, {
    					.../*colorDirective*/ ctx[4],
    					value: {
    						layerIndex: /*layerIndex*/ ctx[9],
    						colorIndex: /*colorIndex*/ ctx[12]
    					}
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const color_changes = {};
    			if (dirty & /*$layers*/ 2) color_changes.hex = /*color*/ ctx[10].hex;
    			if (dirty & /*$layers*/ 2) color_changes.rgb = /*color*/ ctx[10].rgb;
    			if (dirty & /*$layers*/ 2) color_changes.colorIndex = /*colorIndex*/ ctx[12];

    			if (dirty & /*$$scope, $layers*/ 8194) {
    				color_changes.$$scope = { dirty, ctx };
    			}

    			color.$set(color_changes);

    			if (drop_action && is_function(drop_action.update) && dirty & /*$layers*/ 2) drop_action.update.call(null, {
    				.../*colorDirective*/ ctx[4],
    				value: {
    					layerIndex: /*layerIndex*/ ctx[9],
    					colorIndex: /*colorIndex*/ ctx[12]
    				}
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(color.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(color.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(color);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(42:12) {#each palette.colors as color, colorIndex (colorIndex)}",
    		ctx
    	});

    	return block;
    }

    // (40:8) <Layer source={palette} {showEditButtons} activeLayer={activeLayer} {layerIndex}>
    function create_default_slot_1$4(ctx) {
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let current;
    	let each_value_1 = /*palette*/ ctx[7].colors;
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*colorIndex*/ ctx[12];
    	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(ul, "class", "svelte-njkqod");
    			add_location(ul, file$r, 40, 10, 1216);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*colorDirective, $layers*/ 18) {
    				each_value_1 = /*palette*/ ctx[7].colors;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(40:8) <Layer source={palette} {showEditButtons} activeLayer={activeLayer} {layerIndex}>",
    		ctx
    	});

    	return block;
    }

    // (39:6) {#each $layers as palette, layerIndex}
    function create_each_block$7(ctx) {
    	let layer;
    	let current;

    	layer = new PaletteLayer({
    			props: {
    				source: /*palette*/ ctx[7],
    				showEditButtons: /*showEditButtons*/ ctx[0],
    				activeLayer: /*activeLayer*/ ctx[2],
    				layerIndex: /*layerIndex*/ ctx[9],
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const layer_changes = {};
    			if (dirty & /*$layers*/ 2) layer_changes.source = /*palette*/ ctx[7];
    			if (dirty & /*showEditButtons*/ 1) layer_changes.showEditButtons = /*showEditButtons*/ ctx[0];

    			if (dirty & /*$$scope, $layers*/ 8194) {
    				layer_changes.$$scope = { dirty, ctx };
    			}

    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(39:6) {#each $layers as palette, layerIndex}",
    		ctx
    	});

    	return block;
    }

    // (57:4) {#if showEditButtons}
    function create_if_block$7(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(57:4) {#if showEditButtons}",
    		ctx
    	});

    	return block;
    }

    // (58:6) <Button on:click={_ => ActionsManager.execute('palette_create')}>
    function create_default_slot$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create palette");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(58:6) <Button on:click={_ => ActionsManager.execute('palette_create')}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div2;
    	let div0;
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let div1;
    	let current;
    	const if_block_creators = [create_if_block_1$2, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$layers*/ ctx[1] && /*$layers*/ ctx[1].length) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*showEditButtons*/ ctx[0] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if_block0.c();
    			t = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "layers svelte-njkqod");
    			add_location(div0, file$r, 36, 2, 1010);
    			attr_dev(div1, "class", "center svelte-njkqod");
    			add_location(div1, file$r, 55, 2, 1686);
    			attr_dev(div2, "class", "palette-layer svelte-njkqod");
    			add_location(div2, file$r, 35, 0, 979);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div0, null);
    			}

    			if (/*showEditButtons*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*showEditButtons*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$7(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $layers;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PaletteLayers", slots, []);
    	let { showEditButtons = true } = $$props;
    	const { activeLayer, layers } = Palettes.stores;
    	validate_store(layers, "layers");
    	component_subscribe($$self, layers, value => $$invalidate(1, $layers = value));
    	let over;

    	const colorDirective = {
    		over: _ => over = true,
    		leave: _ => over = false,
    		drop: ({ e, value }) => {
    			over = false;
    			const swap = e.dataTransfer.getData("swap");

    			if (swap) {
    				layers.swapColors({ ...JSON.parse(swap), to: { ...value } });
    			}

    			// handle replacement
    			const replace = e.dataTransfer.getData("replace");

    			if (replace) {
    				layers.replaceColor({ ...JSON.parse(replace), ...value });
    			}
    		}
    	};

    	const writable_props = ["showEditButtons"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PaletteLayers> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => actions.execute("palette_create");

    	$$self.$$set = $$props => {
    		if ("showEditButtons" in $$props) $$invalidate(0, showEditButtons = $$props.showEditButtons);
    	};

    	$$self.$capture_state = () => ({
    		Palettes,
    		Button,
    		Layer: PaletteLayer,
    		Color,
    		ActionsManager: actions,
    		drop,
    		showEditButtons,
    		activeLayer,
    		layers,
    		over,
    		colorDirective,
    		$layers
    	});

    	$$self.$inject_state = $$props => {
    		if ("showEditButtons" in $$props) $$invalidate(0, showEditButtons = $$props.showEditButtons);
    		if ("over" in $$props) over = $$props.over;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [showEditButtons, $layers, activeLayer, layers, colorDirective, click_handler];
    }

    class PaletteLayers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { showEditButtons: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaletteLayers",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get showEditButtons() {
    		throw new Error("<PaletteLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showEditButtons(value) {
    		throw new Error("<PaletteLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var clickOutside = (element, fn) => {
      const handler = (e) => {
        if(!element.contains(e.target)){
          e.preventDefault();
          fn.call(null);
        }
      };
      window.addEventListener('click', handler);
      return {
        destroy(){
          window.removeEventListener('click', handler);
        }
      }
    };

    /* src\_singles\buttons\CircularPillButton.svelte generated by Svelte v3.31.2 */

    const file$s = "src\\_singles\\buttons\\CircularPillButton.svelte";

    function create_fragment$x(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", "svelte-8gzkl6");
    			add_location(button, file$s, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CircularPillButton", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CircularPillButton> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots, click_handler];
    }

    class CircularPillButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CircularPillButton",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src\_components\SelectButton.svelte generated by Svelte v3.31.2 */
    const file$t = "src\\_components\\SelectButton.svelte";
    const get_list_slot_changes = dirty => ({});
    const get_list_slot_context = ctx => ({});
    const get_icon_slot_changes = dirty => ({});
    const get_icon_slot_context = ctx => ({});

    // (9:2) <CircularPillButton on:click={_ => active = !active}>
    function create_default_slot$b(ctx) {
    	let current;
    	const icon_slot_template = /*#slots*/ ctx[1].icon;
    	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[4], get_icon_slot_context);

    	const block = {
    		c: function create() {
    			if (icon_slot) icon_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (icon_slot) {
    				icon_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (icon_slot) {
    				if (icon_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(icon_slot, icon_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_icon_slot_changes, get_icon_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (icon_slot) icon_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(9:2) <CircularPillButton on:click={_ => active = !active}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let div1;
    	let t0;
    	let circularpillbutton;
    	let t1;
    	let div0;
    	let clickOutside_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	circularpillbutton = new CircularPillButton({
    			props: {
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	circularpillbutton.$on("click", /*click_handler*/ ctx[2]);
    	const list_slot_template = /*#slots*/ ctx[1].list;
    	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[4], get_list_slot_context);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			create_component(circularpillbutton.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if (list_slot) list_slot.c();
    			attr_dev(div0, "class", "dropdown svelte-1rwcx4c");
    			add_location(div0, file$t, 11, 2, 399);
    			attr_dev(div1, "class", "select-button svelte-1rwcx4c");
    			toggle_class(div1, "active", /*active*/ ctx[0]);
    			add_location(div1, file$t, 6, 0, 186);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			mount_component(circularpillbutton, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (list_slot) {
    				list_slot.m(div0, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(clickOutside_action = clickOutside.call(null, div1, /*clickOutside_function*/ ctx[3]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			const circularpillbutton_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				circularpillbutton_changes.$$scope = { dirty, ctx };
    			}

    			circularpillbutton.$set(circularpillbutton_changes);

    			if (list_slot) {
    				if (list_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(list_slot, list_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_list_slot_changes, get_list_slot_context);
    				}
    			}

    			if (clickOutside_action && is_function(clickOutside_action.update) && dirty & /*active*/ 1) clickOutside_action.update.call(null, /*clickOutside_function*/ ctx[3]);

    			if (dirty & /*active*/ 1) {
    				toggle_class(div1, "active", /*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(circularpillbutton.$$.fragment, local);
    			transition_in(list_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(circularpillbutton.$$.fragment, local);
    			transition_out(list_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(circularpillbutton);
    			if (list_slot) list_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SelectButton", slots, ['default','icon','list']);
    	let active = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SelectButton> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => $$invalidate(0, active = !active);
    	const clickOutside_function = _ => $$invalidate(0, active = false);

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ clickOutside, CircularPillButton, active });

    	$$self.$inject_state = $$props => {
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [active, slots, click_handler, clickOutside_function, $$scope];
    }

    class SelectButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectButton",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* src\_components\ArtboardOptions.svelte generated by Svelte v3.31.2 */
    const file$u = "src\\_components\\ArtboardOptions.svelte";

    function create_fragment$z(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let button;
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			div1 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(div0, "class", "group svelte-1ux55nb");
    			add_location(div0, file$u, 6, 2, 141);
    			attr_dev(path, "d", "M10.573 3.021h7.427v-3.021l6 5.39-6 5.61v-3h-7.427c-3.071 0-5.561 2.356-5.561 5.427 0 3.071 2.489 5.573 5.561 5.573h7.427v5h-7.427c-5.84 0-10.573-4.734-10.573-10.573s4.733-10.406 10.573-10.406z");
    			add_location(path, file$u, 10, 138, 354);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "13");
    			attr_dev(svg, "height", "13");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-1ux55nb");
    			add_location(svg, file$u, 10, 55, 271);
    			attr_dev(button, "class", "svelte-1ux55nb");
    			add_location(button, file$u, 10, 4, 220);
    			attr_dev(div1, "class", "group svelte-1ux55nb");
    			add_location(div1, file$u, 9, 2, 195);
    			attr_dev(div2, "id", "buttons");
    			attr_dev(div2, "class", "svelte-1ux55nb");
    			add_location(div2, file$u, 5, 0, 119);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append_dev(div2, t);
    			append_dev(div2, div1);
    			append_dev(div1, button);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ArtboardOptions", slots, ['default']);
    	const dispatch = createEventDispatcher();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ArtboardOptions> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => dispatch("centerArtboard");

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ createEventDispatcher, dispatch });
    	return [dispatch, $$scope, slots, click_handler];
    }

    class ArtboardOptions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArtboardOptions",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* src\_components\graphics\SpritesheetOptions.svelte generated by Svelte v3.31.2 */
    const file$v = "src\\_components\\graphics\\SpritesheetOptions.svelte";
    const get_default_slot_changes_1 = dirty => ({});
    const get_default_slot_context_1 = ctx => ({ slot: "list" });
    const get_default_slot_changes$2 = dirty => ({});
    const get_default_slot_context$2 = ctx => ({ slot: "icon" });

    // (11:4) <slot slot="icon">        <svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 24 24"><path d="M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z"/></svg>      </slot>      <slot slot="list">              <div>          <Button on:click={_ => ActionsManager.execute('spritesheet_import')}
    function create_icon_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[0].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context$2);
    	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, get_default_slot_changes$2, get_default_slot_context$2);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot.name,
    		type: "slot",
    		source: "(11:4) <slot slot=\\\"icon\\\">        <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"13\\\" height=\\\"13\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z\\\"/></svg>      </slot>      <slot slot=\\\"list\\\">              <div>          <Button on:click={_ => ActionsManager.execute('spritesheet_import')}",
    		ctx
    	});

    	return block;
    }

    // (11:22)         
    function fallback_block_1(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z");
    			add_location(path, file$v, 11, 89, 454);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "13");
    			attr_dev(svg, "height", "13");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$v, 11, 6, 371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(11:22)         ",
    		ctx
    	});

    	return block;
    }

    // (16:8) <Button on:click={_ => ActionsManager.execute('spritesheet_import')}>
    function create_default_slot_7$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Import spritesheet");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(16:8) <Button on:click={_ => ActionsManager.execute('spritesheet_import')}>",
    		ctx
    	});

    	return block;
    }

    // (17:8) <Button on:click={_ => ActionsManager.execute('spritesheet_import_chr')}>
    function create_default_slot_6$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Import CHR");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(17:8) <Button on:click={_ => ActionsManager.execute('spritesheet_import_chr')}>",
    		ctx
    	});

    	return block;
    }

    // (20:8) <Button on:click={_ => ActionsManager.execute('spritesheet_export')}>
    function create_default_slot_5$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Export spritesheet");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(20:8) <Button on:click={_ => ActionsManager.execute('spritesheet_export')}>",
    		ctx
    	});

    	return block;
    }

    // (21:8) <Button on:click={_ => ActionsManager.execute('spritesheet_export_chr')}>
    function create_default_slot_4$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Export CHR");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(21:8) <Button on:click={_ => ActionsManager.execute('spritesheet_export_chr')}>",
    		ctx
    	});

    	return block;
    }

    // (22:8) <Button on:click={_ => ActionsManager.execute('spritesheet_export_png')}>
    function create_default_slot_3$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Export PNG");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(22:8) <Button on:click={_ => ActionsManager.execute('spritesheet_export_png')}>",
    		ctx
    	});

    	return block;
    }

    // (25:8) <Button variant="danger" on:click={_ => ActionsManager.execute('spritesheet_clear')}>
    function create_default_slot_2$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Clear all");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(25:8) <Button variant=\\\"danger\\\" on:click={_ => ActionsManager.execute('spritesheet_clear')}>",
    		ctx
    	});

    	return block;
    }

    // (14:4) <slot slot="list">              <div>          <Button on:click={_ => ActionsManager.execute('spritesheet_import')}
    function create_list_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[0].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context_1);
    	const default_slot_or_fallback = default_slot || fallback_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, get_default_slot_changes_1, get_default_slot_context_1);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_list_slot.name,
    		type: "slot",
    		source: "(14:4) <slot slot=\\\"list\\\">              <div>          <Button on:click={_ => ActionsManager.execute('spritesheet_import')}",
    		ctx
    	});

    	return block;
    }

    // (14:22)               
    function fallback_block$4(ctx) {
    	let div0;
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let div1;
    	let button2;
    	let t2;
    	let button3;
    	let t3;
    	let button4;
    	let t4;
    	let div2;
    	let button5;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[1]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[2]);

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*click_handler_2*/ ctx[3]);

    	button3 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3.$on("click", /*click_handler_3*/ ctx[4]);

    	button4 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button4.$on("click", /*click_handler_4*/ ctx[5]);

    	button5 = new Button({
    			props: {
    				variant: "danger",
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button5.$on("click", /*click_handler_5*/ ctx[6]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(button2.$$.fragment);
    			t2 = space();
    			create_component(button3.$$.fragment);
    			t3 = space();
    			create_component(button4.$$.fragment);
    			t4 = space();
    			div2 = element("div");
    			create_component(button5.$$.fragment);
    			add_location(div0, file$v, 14, 6, 1233);
    			add_location(div1, file$v, 18, 6, 1468);
    			add_location(div2, file$v, 23, 6, 1805);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(button0, div0, null);
    			append_dev(div0, t0);
    			mount_component(button1, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(button2, div1, null);
    			append_dev(div1, t2);
    			mount_component(button3, div1, null);
    			append_dev(div1, t3);
    			mount_component(button4, div1, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(button5, div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			const button3_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    			const button4_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				button4_changes.$$scope = { dirty, ctx };
    			}

    			button4.$set(button4_changes);
    			const button5_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				button5_changes.$$scope = { dirty, ctx };
    			}

    			button5.$set(button5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			transition_in(button4.$$.fragment, local);
    			transition_in(button5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			transition_out(button4.$$.fragment, local);
    			transition_out(button5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(button0);
    			destroy_component(button1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(button2);
    			destroy_component(button3);
    			destroy_component(button4);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div2);
    			destroy_component(button5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$4.name,
    		type: "fallback",
    		source: "(14:22)               ",
    		ctx
    	});

    	return block;
    }

    // (10:2) <SelectButton>
    function create_default_slot_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(10:2) <SelectButton>",
    		ctx
    	});

    	return block;
    }

    // (9:0) <ArtboardOptions on:centerArtboard>
    function create_default_slot$c(ctx) {
    	let selectbutton;
    	let current;

    	selectbutton = new SelectButton({
    			props: {
    				$$slots: {
    					default: [create_default_slot_1$5],
    					list: [create_list_slot],
    					icon: [create_icon_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(selectbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(selectbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const selectbutton_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				selectbutton_changes.$$scope = { dirty, ctx };
    			}

    			selectbutton.$set(selectbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(selectbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(9:0) <ArtboardOptions on:centerArtboard>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let artboardoptions;
    	let current;

    	artboardoptions = new ArtboardOptions({
    			props: {
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	artboardoptions.$on("centerArtboard", /*centerArtboard_handler*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(artboardoptions.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(artboardoptions, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const artboardoptions_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				artboardoptions_changes.$$scope = { dirty, ctx };
    			}

    			artboardoptions.$set(artboardoptions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(artboardoptions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(artboardoptions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(artboardoptions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SpritesheetOptions", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SpritesheetOptions> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => actions.execute("spritesheet_import");
    	const click_handler_1 = _ => actions.execute("spritesheet_import_chr");
    	const click_handler_2 = _ => actions.execute("spritesheet_export");
    	const click_handler_3 = _ => actions.execute("spritesheet_export_chr");
    	const click_handler_4 = _ => actions.execute("spritesheet_export_png");
    	const click_handler_5 = _ => actions.execute("spritesheet_clear");

    	function centerArtboard_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		SelectButton,
    		Button,
    		ArtboardOptions
    	});

    	return [
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		centerArtboard_handler,
    		$$scope
    	];
    }

    class SpritesheetOptions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SpritesheetOptions",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    /* src\modules\spritesheet_editor\Canvas.svelte generated by Svelte v3.31.2 */

    const file$w = "src\\modules\\spritesheet_editor\\Canvas.svelte";

    // (48:0) {:else}
    function create_else_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Please select a spritesheet and palette");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(48:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (42:0) {#if $activeLayer && $layers.length && $activePaletteLayer}
    function create_if_block$8(ctx) {
    	let div;
    	let canvas_1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			canvas_1 = element("canvas");
    			if (default_slot) default_slot.c();
    			attr_dev(canvas_1, "width", 128);
    			attr_dev(canvas_1, "height", 128);
    			attr_dev(canvas_1, "class", "svelte-9op668");
    			add_location(canvas_1, file$w, 43, 4, 1080);
    			set_style(div, "--zoom", /*zoom*/ ctx[0]);
    			attr_dev(div, "class", "svelte-9op668");
    			add_location(div, file$w, 42, 2, 1045);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, canvas_1);

    			if (default_slot) {
    				default_slot.m(canvas_1, null);
    			}

    			/*canvas_1_binding*/ ctx[10](canvas_1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*zoom*/ 1) {
    				set_style(div, "--zoom", /*zoom*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*canvas_1_binding*/ ctx[10](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(42:0) {#if $activeLayer && $layers.length && $activePaletteLayer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$activeLayer*/ ctx[2] && /*$layers*/ ctx[3].length && /*$activePaletteLayer*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let $activeLayer;
    	let $layers;
    	let $activePaletteLayer;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Canvas", slots, ['default']);
    	let { zoom } = $$props;
    	const { activeLayer, layers, width, height } = Spritesheets.stores;
    	validate_store(activeLayer, "activeLayer");
    	component_subscribe($$self, activeLayer, value => $$invalidate(2, $activeLayer = value));
    	validate_store(layers, "layers");
    	component_subscribe($$self, layers, value => $$invalidate(3, $layers = value));
    	const activePaletteLayer = Palettes.stores.activeLayer;
    	validate_store(activePaletteLayer, "activePaletteLayer");
    	component_subscribe($$self, activePaletteLayer, value => $$invalidate(4, $activePaletteLayer = value));
    	let canvas;
    	let editor = new SpritesheetEditor({ width, height });

    	// bind events
    	editor.on("primary", e => primary(e));

    	editor.on("secondary", e => secondary(e));
    	editor.on("move", e => move(e));
    	editor.on("mouseup", e => mouseup(e));

    	onMount(() => {
    		// clean up
    		return () => {
    			if (editor) {
    				editor.destroy();
    			}
    		};
    	});

    	const writable_props = ["zoom"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Canvas> was created with unknown prop '${key}'`);
    	});

    	function canvas_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			canvas = $$value;
    			$$invalidate(1, canvas);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Palettes,
    		Spritesheets,
    		SpritesheetEditor,
    		primary,
    		secondary,
    		move,
    		mouseup,
    		zoom,
    		activeLayer,
    		layers,
    		width,
    		height,
    		activePaletteLayer,
    		canvas,
    		editor,
    		$activeLayer,
    		$layers,
    		$activePaletteLayer
    	});

    	$$self.$inject_state = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    		if ("canvas" in $$props) $$invalidate(1, canvas = $$props.canvas);
    		if ("editor" in $$props) $$invalidate(13, editor = $$props.editor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*canvas*/ 2) {
    			 if (canvas) {
    				// editor
    				editor.defineCanvas(canvas);
    			}
    		}
    	};

    	return [
    		zoom,
    		canvas,
    		$activeLayer,
    		$layers,
    		$activePaletteLayer,
    		activeLayer,
    		layers,
    		activePaletteLayer,
    		$$scope,
    		slots,
    		canvas_1_binding
    	];
    }

    class Canvas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { zoom: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Canvas",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*zoom*/ ctx[0] === undefined && !("zoom" in props)) {
    			console.warn("<Canvas> was created without expected prop 'zoom'");
    		}
    	}

    	get zoom() {
    		throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoom(value) {
    		throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\modules\spritesheet_editor\SpritesheetEditor.svelte generated by Svelte v3.31.2 */

    function create_fragment$C(ctx) {
    	let canvas;
    	let current;

    	canvas = new Canvas({
    			props: { zoom: /*zoom*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(canvas.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(canvas, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const canvas_changes = {};
    			if (dirty & /*zoom*/ 1) canvas_changes.zoom = /*zoom*/ ctx[0];
    			canvas.$set(canvas_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(canvas.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(canvas.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(canvas, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SpritesheetEditor", slots, []);
    	let { zoom } = $$props;
    	const writable_props = ["zoom"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SpritesheetEditor> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    	};

    	$$self.$capture_state = () => ({ Canvas, zoom });

    	$$self.$inject_state = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zoom];
    }

    class SpritesheetEditor$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { zoom: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SpritesheetEditor",
    			options,
    			id: create_fragment$C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*zoom*/ ctx[0] === undefined && !("zoom" in props)) {
    			console.warn("<SpritesheetEditor> was created without expected prop 'zoom'");
    		}
    	}

    	get zoom() {
    		throw new Error("<SpritesheetEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoom(value) {
    		throw new Error("<SpritesheetEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_views\graphics\Spritesheets.svelte generated by Svelte v3.31.2 */
    const file$x = "src\\_views\\graphics\\Spritesheets.svelte";

    // (37:4) <Artboard x={$artboard.offset.x} y={$artboard.offset.y} on:artboardScrollEvent={changeZoomLevel} on:artboardOffsetEvent={changeOffset}>
    function create_default_slot$d(ctx) {
    	let spritesheeteditor;
    	let current;

    	spritesheeteditor = new SpritesheetEditor$1({
    			props: { zoom: /*zoom*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spritesheeteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spritesheeteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const spritesheeteditor_changes = {};
    			if (dirty & /*zoom*/ 2) spritesheeteditor_changes.zoom = /*zoom*/ ctx[1];
    			spritesheeteditor.$set(spritesheeteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spritesheeteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spritesheeteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spritesheeteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(37:4) <Artboard x={$artboard.offset.x} y={$artboard.offset.y} on:artboardScrollEvent={changeZoomLevel} on:artboardOffsetEvent={changeOffset}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let section0;
    	let div0;
    	let switch_instance;
    	let t0;
    	let div1;
    	let spritesheetoptions;
    	let t1;
    	let artboard_1;
    	let t2;
    	let section1;
    	let spritesheettoolbar;
    	let t3;
    	let section2;
    	let spritesheetlayers;
    	let t4;
    	let section3;
    	let palettelayers;
    	let current;
    	var switch_value = /*$activeTool*/ ctx[2].optionsComponent;

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	spritesheetoptions = new SpritesheetOptions({ $$inline: true });
    	spritesheetoptions.$on("centerArtboard", centerScrollAndCanvas);

    	artboard_1 = new Artboard({
    			props: {
    				x: /*$artboard*/ ctx[0].offset.x,
    				y: /*$artboard*/ ctx[0].offset.y,
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	artboard_1.$on("artboardScrollEvent", /*changeZoomLevel*/ ctx[5]);
    	artboard_1.$on("artboardOffsetEvent", /*changeOffset*/ ctx[6]);
    	spritesheettoolbar = new SpritesheetToolbar({ $$inline: true });
    	spritesheetlayers = new SpritesheetLayers({ $$inline: true });

    	palettelayers = new PaletteLayers({
    			props: { showEditButtons: false },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(spritesheetoptions.$$.fragment);
    			t1 = space();
    			create_component(artboard_1.$$.fragment);
    			t2 = space();
    			section1 = element("section");
    			create_component(spritesheettoolbar.$$.fragment);
    			t3 = space();
    			section2 = element("section");
    			create_component(spritesheetlayers.$$.fragment);
    			t4 = space();
    			section3 = element("section");
    			create_component(palettelayers.$$.fragment);
    			attr_dev(div0, "class", "options-panel svelte-torjmx");
    			add_location(div0, file$x, 31, 2, 1448);
    			attr_dev(div1, "class", "inner-artboard svelte-torjmx");
    			add_location(div1, file$x, 34, 2, 1568);
    			attr_dev(section0, "class", "main-artboard svelte-torjmx");
    			add_location(section0, file$x, 29, 0, 1362);
    			attr_dev(section1, "class", "toolbar-layer svelte-torjmx");
    			add_location(section1, file$x, 42, 0, 1886);
    			attr_dev(section2, "class", "spritesheets-layer svelte-torjmx");
    			add_location(section2, file$x, 46, 0, 1959);
    			attr_dev(section3, "class", "palettes-layer svelte-torjmx");
    			add_location(section3, file$x, 50, 0, 2036);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			append_dev(section0, t0);
    			append_dev(section0, div1);
    			mount_component(spritesheetoptions, div1, null);
    			append_dev(div1, t1);
    			mount_component(artboard_1, div1, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, section1, anchor);
    			mount_component(spritesheettoolbar, section1, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, section2, anchor);
    			mount_component(spritesheetlayers, section2, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, section3, anchor);
    			mount_component(palettelayers, section3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (switch_value !== (switch_value = /*$activeTool*/ ctx[2].optionsComponent)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			const artboard_1_changes = {};
    			if (dirty & /*$artboard*/ 1) artboard_1_changes.x = /*$artboard*/ ctx[0].offset.x;
    			if (dirty & /*$artboard*/ 1) artboard_1_changes.y = /*$artboard*/ ctx[0].offset.y;

    			if (dirty & /*$$scope, zoom*/ 130) {
    				artboard_1_changes.$$scope = { dirty, ctx };
    			}

    			artboard_1.$set(artboard_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(spritesheetoptions.$$.fragment, local);
    			transition_in(artboard_1.$$.fragment, local);
    			transition_in(spritesheettoolbar.$$.fragment, local);
    			transition_in(spritesheetlayers.$$.fragment, local);
    			transition_in(palettelayers.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(spritesheetoptions.$$.fragment, local);
    			transition_out(artboard_1.$$.fragment, local);
    			transition_out(spritesheettoolbar.$$.fragment, local);
    			transition_out(spritesheetlayers.$$.fragment, local);
    			transition_out(palettelayers.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (switch_instance) destroy_component(switch_instance);
    			destroy_component(spritesheetoptions);
    			destroy_component(artboard_1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(section1);
    			destroy_component(spritesheettoolbar);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(section2);
    			destroy_component(spritesheetlayers);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(section3);
    			destroy_component(palettelayers);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let zoom;
    	let $artboard;
    	let $activeTool;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Spritesheets", slots, []);
    	const { artboard } = Spritesheets.stores;
    	validate_store(artboard, "artboard");
    	component_subscribe($$self, artboard, value => $$invalidate(0, $artboard = value));
    	const { activeTool } = Toolbar;
    	validate_store(activeTool, "activeTool");
    	component_subscribe($$self, activeTool, value => $$invalidate(2, $activeTool = value));

    	// this should be refactored to be an action 
    	const changeZoomLevel = e => {
    		e.detail;

    		// TODO: find out the x,y of the cursor position and update the canvas origin
    		// so it zooms where the cursor is located. will perhaps give a nicer feel
    		// update zoom
    		set_store_value(artboard, $artboard.zoom = Math.max(1, zoom + (e.detail.deltaY < 0 ? 2 : -2)), $artboard);
    	};

    	const changeOffset = e => set_store_value(artboard, $artboard.offset = e.detail, $artboard);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spritesheets> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Artboard,
    		centerScrollAndCanvas,
    		SpritesheetToolbar,
    		SpritesheetLayers,
    		PaletteLayers,
    		SpritesheetOptions,
    		SpritesheetEditor: SpritesheetEditor$1,
    		Toolbar,
    		Spritesheets,
    		artboard,
    		activeTool,
    		changeZoomLevel,
    		changeOffset,
    		zoom,
    		$artboard,
    		$activeTool
    	});

    	$$self.$inject_state = $$props => {
    		if ("zoom" in $$props) $$invalidate(1, zoom = $$props.zoom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$artboard*/ 1) {
    			// react to the spritesheet artboard zoom. could refactor this a bit cleaner
    			// but this is a fast way to get it working.
    			 $$invalidate(1, zoom = $artboard.zoom);
    		}
    	};

    	return [
    		$artboard,
    		zoom,
    		$activeTool,
    		artboard,
    		activeTool,
    		changeZoomLevel,
    		changeOffset
    	];
    }

    class Spritesheets_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spritesheets_1",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* src\_components\LabelWrapper.svelte generated by Svelte v3.31.2 */

    const file$y = "src\\_components\\LabelWrapper.svelte";

    // (6:2) {#if label}
    function create_if_block$9(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*label*/ ctx[0]);
    			attr_dev(div, "class", "label svelte-j9cd0w");
    			add_location(div, file$y, 6, 4, 98);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(6:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = /*label*/ ctx[0] && create_if_block$9(ctx);
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "labeled svelte-j9cd0w");
    			add_location(div, file$y, 4, 0, 56);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LabelWrapper", slots, ['default']);
    	let { label = undefined } = $$props;
    	const writable_props = ["label"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LabelWrapper> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ label });

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label, $$scope, slots];
    }

    class LabelWrapper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { label: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LabelWrapper",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get label() {
    		throw new Error("<LabelWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<LabelWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_components\graphics\PaletteOptions.svelte generated by Svelte v3.31.2 */
    const file$z = "src\\_components\\graphics\\PaletteOptions.svelte";
    const get_default_slot_changes_1$1 = dirty => ({});
    const get_default_slot_context_1$1 = ctx => ({ slot: "list" });
    const get_default_slot_changes$3 = dirty => ({});
    const get_default_slot_context$3 = ctx => ({ slot: "icon" });

    // (11:4) <slot slot="icon">        <svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 24 24"><path d="M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z"/></svg>      </slot>      <slot slot="list">        <div>          <Button on:click={_ => ActionsManager.execute('palette_import')}
    function create_icon_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[0].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], get_default_slot_context$3);
    	const default_slot_or_fallback = default_slot || fallback_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, get_default_slot_changes$3, get_default_slot_context$3);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot$1.name,
    		type: "slot",
    		source: "(11:4) <slot slot=\\\"icon\\\">        <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"13\\\" height=\\\"13\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z\\\"/></svg>      </slot>      <slot slot=\\\"list\\\">        <div>          <Button on:click={_ => ActionsManager.execute('palette_import')}",
    		ctx
    	});

    	return block;
    }

    // (11:22)         
    function fallback_block_1$1(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z");
    			add_location(path, file$z, 11, 89, 454);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "13");
    			attr_dev(svg, "height", "13");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$z, 11, 6, 371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$1.name,
    		type: "fallback",
    		source: "(11:22)         ",
    		ctx
    	});

    	return block;
    }

    // (16:8) <Button on:click={_ => ActionsManager.execute('palette_import')}>
    function create_default_slot_4$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Import palette");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(16:8) <Button on:click={_ => ActionsManager.execute('palette_import')}>",
    		ctx
    	});

    	return block;
    }

    // (17:8) <Button on:click={_ => ActionsManager.execute('palette_export')}>
    function create_default_slot_3$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Export palette");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(17:8) <Button on:click={_ => ActionsManager.execute('palette_export')}>",
    		ctx
    	});

    	return block;
    }

    // (20:8) <Button variant="danger" on:click={_ => ActionsManager.execute('palette_clear')}>
    function create_default_slot_2$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Clear all");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(20:8) <Button variant=\\\"danger\\\" on:click={_ => ActionsManager.execute('palette_clear')}>",
    		ctx
    	});

    	return block;
    }

    // (14:4) <slot slot="list">        <div>          <Button on:click={_ => ActionsManager.execute('palette_import')}
    function create_list_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[0].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], get_default_slot_context_1$1);
    	const default_slot_or_fallback = default_slot || fallback_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, get_default_slot_changes_1$1, get_default_slot_context_1$1);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_list_slot$1.name,
    		type: "slot",
    		source: "(14:4) <slot slot=\\\"list\\\">        <div>          <Button on:click={_ => ActionsManager.execute('palette_import')}",
    		ctx
    	});

    	return block;
    }

    // (14:22)         
    function fallback_block$5(ctx) {
    	let div0;
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let div1;
    	let button2;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[1]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[2]);

    	button2 = new Button({
    			props: {
    				variant: "danger",
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*click_handler_2*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(button2.$$.fragment);
    			add_location(div0, file$z, 14, 6, 1227);
    			add_location(div1, file$z, 18, 6, 1450);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(button0, div0, null);
    			append_dev(div0, t0);
    			mount_component(button1, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(button2, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(button0);
    			destroy_component(button1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(button2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$5.name,
    		type: "fallback",
    		source: "(14:22)         ",
    		ctx
    	});

    	return block;
    }

    // (10:2) <SelectButton>
    function create_default_slot_1$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(10:2) <SelectButton>",
    		ctx
    	});

    	return block;
    }

    // (9:0) <ArtboardOptions on:centerArtboard>
    function create_default_slot$e(ctx) {
    	let selectbutton;
    	let current;

    	selectbutton = new SelectButton({
    			props: {
    				$$slots: {
    					default: [create_default_slot_1$6],
    					list: [create_list_slot$1],
    					icon: [create_icon_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(selectbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(selectbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const selectbutton_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				selectbutton_changes.$$scope = { dirty, ctx };
    			}

    			selectbutton.$set(selectbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(selectbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(9:0) <ArtboardOptions on:centerArtboard>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let artboardoptions;
    	let current;

    	artboardoptions = new ArtboardOptions({
    			props: {
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	artboardoptions.$on("centerArtboard", /*centerArtboard_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(artboardoptions.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(artboardoptions, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const artboardoptions_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				artboardoptions_changes.$$scope = { dirty, ctx };
    			}

    			artboardoptions.$set(artboardoptions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(artboardoptions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(artboardoptions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(artboardoptions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PaletteOptions", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PaletteOptions> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => actions.execute("palette_import");
    	const click_handler_1 = _ => actions.execute("palette_export");
    	const click_handler_2 = _ => actions.execute("palette_clear");

    	function centerArtboard_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		SelectButton,
    		Button,
    		ArtboardOptions
    	});

    	return [
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		centerArtboard_handler,
    		$$scope
    	];
    }

    class PaletteOptions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaletteOptions",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* src\_components\graphics\SwatchList.svelte generated by Svelte v3.31.2 */

    const { console: console_1 } = globals;
    const file$A = "src\\_components\\graphics\\SwatchList.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (10:2) {#each NESPalette as color}
    function create_each_block$8(ctx) {
    	let li;
    	let color;
    	let current;

    	color = new Color({
    			props: {
    				rgb: /*color*/ ctx[1].rgb,
    				hex: /*color*/ ctx[1].hex,
    				type: "replace"
    			},
    			$$inline: true
    		});

    	color.$on("click", /*click*/ ctx[0]);

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(color.$$.fragment);
    			add_location(li, file$A, 10, 4, 219);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(color, li, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(color.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(color.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(color);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(10:2) {#each NESPalette as color}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let ul;
    	let current;
    	let each_value = mappedColorList;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(ul, file$A, 8, 0, 178);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*NESPalette, click*/ 1) {
    				each_value = mappedColorList;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SwatchList", slots, []);

    	const click = e => {
    		console.log(e);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<SwatchList> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Color, NESPalette: mappedColorList, click });
    	return [click];
    }

    class SwatchList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SwatchList",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    /* src\_views\graphics\Palettes.svelte generated by Svelte v3.31.2 */
    const file$B = "src\\_views\\graphics\\Palettes.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (55:6) {:else}
    function create_else_block$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No layer selected");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(55:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (43:6) {#if $activeLayer}
    function create_if_block$a(ctx) {
    	let previous_key = /*$activeLayer*/ ctx[0];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$2(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$activeLayer*/ 1 && safe_not_equal(previous_key, previous_key = /*$activeLayer*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$2(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(43:6) {#if $activeLayer}",
    		ctx
    	});

    	return block;
    }

    // (47:14) {#each $activeLayer.colors as color, colorIndex}
    function create_each_block$9(ctx) {
    	let li;
    	let color;
    	let t;
    	let drop_action;
    	let current;
    	let mounted;
    	let dispose;

    	color = new Color({
    			props: {
    				hex: /*color*/ ctx[5].hex,
    				rgb: /*color*/ ctx[5].rgb,
    				layerIndex: Palettes.layerIndexFromSource(/*$activeLayer*/ ctx[0]),
    				colorIndex: /*colorIndex*/ ctx[7],
    				type: "swap"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(color.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "svelte-dgveli");
    			add_location(li, file$B, 47, 16, 1584);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(color, li, null);
    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(drop_action = drop.call(null, li, {
    					.../*colorDirective*/ ctx[2],
    					value: {
    						layerIndex: Palettes.layerIndexFromSource(/*$activeLayer*/ ctx[0]),
    						colorIndex: /*colorIndex*/ ctx[7]
    					}
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const color_changes = {};
    			if (dirty & /*$activeLayer*/ 1) color_changes.hex = /*color*/ ctx[5].hex;
    			if (dirty & /*$activeLayer*/ 1) color_changes.rgb = /*color*/ ctx[5].rgb;
    			if (dirty & /*$activeLayer*/ 1) color_changes.layerIndex = Palettes.layerIndexFromSource(/*$activeLayer*/ ctx[0]);
    			color.$set(color_changes);

    			if (drop_action && is_function(drop_action.update) && dirty & /*$activeLayer*/ 1) drop_action.update.call(null, {
    				.../*colorDirective*/ ctx[2],
    				value: {
    					layerIndex: Palettes.layerIndexFromSource(/*$activeLayer*/ ctx[0]),
    					colorIndex: /*colorIndex*/ ctx[7]
    				}
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(color.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(color.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(color);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(47:14) {#each $activeLayer.colors as color, colorIndex}",
    		ctx
    	});

    	return block;
    }

    // (45:10) <Labeled label={$activeLayer.label}>
    function create_default_slot_1$7(ctx) {
    	let ul;
    	let current;
    	let each_value = /*$activeLayer*/ ctx[0].colors;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "active-color-group svelte-dgveli");
    			add_location(ul, file$B, 45, 12, 1471);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*colorDirective, Palettes, $activeLayer*/ 5) {
    				each_value = /*$activeLayer*/ ctx[0].colors;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(45:10) <Labeled label={$activeLayer.label}>",
    		ctx
    	});

    	return block;
    }

    // (44:8) {#key $activeLayer}
    function create_key_block$2(ctx) {
    	let labeled;
    	let current;

    	labeled = new LabelWrapper({
    			props: {
    				label: /*$activeLayer*/ ctx[0].label,
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(labeled.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(labeled, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const labeled_changes = {};
    			if (dirty & /*$activeLayer*/ 1) labeled_changes.label = /*$activeLayer*/ ctx[0].label;

    			if (dirty & /*$$scope, $activeLayer*/ 257) {
    				labeled_changes.$$scope = { dirty, ctx };
    			}

    			labeled.$set(labeled_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(labeled.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(labeled.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(labeled, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$2.name,
    		type: "key",
    		source: "(44:8) {#key $activeLayer}",
    		ctx
    	});

    	return block;
    }

    // (42:4) <Artboard>
    function create_default_slot$f(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$activeLayer*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(42:4) <Artboard>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let section0;
    	let div0;
    	let t0;
    	let div1;
    	let paletteoptions;
    	let t1;
    	let artboard;
    	let t2;
    	let section1;
    	let swatchlist;
    	let t3;
    	let section2;
    	let palettelayers;
    	let current;
    	paletteoptions = new PaletteOptions({ $$inline: true });
    	paletteoptions.$on("centerArtboard", centerScrollAndCanvas);

    	artboard = new Artboard({
    			props: {
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	swatchlist = new SwatchList({ $$inline: true });

    	palettelayers = new PaletteLayers({
    			props: { showEditButtons: true },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			create_component(paletteoptions.$$.fragment);
    			t1 = space();
    			create_component(artboard.$$.fragment);
    			t2 = space();
    			section1 = element("section");
    			create_component(swatchlist.$$.fragment);
    			t3 = space();
    			section2 = element("section");
    			create_component(palettelayers.$$.fragment);
    			add_location(div0, file$B, 38, 2, 1229);
    			attr_dev(div1, "class", "inner-artboard svelte-dgveli");
    			add_location(div1, file$B, 39, 2, 1244);
    			attr_dev(section0, "class", "main-artboard svelte-dgveli");
    			add_location(section0, file$B, 36, 0, 1143);
    			attr_dev(section1, "class", "swatchlist svelte-dgveli");
    			add_location(section1, file$B, 61, 0, 2045);
    			attr_dev(section2, "class", "palettes-layers svelte-dgveli");
    			add_location(section2, file$B, 65, 0, 2107);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div0);
    			append_dev(section0, t0);
    			append_dev(section0, div1);
    			mount_component(paletteoptions, div1, null);
    			append_dev(div1, t1);
    			mount_component(artboard, div1, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, section1, anchor);
    			mount_component(swatchlist, section1, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, section2, anchor);
    			mount_component(palettelayers, section2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const artboard_changes = {};

    			if (dirty & /*$$scope, $activeLayer*/ 257) {
    				artboard_changes.$$scope = { dirty, ctx };
    			}

    			artboard.$set(artboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(paletteoptions.$$.fragment, local);
    			transition_in(artboard.$$.fragment, local);
    			transition_in(swatchlist.$$.fragment, local);
    			transition_in(palettelayers.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(paletteoptions.$$.fragment, local);
    			transition_out(artboard.$$.fragment, local);
    			transition_out(swatchlist.$$.fragment, local);
    			transition_out(palettelayers.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			destroy_component(paletteoptions);
    			destroy_component(artboard);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(section1);
    			destroy_component(swatchlist);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(section2);
    			destroy_component(palettelayers);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $activeLayer;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Palettes", slots, []);
    	const { activeLayer, layers } = Palettes.stores;
    	validate_store(activeLayer, "activeLayer");
    	component_subscribe($$self, activeLayer, value => $$invalidate(0, $activeLayer = value));
    	let over;

    	const colorDirective = {
    		over: _ => over = true,
    		leave: _ => over = false,
    		drop: ({ e, value }) => {
    			over = false;
    			const swap = e.dataTransfer.getData("swap");

    			if (swap) {
    				layers.swapColors({ ...JSON.parse(swap), to: { ...value } });
    			}

    			// handle replacement
    			const replace = e.dataTransfer.getData("replace");

    			if (replace) {
    				layers.replaceColor({ ...JSON.parse(replace), ...value });
    			}
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Palettes> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Color,
    		Artboard,
    		centerScrollAndCanvas,
    		Labeled: LabelWrapper,
    		PaletteLayers,
    		PaletteOptions,
    		Palettes,
    		activeLayer,
    		layers,
    		drop,
    		SwatchList,
    		over,
    		colorDirective,
    		$activeLayer
    	});

    	$$self.$inject_state = $$props => {
    		if ("over" in $$props) over = $$props.over;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$activeLayer, activeLayer, colorDirective];
    }

    class Palettes_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Palettes_1",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    let interval;
    const activeImage = derived(Spritesheets.stores.activeLayer, ($s, set) => {
      clearInterval(interval);
      if(!$s) return;
      interval = setInterval(() => {
        $s.updateImageSource();
        set($s.updateImageSource());
      }, 500);
      return () => {
        clearInterval(interval);
    	};
    });

    const layers$3 = derived(Spritesheets.stores.layers, $s => $s);

    const Spritesets = writable$1({ layers: layers$3, activeImage }, ({ store, value, get }) => {

      return {
        stores: value
      };
    });

    /* src\_singles\form\Select.svelte generated by Svelte v3.31.2 */

    const file$C = "src\\_singles\\form\\Select.svelte";

    // (9:2) {#if label}
    function create_if_block$b(ctx) {
    	let label_1;
    	let t;

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			t = text(/*label*/ ctx[1]);
    			attr_dev(label_1, "for", "select");
    			attr_dev(label_1, "class", "svelte-gfpjc3");
    			add_location(label_1, file$C, 9, 4, 200);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t, /*label*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(9:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let div1;
    	let t;
    	let div0;
    	let select;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*label*/ ctx[1] && create_if_block$b(ctx);
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");
    			select = element("select");
    			if (default_slot) default_slot.c();
    			attr_dev(select, "name", "select");
    			select.disabled = /*disabled*/ ctx[2];
    			attr_dev(select, "class", "svelte-gfpjc3");
    			if (/*value*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[7].call(select));
    			add_location(select, file$C, 12, 4, 299);
    			attr_dev(div0, "class", "select svelte-gfpjc3");
    			toggle_class(div0, "multiple", /*multiple*/ ctx[3]);
    			add_location(div0, file$C, 11, 2, 248);
    			attr_dev(div1, "class", "select-group svelte-gfpjc3");
    			add_location(div1, file$C, 7, 0, 153);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			append_dev(div0, select);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			select_option(select, /*value*/ ctx[0]);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[7]),
    					listen_dev(div0, "change", /*change_handler*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(select, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (dirty & /*value*/ 1) {
    				select_option(select, /*value*/ ctx[0]);
    			}

    			if (dirty & /*multiple*/ 8) {
    				toggle_class(div0, "multiple", /*multiple*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Select", slots, ['default']);
    	let { label = undefined } = $$props;
    	let { disabled = false } = $$props;
    	let { multiple = false } = $$props;
    	let { value = undefined } = $$props;
    	const writable_props = ["label", "disabled", "multiple", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function select_change_handler() {
    		value = select_value(this);
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ("multiple" in $$props) $$invalidate(3, multiple = $$props.multiple);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ label, disabled, multiple, value });

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ("multiple" in $$props) $$invalidate(3, multiple = $$props.multiple);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		label,
    		disabled,
    		multiple,
    		$$scope,
    		slots,
    		change_handler,
    		select_change_handler
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
    			label: 1,
    			disabled: 2,
    			multiple: 3,
    			value: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get label() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_views\graphics\Spritesets.svelte generated by Svelte v3.31.2 */
    const file$D = "src\\_views\\graphics\\Spritesets.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    // (44:4) <Artboard on:artboardScrollEvent={changeZoomLevel}>
    function create_default_slot_1$8(ctx) {
    	let spritesheeteditor;
    	let current;

    	spritesheeteditor = new SpritesheetEditor$1({
    			props: { zoom: /*zoom*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spritesheeteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spritesheeteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const spritesheeteditor_changes = {};
    			if (dirty & /*zoom*/ 1) spritesheeteditor_changes.zoom = /*zoom*/ ctx[0];
    			spritesheeteditor.$set(spritesheeteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spritesheeteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spritesheeteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spritesheeteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(44:4) <Artboard on:artboardScrollEvent={changeZoomLevel}>",
    		ctx
    	});

    	return block;
    }

    // (54:10) {:else}
    function create_else_block$6(ctx) {
    	let option;

    	const block = {
    		c: function create() {
    			option = element("option");
    			option.textContent = "oh noo!";
    			option.__value = "oh noo!";
    			option.value = option.__value;
    			add_location(option, file$D, 54, 12, 2179);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(54:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (52:10) {#each $layers as layer}
    function create_each_block_2(ctx) {
    	let option;
    	let t_value = /*layer*/ ctx[22].label + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*layer*/ ctx[22];
    			option.value = option.__value;
    			add_location(option, file$D, 52, 12, 2102);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$layers*/ 4 && t_value !== (t_value = /*layer*/ ctx[22].label + "")) set_data_dev(t, t_value);

    			if (dirty & /*$layers*/ 4 && option_value_value !== (option_value_value = /*layer*/ ctx[22])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(52:10) {#each $layers as layer}",
    		ctx
    	});

    	return block;
    }

    // (51:8) <Select bind:value={selectedSpritesheet} on:change={selectSpritesheet}>
    function create_default_slot$g(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*$layers*/ ctx[2];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	let each_1_else = null;

    	if (!each_value_2.length) {
    		each_1_else = create_else_block$6(ctx);
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();

    			if (each_1_else) {
    				each_1_else.c();
    			}
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$layers*/ 4) {
    				each_value_2 = /*$layers*/ ctx[2];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;

    				if (each_value_2.length) {
    					if (each_1_else) {
    						each_1_else.d(1);
    						each_1_else = null;
    					}
    				} else if (!each_1_else) {
    					each_1_else = create_else_block$6(ctx);
    					each_1_else.c();
    					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			if (each_1_else) each_1_else.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(51:8) <Select bind:value={selectedSpritesheet} on:change={selectSpritesheet}>",
    		ctx
    	});

    	return block;
    }

    // (61:6) {#if $activeLayer}
    function create_if_block$c(ctx) {
    	let previous_key = /*$activeImage*/ ctx[4];
    	let key_block_anchor;
    	let key_block = create_key_block$3(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$activeImage*/ 16 && safe_not_equal(previous_key, previous_key = /*$activeImage*/ ctx[4])) {
    				key_block.d(1);
    				key_block = create_key_block$3(ctx);
    				key_block.c();
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(61:6) {#if $activeLayer}",
    		ctx
    	});

    	return block;
    }

    // (64:12) {#each yl as b}
    function create_each_block_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "tile-image svelte-1og0o7w");
    			set_style(div, "--src", "url(" + /*$activeLayer*/ ctx[3].image.src + ")");
    			set_style(div, "--x", /*a*/ ctx[16]);
    			set_style(div, "--y", /*b*/ ctx[19]);
    			add_location(div, file$D, 64, 14, 2426);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$activeLayer*/ 8) {
    				set_style(div, "--src", "url(" + /*$activeLayer*/ ctx[3].image.src + ")");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(64:12) {#each yl as b}",
    		ctx
    	});

    	return block;
    }

    // (63:10) {#each xl as a}
    function create_each_block$a(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*yl*/ ctx[11];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$activeLayer, xl, yl*/ 3080) {
    				each_value_1 = /*yl*/ ctx[11];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(63:10) {#each xl as a}",
    		ctx
    	});

    	return block;
    }

    // (62:8) {#key $activeImage}
    function create_key_block$3(ctx) {
    	let each_1_anchor;
    	let each_value = /*xl*/ ctx[10];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*yl, $activeLayer, xl*/ 3080) {
    				each_value = /*xl*/ ctx[10];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$3.name,
    		type: "key",
    		source: "(62:8) {#key $activeImage}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let section1;
    	let div0;
    	let t0;
    	let div1;
    	let spritesheetoptions;
    	let t1;
    	let artboard_1;
    	let t2;
    	let section0;
    	let header;
    	let div2;
    	let select;
    	let updating_value;
    	let t3;
    	let div3;
    	let t4;
    	let section2;
    	let spritesheettoolbar;
    	let t5;
    	let section3;
    	let t6;
    	let section4;
    	let palettelayers;
    	let current;
    	spritesheetoptions = new SpritesheetOptions({ $$inline: true });
    	spritesheetoptions.$on("centerArtboard", centerScrollAndCanvas);

    	artboard_1 = new Artboard({
    			props: {
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	artboard_1.$on("artboardScrollEvent", /*changeZoomLevel*/ ctx[9]);

    	function select_value_binding(value) {
    		/*select_value_binding*/ ctx[13].call(null, value);
    	}

    	let select_props = {
    		$$slots: { default: [create_default_slot$g] },
    		$$scope: { ctx }
    	};

    	if (/*selectedSpritesheet*/ ctx[1] !== void 0) {
    		select_props.value = /*selectedSpritesheet*/ ctx[1];
    	}

    	select = new Select({ props: select_props, $$inline: true });
    	binding_callbacks.push(() => bind(select, "value", select_value_binding));
    	select.$on("change", /*selectSpritesheet*/ ctx[12]);
    	let if_block = /*$activeLayer*/ ctx[3] && create_if_block$c(ctx);
    	spritesheettoolbar = new SpritesheetToolbar({ $$inline: true });

    	palettelayers = new PaletteLayers({
    			props: { showEditButtons: false },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section1 = element("section");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			create_component(spritesheetoptions.$$.fragment);
    			t1 = space();
    			create_component(artboard_1.$$.fragment);
    			t2 = space();
    			section0 = element("section");
    			header = element("header");
    			div2 = element("div");
    			create_component(select.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			if (if_block) if_block.c();
    			t4 = space();
    			section2 = element("section");
    			create_component(spritesheettoolbar.$$.fragment);
    			t5 = space();
    			section3 = element("section");
    			t6 = space();
    			section4 = element("section");
    			create_component(palettelayers.$$.fragment);
    			add_location(div0, file$D, 40, 2, 1684);
    			attr_dev(div1, "class", "inner-artboard svelte-1og0o7w");
    			add_location(div1, file$D, 41, 2, 1699);
    			add_location(div2, file$D, 49, 6, 1966);
    			attr_dev(header, "class", "svelte-1og0o7w");
    			add_location(header, file$D, 48, 4, 1950);
    			attr_dev(div3, "class", "tile-grid svelte-1og0o7w");
    			add_location(div3, file$D, 59, 4, 2276);
    			attr_dev(section0, "class", "tiles svelte-1og0o7w");
    			add_location(section0, file$D, 47, 2, 1921);
    			attr_dev(section1, "class", "main-artboard svelte-1og0o7w");
    			add_location(section1, file$D, 38, 0, 1598);
    			attr_dev(section2, "class", "toolbar-layer svelte-1og0o7w");
    			add_location(section2, file$D, 73, 0, 2633);
    			attr_dev(section3, "class", "spritesheets-layer svelte-1og0o7w");
    			add_location(section3, file$D, 77, 0, 2706);
    			attr_dev(section4, "class", "palettes-layer svelte-1og0o7w");
    			add_location(section4, file$D, 81, 0, 2760);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div0);
    			append_dev(section1, t0);
    			append_dev(section1, div1);
    			mount_component(spritesheetoptions, div1, null);
    			append_dev(div1, t1);
    			mount_component(artboard_1, div1, null);
    			append_dev(section1, t2);
    			append_dev(section1, section0);
    			append_dev(section0, header);
    			append_dev(header, div2);
    			mount_component(select, div2, null);
    			append_dev(section0, t3);
    			append_dev(section0, div3);
    			if (if_block) if_block.m(div3, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, section2, anchor);
    			mount_component(spritesheettoolbar, section2, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, section3, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, section4, anchor);
    			mount_component(palettelayers, section4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const artboard_1_changes = {};

    			if (dirty & /*$$scope, zoom*/ 33554433) {
    				artboard_1_changes.$$scope = { dirty, ctx };
    			}

    			artboard_1.$set(artboard_1_changes);
    			const select_changes = {};

    			if (dirty & /*$$scope, $layers*/ 33554436) {
    				select_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*selectedSpritesheet*/ 2) {
    				updating_value = true;
    				select_changes.value = /*selectedSpritesheet*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			select.$set(select_changes);

    			if (/*$activeLayer*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spritesheetoptions.$$.fragment, local);
    			transition_in(artboard_1.$$.fragment, local);
    			transition_in(select.$$.fragment, local);
    			transition_in(spritesheettoolbar.$$.fragment, local);
    			transition_in(palettelayers.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spritesheetoptions.$$.fragment, local);
    			transition_out(artboard_1.$$.fragment, local);
    			transition_out(select.$$.fragment, local);
    			transition_out(spritesheettoolbar.$$.fragment, local);
    			transition_out(palettelayers.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section1);
    			destroy_component(spritesheetoptions);
    			destroy_component(artboard_1);
    			destroy_component(select);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(section2);
    			destroy_component(spritesheettoolbar);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(section3);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(section4);
    			destroy_component(palettelayers);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let $artboard;
    	let $layers;
    	let $activeLayer;
    	let $activeImage;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Spritesets", slots, []);
    	const { activeImage } = Spritesets.stores;
    	validate_store(activeImage, "activeImage");
    	component_subscribe($$self, activeImage, value => $$invalidate(4, $activeImage = value));
    	const { layers, activeLayer, artboard } = Spritesheets.stores;
    	validate_store(layers, "layers");
    	component_subscribe($$self, layers, value => $$invalidate(2, $layers = value));
    	validate_store(activeLayer, "activeLayer");
    	component_subscribe($$self, activeLayer, value => $$invalidate(3, $activeLayer = value));
    	validate_store(artboard, "artboard");
    	component_subscribe($$self, artboard, value => $$invalidate(14, $artboard = value));

    	// this should be refactored to be an action 
    	let zoom = $artboard.zoom;

    	const changeZoomLevel = e => {
    		// TODO: find out the x,y of the cursor position and update the canvas origin
    		// so it zooms where the cursor is located. will perhaps give a nicer feel
    		// update zoom
    		$$invalidate(0, zoom = Math.max(1, zoom + (zoom - e.detail.deltaY > 0 ? 1 : -1)));
    	};

    	const generateLoop = (n = 16) => new Array(n).fill(null).map((_, i) => i + 1).reverse();
    	let xl = [...generateLoop()];
    	let yl = [...generateLoop()];
    	let selectedSpritesheet;

    	const selectSpritesheet = e => {
    		actions.execute("spritesheet_make_layer_active", selectedSpritesheet);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spritesets> was created with unknown prop '${key}'`);
    	});

    	function select_value_binding(value) {
    		selectedSpritesheet = value;
    		$$invalidate(1, selectedSpritesheet);
    	}

    	$$self.$capture_state = () => ({
    		Artboard,
    		centerScrollAndCanvas,
    		SpritesheetToolbar,
    		SpritesheetLayers,
    		PaletteLayers,
    		SpritesheetOptions,
    		SpritesheetEditor: SpritesheetEditor$1,
    		ActionsManager: actions,
    		Spritesheets,
    		Spritesets,
    		Select,
    		activeImage,
    		layers,
    		activeLayer,
    		artboard,
    		zoom,
    		changeZoomLevel,
    		generateLoop,
    		xl,
    		yl,
    		selectedSpritesheet,
    		selectSpritesheet,
    		$artboard,
    		$layers,
    		$activeLayer,
    		$activeImage
    	});

    	$$self.$inject_state = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    		if ("xl" in $$props) $$invalidate(10, xl = $$props.xl);
    		if ("yl" in $$props) $$invalidate(11, yl = $$props.yl);
    		if ("selectedSpritesheet" in $$props) $$invalidate(1, selectedSpritesheet = $$props.selectedSpritesheet);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		zoom,
    		selectedSpritesheet,
    		$layers,
    		$activeLayer,
    		$activeImage,
    		activeImage,
    		layers,
    		activeLayer,
    		artboard,
    		changeZoomLevel,
    		xl,
    		yl,
    		selectSpritesheet,
    		select_value_binding
    	];
    }

    class Spritesets_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spritesets_1",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src\_components\graphics\TilemapsLayer.svelte generated by Svelte v3.31.2 */

    // (12:0) <Layer {...$$restProps} on:swapLayers={swapLayers} on:remove={removeLayer} on:updateLabel={updateLabel} on:makeActive={makeLayerActive} on:clone={cloneLayer}>
    function create_default_slot$h(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(12:0) <Layer {...$$restProps} on:swapLayers={swapLayers} on:remove={removeLayer} on:updateLabel={updateLabel} on:makeActive={makeLayerActive} on:clone={cloneLayer}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let layer;
    	let current;
    	const layer_spread_levels = [/*$$restProps*/ ctx[5]];

    	let layer_props = {
    		$$slots: { default: [create_default_slot$h] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < layer_spread_levels.length; i += 1) {
    		layer_props = assign(layer_props, layer_spread_levels[i]);
    	}

    	layer = new Layer$1({ props: layer_props, $$inline: true });
    	layer.$on("swapLayers", /*swapLayers*/ ctx[4]);
    	layer.$on("remove", /*removeLayer*/ ctx[0]);
    	layer.$on("updateLabel", /*updateLabel*/ ctx[1]);
    	layer.$on("makeActive", /*makeLayerActive*/ ctx[2]);
    	layer.$on("clone", /*cloneLayer*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const layer_changes = (dirty & /*$$restProps*/ 32)
    			? get_spread_update(layer_spread_levels, [get_spread_object(/*$$restProps*/ ctx[5])])
    			: {};

    			if (dirty & /*$$scope*/ 128) {
    				layer_changes.$$scope = { dirty, ctx };
    			}

    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TilemapsLayer", slots, ['default']);
    	const removeLayer = e => actions.execute("tilemap_remove", e.detail);

    	const updateLabel = e => actions.execute("tilemap_update_layer_label", {
    		source: e.detail.source,
    		label: e.detail.value
    	});

    	const makeLayerActive = e => actions.execute("tilemap_make_layer_active", e.detail);
    	const cloneLayer = e => actions.execute("tilemap_clone_layer", e.detail);
    	const swapLayers = e => actions.execute("tilemap_swap_layers", e.detail);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		Layer: Layer$1,
    		removeLayer,
    		updateLabel,
    		makeLayerActive,
    		cloneLayer,
    		swapLayers
    	});

    	return [
    		removeLayer,
    		updateLabel,
    		makeLayerActive,
    		cloneLayer,
    		swapLayers,
    		$$restProps,
    		slots,
    		$$scope
    	];
    }

    class TilemapsLayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TilemapsLayer",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* src\_components\graphics\TilemapsLayers.svelte generated by Svelte v3.31.2 */
    const file$E = "src\\_components\\graphics\\TilemapsLayers.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (26:4) {:else}
    function create_else_block$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No tilemaps";
    			attr_dev(div, "class", "center svelte-1xx5how");
    			add_location(div, file$E, 26, 6, 845);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(26:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if $layers.length}
    function create_if_block$d(ctx) {
    	let previous_key = /*$layers*/ ctx[0];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$4(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$layers*/ 1 && safe_not_equal(previous_key, previous_key = /*$layers*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$4(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(16:4) {#if $layers.length}",
    		ctx
    	});

    	return block;
    }

    // (19:10) <Layer source={canvas} activeLayer={activeLayer} {layerIndex}>
    function create_default_slot_1$9(ctx) {
    	let div;
    	let canvaspreview;
    	let t;
    	let current;

    	canvaspreview = new CanvasPreview({
    			props: {
    				source: /*canvas*/ ctx[4],
    				width: 256,
    				height: 240
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(canvaspreview.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "canvas-preview-wrapper svelte-1xx5how");
    			add_location(div, file$E, 19, 12, 643);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(canvaspreview, div, null);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const canvaspreview_changes = {};
    			if (dirty & /*$layers*/ 1) canvaspreview_changes.source = /*canvas*/ ctx[4];
    			canvaspreview.$set(canvaspreview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(canvaspreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(canvaspreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(canvaspreview);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(19:10) <Layer source={canvas} activeLayer={activeLayer} {layerIndex}>",
    		ctx
    	});

    	return block;
    }

    // (18:8) {#each $layers as canvas, layerIndex}
    function create_each_block$b(ctx) {
    	let layer;
    	let current;

    	layer = new TilemapsLayer({
    			props: {
    				source: /*canvas*/ ctx[4],
    				activeLayer: /*activeLayer*/ ctx[1],
    				layerIndex: /*layerIndex*/ ctx[6],
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(layer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(layer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const layer_changes = {};
    			if (dirty & /*$layers*/ 1) layer_changes.source = /*canvas*/ ctx[4];

    			if (dirty & /*$$scope, $layers*/ 129) {
    				layer_changes.$$scope = { dirty, ctx };
    			}

    			layer.$set(layer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(18:8) {#each $layers as canvas, layerIndex}",
    		ctx
    	});

    	return block;
    }

    // (17:6) {#key $layers}
    function create_key_block$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$layers*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$layers, activeLayer*/ 3) {
    				each_value = /*$layers*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$4.name,
    		type: "key",
    		source: "(17:6) {#key $layers}",
    		ctx
    	});

    	return block;
    }

    // (34:4) <Button on:click={_ => ActionsManager.execute('tilemap_create')}>
    function create_default_slot$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Create tilemap");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(34:4) <Button on:click={_ => ActionsManager.execute('tilemap_create')}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let div2;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div1;
    	let button;
    	let current;
    	const if_block_creators = [create_if_block$d, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$layers*/ ctx[0].length) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "layers svelte-1xx5how");
    			add_location(div0, file$E, 14, 2, 440);
    			attr_dev(div1, "class", "center svelte-1xx5how");
    			add_location(div1, file$E, 32, 2, 927);
    			attr_dev(div2, "class", "palette-layer svelte-1xx5how");
    			add_location(div2, file$E, 12, 0, 407);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let $layers;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TilemapsLayers", slots, []);
    	const { activeLayer, layers } = Tilemaps.stores;
    	validate_store(layers, "layers");
    	component_subscribe($$self, layers, value => $$invalidate(0, $layers = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TilemapsLayers> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => actions.execute("tilemap_create");

    	$$self.$capture_state = () => ({
    		Button,
    		Layer: TilemapsLayer,
    		CanvasPreview,
    		ActionsManager: actions,
    		Tilemaps,
    		activeLayer,
    		layers,
    		$layers
    	});

    	return [$layers, activeLayer, layers, click_handler];
    }

    class TilemapsLayers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TilemapsLayers",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src\_components\graphics\TilemapOptions.svelte generated by Svelte v3.31.2 */
    const file$F = "src\\_components\\graphics\\TilemapOptions.svelte";
    const get_default_slot_changes_1$2 = dirty => ({});
    const get_default_slot_context_1$2 = ctx => ({ slot: "list" });
    const get_default_slot_changes$4 = dirty => ({});
    const get_default_slot_context$4 = ctx => ({ slot: "icon" });

    // (11:4) <slot slot="icon">        <svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 24 24"><path d="M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z"/></svg>      </slot>      <slot slot="list">        <div>          <Button on:click={_ => ActionsManager.execute('tilemap_import')}
    function create_icon_slot$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[0].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$4);
    	const default_slot_or_fallback = default_slot || fallback_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$4, get_default_slot_context$4);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot$2.name,
    		type: "slot",
    		source: "(11:4) <slot slot=\\\"icon\\\">        <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"13\\\" height=\\\"13\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z\\\"/></svg>      </slot>      <slot slot=\\\"list\\\">        <div>          <Button on:click={_ => ActionsManager.execute('tilemap_import')}",
    		ctx
    	});

    	return block;
    }

    // (11:22)         
    function fallback_block_1$2(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z");
    			add_location(path, file$F, 11, 89, 454);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "13");
    			attr_dev(svg, "height", "13");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$F, 11, 6, 371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$2.name,
    		type: "fallback",
    		source: "(11:22)         ",
    		ctx
    	});

    	return block;
    }

    // (16:8) <Button on:click={_ => ActionsManager.execute('tilemap_import')}>
    function create_default_slot_6$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Import tilemap");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(16:8) <Button on:click={_ => ActionsManager.execute('tilemap_import')}>",
    		ctx
    	});

    	return block;
    }

    // (19:8) <Button on:click={_ => ActionsManager.execute('tilemap_export')}>
    function create_default_slot_5$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Export tilemap");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(19:8) <Button on:click={_ => ActionsManager.execute('tilemap_export')}>",
    		ctx
    	});

    	return block;
    }

    // (20:8) <Button on:click={_ => ActionsManager.execute('tilemap_export_nametable')}>
    function create_default_slot_4$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Export nametable");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(20:8) <Button on:click={_ => ActionsManager.execute('tilemap_export_nametable')}>",
    		ctx
    	});

    	return block;
    }

    // (21:8) <Button on:click={_ => ActionsManager.execute('tilemap_export_png')}>
    function create_default_slot_3$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Export PNG");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(21:8) <Button on:click={_ => ActionsManager.execute('tilemap_export_png')}>",
    		ctx
    	});

    	return block;
    }

    // (24:8) <Button variant="danger" on:click={_ => ActionsManager.execute('tilemap_clear')}>
    function create_default_slot_2$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Clear all");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(24:8) <Button variant=\\\"danger\\\" on:click={_ => ActionsManager.execute('tilemap_clear')}>",
    		ctx
    	});

    	return block;
    }

    // (14:4) <slot slot="list">        <div>          <Button on:click={_ => ActionsManager.execute('tilemap_import')}
    function create_list_slot$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[0].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context_1$2);
    	const default_slot_or_fallback = default_slot || fallback_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_default_slot_changes_1$2, get_default_slot_context_1$2);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_list_slot$2.name,
    		type: "slot",
    		source: "(14:4) <slot slot=\\\"list\\\">        <div>          <Button on:click={_ => ActionsManager.execute('tilemap_import')}",
    		ctx
    	});

    	return block;
    }

    // (14:22)         
    function fallback_block$6(ctx) {
    	let div0;
    	let button0;
    	let t0;
    	let div1;
    	let button1;
    	let t1;
    	let button2;
    	let t2;
    	let button3;
    	let t3;
    	let div2;
    	let button4;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[1]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[2]);

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*click_handler_2*/ ctx[3]);

    	button3 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3.$on("click", /*click_handler_3*/ ctx[4]);

    	button4 = new Button({
    			props: {
    				variant: "danger",
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button4.$on("click", /*click_handler_4*/ ctx[5]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    			t2 = space();
    			create_component(button3.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(button4.$$.fragment);
    			add_location(div0, file$F, 14, 6, 1227);
    			add_location(div1, file$F, 17, 6, 1352);
    			add_location(div2, file$F, 22, 6, 1685);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(button0, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(button1, div1, null);
    			append_dev(div1, t1);
    			mount_component(button2, div1, null);
    			append_dev(div1, t2);
    			mount_component(button3, div1, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(button4, div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			const button3_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    			const button4_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button4_changes.$$scope = { dirty, ctx };
    			}

    			button4.$set(button4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			transition_in(button4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			transition_out(button4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(button0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(button1);
    			destroy_component(button2);
    			destroy_component(button3);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			destroy_component(button4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$6.name,
    		type: "fallback",
    		source: "(14:22)         ",
    		ctx
    	});

    	return block;
    }

    // (10:2) <SelectButton>
    function create_default_slot_1$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(10:2) <SelectButton>",
    		ctx
    	});

    	return block;
    }

    // (9:0) <ArtboardOptions on:centerArtboard>
    function create_default_slot$j(ctx) {
    	let selectbutton;
    	let current;

    	selectbutton = new SelectButton({
    			props: {
    				$$slots: {
    					default: [create_default_slot_1$a],
    					list: [create_list_slot$2],
    					icon: [create_icon_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(selectbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(selectbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const selectbutton_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				selectbutton_changes.$$scope = { dirty, ctx };
    			}

    			selectbutton.$set(selectbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(selectbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(9:0) <ArtboardOptions on:centerArtboard>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let artboardoptions;
    	let current;

    	artboardoptions = new ArtboardOptions({
    			props: {
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	artboardoptions.$on("centerArtboard", /*centerArtboard_handler*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(artboardoptions.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(artboardoptions, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const artboardoptions_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				artboardoptions_changes.$$scope = { dirty, ctx };
    			}

    			artboardoptions.$set(artboardoptions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(artboardoptions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(artboardoptions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(artboardoptions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TilemapOptions", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TilemapOptions> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => actions.execute("tilemap_import");
    	const click_handler_1 = _ => actions.execute("tilemap_export");
    	const click_handler_2 = _ => actions.execute("tilemap_export_nametable");
    	const click_handler_3 = _ => actions.execute("tilemap_export_png");
    	const click_handler_4 = _ => actions.execute("tilemap_clear");

    	function centerArtboard_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ActionsManager: actions,
    		SelectButton,
    		Button,
    		ArtboardOptions
    	});

    	return [
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		centerArtboard_handler,
    		$$scope
    	];
    }

    class TilemapOptions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TilemapOptions",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    const Type$1 = Object.freeze({ primary: 1, secondary: 2, move: 3, mouseup: 4 });


    // TODO: this and the spritesheet editor should be refactored out to the same reusable component
    // instead of doing essentially the same thing over and over. queue it for the next major refactor

    class TilemapEditor{
      constructor({ canvas, context, width, height }){
        this.activeLayer = undefined;
        this.activePaletteLayer = undefined;
        this.lastChanged = undefined;

        this.canvas;
        this.context;

        this.width = width;
        this.height = height;

        const fps = 120;
        this.animationLoop = AnimationLoop(this.render.bind(this), fps);
        
        this.events = {};
        this.eventHandler = {};

        const callActionType = (type, e) => {
          e.mouseIsDown = mouseIsDown;
          switch(type){
            case Type$1.primary:
              callEvent('primary', e);
            break;
            case Type$1.secondary:
              callEvent('secondary', e);
            break;
            case Type$1.move:
              callEvent('move', e); 
            break;
            case Type$1.mouseup:
              callEvent('mouseup', e); 
            break;
            default:
              console.log('hmm...');
          }
        };

        // temp to see if mouse pos handles the transform css scale
        function  getMousePos(canvas, evt) {
          if(!canvas) return {x: 0, y: 0};
          const rect = canvas.getBoundingClientRect(), // abs. size of element
            scaleX = canvas.width / rect.width,    // relationship bitmap vs. element for X
            scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for Y
        
          return {
            x: Math.floor((evt.clientX - rect.left) * scaleX),   // scale mouse coordinates after they have
            y: Math.floor((evt.clientY - rect.top) * scaleY)     // been adjusted to be relative to element
          }
        }

        const callEvent = (type, e) => {
          if(this.events[type]){
            e.realMousePosition = getMousePos(this.canvas, e); 
            this.events[type].call(null, e);
          }
        };
        // handle event actions
        let mouseIsDown = false;
        this.eventHandler.mousemove = (e) => {
          callActionType(Type$1.move, e);
        };
        this.eventHandler.mouseup = e => {
          mouseIsDown = false;
          callActionType(Type$1.mouseup, e);
        };
        this.eventHandler.mousedown = (e) => {
          mouseIsDown = true;
          let type;
          if(e.which == 1){
            type = Type$1.primary;
          }else if(e.which == 3){
            type = Type$1.secondary;
          }else {
            return;
          }
          callActionType(type, e);
        };

        // bind events
        document.addEventListener('mousemove', this.eventHandler.mousemove);
        document.addEventListener('mouseup', this.eventHandler.mouseup);
      }

      defineCanvas(canvas){
        this.canvas = canvas;
        this.context = this.canvas.getContext('2d');
        this.canvas.addEventListener('mousedown', this.eventHandler.mousedown);
      }

      on(event, fn){
        if(typeof event != 'string' && typeof fn !== 'function'){
          throw new Error(`Invalid eventlistener`);
        }
        if(this.events[event]){
          throw new Error(`Event already exists : ${event}`);
        }
        this.events[event] = fn;
      }

      // render
      render(args){
        if(!this.canvas) return;
        this.context.clearRect(0,0, 256, 240);
        // const activeSpritesheetLayer = Spritesheets.stores.activeLayer.get();
        const activeTilemapLayer = Tilemaps.stores.activeLayer.get();
        const activePaletteLayer = Palettes.stores.activeLayer.get();
        if(activeTilemapLayer && activePaletteLayer){
          if(this.lastChanged != Palettes.lastChanged.get() || (this.activeLayer != activeTilemapLayer || this.activePaletteLayer != activePaletteLayer)){
            // draw from source
            activeTilemapLayer.drawFromSource(activePaletteLayer);
            // set the current active layers
            this.activeLayer = activeTilemapLayer;
            this.activePaletteLayer = activePaletteLayer;
            // store last change to palettes so we can force an update
            this.lastChanged = Palettes.lastChanged.get();
          }
          // draw active layer on the canvas context
          this.context.drawImage(activeTilemapLayer.element, 0, 0);
        }
      }
      // clean up
      destroy(){
        // stop animationframe
        this.animationLoop.unsubscribe();
        // clean up events
        if(this.canvas){
          this.canvas.removeEventListener('mousedown', this.eventHandler.mousedown);
        }
        document.removeEventListener('mousemove', this.eventHandler.mousemove);
        document.removeEventListener('mouseup', this.eventHandler.mouseup);
      }
    }

    // tools 
    const ToolTypes$1 = new EnumerableList(
      'pointer', 
      'tile', 
    );

    class Cursor$2{
      constructor(props){
        this.icon = '';
        this.offset = {x: 0, y: 0};
        this.size = {width: 11, height: 11};
        this.scale = {x: 1, y: 1};
        Object.assign(this, props);
      }
    }

    class Tool$1{
      constructor(props){
        this.visible_in_toolbar = true;
        this.pixelIndicator = false;
        this.singleAction = false;
      }
      onMount(){}
      onDestroy(){}
      primary(){}
      secondary(){}
      move(){}
      mouseup(){}
      reset(){}
    }

    class Pointer$1 extends Tool$1{
      constructor(){
        super();
        this.title = 'Pointer (V)';
        this.name = 'pointer';
        this.enum = ToolTypes$1.get('pointer');
        this.weight = 100;
        this.icon = 'M4 0l16 12.279-6.78 1.138 4.256 8.676-3.902 1.907-4.281-8.758-5.293 4.581z';
        this.cursor = new Cursor$2({});
      }
      primary(props){}
      secondary(props){}
      move(props){
        console.log('aa');
      }
    }

    // const x = Math.floor(e.realMousePosition.x / 8);

    class Tile extends Tool$1{
      constructor(){
        super();

        // this.hotkeysGroups = ['colorattribute'];
        // const toggleOverlay = HotkeysManager.set(['Tab'], { groups: this.hotkeysGroups });
        // toggleOverlay.on(({ e, Hotkey, on }) => ColorAttributesOverlay.toggle());
        // toggleOverlay.off(({ e, Hotkey, on }) => ColorAttributesOverlay.toggle());

        // this.cursorLayers = [
        //   ColorAttributesOverlay,
        //   // TODO: change tilecursor to be a cursor of the 4 colors 
        //   TileCursor,
        // ];

        this.title = 'Tile (B)';
        this.name = 'tile';
        this.enum = ToolTypes$1.get('tile');
        this.weight = 75;
        this.icon = 'M17.831 7.672c1.096-1.096 2.875-1.865 3.688-3.106.892-1.362.508-3.192-.851-4.085-1.362-.892-3.187-.508-4.081.854-.842 1.286-.801 3.322-1.433 4.779-.817 1.882-3.553 2.116-6.698.474-1.727 3.352-4.075 6.949-6.456 9.874l2.263 1.484c1.018-.174 2.279-1.059 2.792-2.03-.04 1.167-.478 2.2-1.337 2.983l4.275 2.797c.546-.544 1.054-.976 1.616-1.345-.319.643-.532 1.324-.63 1.99l2.532 1.659c1.5-2.884 4.416-7.343 6.455-9.874-2.82-2.272-3.657-4.936-2.135-6.454zm1.762-5.545c.454.296.58.908.281 1.36-.294.457-.905.582-1.356.286-.456-.297-.582-.906-.284-1.36.295-.455.905-.583 1.359-.286zm-3.959 15.037l-8.225-5.386 1.616-2.469 8.221 5.387-1.612 2.468z';
        this.cursor = new Cursor$2({
          icon: 'M17.831 7.672c1.096-1.096 2.875-1.865 3.688-3.106.892-1.362.508-3.192-.851-4.085-1.362-.892-3.187-.508-4.081.854-.842 1.286-.801 3.322-1.433 4.779-.817 1.882-3.553 2.116-6.698.474-1.727 3.352-4.075 6.949-6.456 9.874l2.263 1.484c1.018-.174 2.279-1.059 2.792-2.03-.04 1.167-.478 2.2-1.337 2.983l4.275 2.797c.546-.544 1.054-.976 1.616-1.345-.319.643-.532 1.324-.63 1.99l2.532 1.659c1.5-2.884 4.416-7.343 6.455-9.874-2.82-2.272-3.657-4.936-2.135-6.454zm1.762-5.545c.454.296.58.908.281 1.36-.294.457-.905.582-1.356.286-.456-.297-.582-.906-.284-1.36.295-.455.905-.583 1.359-.286zm-3.959 15.037l-8.225-5.386 1.616-2.469 8.221 5.387-1.612 2.468z',
          size: {
            width: 66,
            height: 66,
          },
          stroke: 1.5 ,
          offset: {
            x: 0, 
            y: 10
          }    
        });


        this.properties = {
          remove: undefined,
          previous: {
            x: undefined, 
            y: undefined
          }
        };
      }

      primary(props){
        let { x, y } = props.realMousePosition;
        if(!(x > 0 && x < 256 && y > 0 && y < 240)) return;
        x = Math.floor(x / 8);
        y = Math.floor(y / 8);
        this.properties.previous.x = x;
        this.properties.previous.y = y;
        this.setTileAtPosition({ x, y });
      }
      secondary(props){
        // let { x, y } = props.realMousePosition;
        // x = Math.floor(x / 8);
        // y = Math.floor(y / 8);
        // this.properties.remove = true;
        // this.setColorAttribute({ x, y });
      }
      setTileAtPosition({ x, y }){
        const activeLayer = Tilemaps.stores.activeLayer.get();
        if(!activeLayer) return;

        const current = Spritesheets.stores.selectedTile.stores.current.get();
        if(!current) return;

        const { x: _x, y: _y } = current;

        activeLayer.data[y][x] = { x: _x, y: _y, uuid: Spritesheets.stores.activeLayer.get().uuid };
        activeLayer.context.drawImage(
          Spritesheets.stores.activeLayer.get().element, 
            // that
            _x * 8, 
            _y * 8,
            8, 
            8,

            // this
            x * 8,
            y * 8,
            8, 
            8
          );
      }
      mouseup(){
        this.properties.remove = undefined;
        const activeLayer = Tilemaps.stores.activeLayer.get();
        if(activeLayer){
          activeLayer.forceUpdate();
        }
      }
      move(props){
        
        let { x, y } = props.realMousePosition;
        // update cursor position
        TileCursor$1.x = x;
        TileCursor$1.y = y;

        if(!props.mouseIsDown) return;

        if(!(x > 0 && x < 256 && y > 0 && y < 240)) return;
        
        x = Math.floor(x / 8);
        y = Math.floor(y / 8);

        if(props.which == 1 || props.which == 3){
          if(!(this.properties.previous.x == x && this.properties.previous.y == y)){
            this.setTileAtPosition({ x, y });
          }
          this.properties.previous.x = x;
          this.properties.previous.y = y;
        }

      }
    }

    const mapped$1 = {
      pointer: new Pointer$1(),
      tile: new Tile(),
    };

    const Toolbar$1 = {
      tools: mapped$1, 
      activeTool: writable$1(undefined, ({ value, store, get }) => {
        return {
          setActive(_enum){
            if(!(_enum instanceof Enum)){
              throw new Error(`Invalid tool`);
            }
            const prev = get();
            if(prev instanceof Tool$1){
              prev.onDestroy();
            }
            const instance = mapped$1[_enum.key];
            const { cursor } = instance;
            // fallback cursor
            let type = 'default';
            // overwrite cursor if one is defined on the tool
            if(cursor && cursor.icon){
              type = `url("data:image/svg+xml,%3Csvg transform='' xmlns='http://www.w3.org/2000/svg' width='${cursor.size.width}' height='${cursor.size.height}' viewBox='0 0 100 100' xml:space='preserve'%3E %3Cpath fill='white' stroke='black' stroke-width='${cursor.stroke || 2}' d='${cursor.icon}'/%3E %3C/svg%3E") ${cursor.offset.x} ${cursor.offset.y}, auto`;
            }
            // set new icon to css variable
            document.documentElement.style.setProperty('--canvas-cursor', type);
            store.set(instance);

            // activate keyboard shortcuts
            if(Array.isArray(instance.hotkeysGroups)){
              // TODO: refactor this so it isn't tied to the spritesheets. We might want tools in other sections
              // but for now this will work
              manager.enableGroups('*', 'tilemaps', ...instance.hotkeysGroups);
            }
          }
        }
      })
    };

    Toolbar$1.activeTool.setActive(ToolTypes$1.get('tile'));

    // tool actions
    const execute$1 = (t, ...args) => {
      if(t){
        t.call(Toolbar$1.activeTool.get(), ...args);
      }
    };

    const primary$1 = (...args) => execute$1(Toolbar$1.activeTool.get()?.primary, ...args);
    const secondary$1 = (...args) => execute$1(Toolbar$1.activeTool.get()?.secondary, ...args);
    const move$1 = (...args) => execute$1(Toolbar$1.activeTool.get()?.move, ...args);
    const mouseup$1 = (...args) => execute$1(Toolbar$1.activeTool.get()?.mouseup, ...args);

    /* src\modules\tilemap_editor\Canvas.svelte generated by Svelte v3.31.2 */

    const file$G = "src\\modules\\tilemap_editor\\Canvas.svelte";

    // (48:0) {:else}
    function create_else_block$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Please select a spritesheet and palette");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(48:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (42:0) {#if $activeLayer && $layers.length && $activePaletteLayer}
    function create_if_block$e(ctx) {
    	let div;
    	let canvas_1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			canvas_1 = element("canvas");
    			if (default_slot) default_slot.c();
    			attr_dev(canvas_1, "width", 256);
    			attr_dev(canvas_1, "height", 240);
    			attr_dev(canvas_1, "class", "svelte-13r9qvw");
    			add_location(canvas_1, file$G, 43, 4, 1063);
    			set_style(div, "--zoom", /*zoom*/ ctx[0]);
    			attr_dev(div, "class", "svelte-13r9qvw");
    			add_location(div, file$G, 42, 2, 1028);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, canvas_1);

    			if (default_slot) {
    				default_slot.m(canvas_1, null);
    			}

    			/*canvas_1_binding*/ ctx[10](canvas_1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*zoom*/ 1) {
    				set_style(div, "--zoom", /*zoom*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*canvas_1_binding*/ ctx[10](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(42:0) {#if $activeLayer && $layers.length && $activePaletteLayer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$e, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$activeLayer*/ ctx[2] && /*$layers*/ ctx[3].length && /*$activePaletteLayer*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $activeLayer;
    	let $layers;
    	let $activePaletteLayer;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Canvas", slots, ['default']);
    	let { zoom } = $$props;
    	const { activeLayer, layers, width, height } = Tilemaps.stores;
    	validate_store(activeLayer, "activeLayer");
    	component_subscribe($$self, activeLayer, value => $$invalidate(2, $activeLayer = value));
    	validate_store(layers, "layers");
    	component_subscribe($$self, layers, value => $$invalidate(3, $layers = value));
    	const activePaletteLayer = Palettes.stores.activeLayer;
    	validate_store(activePaletteLayer, "activePaletteLayer");
    	component_subscribe($$self, activePaletteLayer, value => $$invalidate(4, $activePaletteLayer = value));
    	let canvas;
    	let editor = new TilemapEditor({ width: 256, height: 240 });

    	// bind events
    	editor.on("primary", e => primary$1(e));

    	editor.on("secondary", e => secondary$1(e));
    	editor.on("move", e => move$1(e));
    	editor.on("mouseup", e => mouseup$1(e));

    	onMount(() => {
    		// clean up
    		return () => {
    			if (editor) {
    				editor.destroy();
    			}
    		};
    	});

    	const writable_props = ["zoom"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Canvas> was created with unknown prop '${key}'`);
    	});

    	function canvas_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			canvas = $$value;
    			$$invalidate(1, canvas);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Palettes,
    		Tilemaps,
    		TilemapEditor,
    		primary: primary$1,
    		secondary: secondary$1,
    		move: move$1,
    		mouseup: mouseup$1,
    		zoom,
    		activeLayer,
    		layers,
    		width,
    		height,
    		activePaletteLayer,
    		canvas,
    		editor,
    		$activeLayer,
    		$layers,
    		$activePaletteLayer
    	});

    	$$self.$inject_state = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    		if ("canvas" in $$props) $$invalidate(1, canvas = $$props.canvas);
    		if ("editor" in $$props) $$invalidate(13, editor = $$props.editor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*canvas*/ 2) {
    			 if (canvas) {
    				// editor
    				editor.defineCanvas(canvas);
    			}
    		}
    	};

    	return [
    		zoom,
    		canvas,
    		$activeLayer,
    		$layers,
    		$activePaletteLayer,
    		activeLayer,
    		layers,
    		activePaletteLayer,
    		$$scope,
    		slots,
    		canvas_1_binding
    	];
    }

    class Canvas$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, { zoom: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Canvas",
    			options,
    			id: create_fragment$N.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*zoom*/ ctx[0] === undefined && !("zoom" in props)) {
    			console.warn("<Canvas> was created without expected prop 'zoom'");
    		}
    	}

    	get zoom() {
    		throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoom(value) {
    		throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\modules\tilemap_editor\TilemapEditor.svelte generated by Svelte v3.31.2 */

    function create_fragment$O(ctx) {
    	let canvas;
    	let current;

    	canvas = new Canvas$1({
    			props: { zoom: /*zoom*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(canvas.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(canvas, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const canvas_changes = {};
    			if (dirty & /*zoom*/ 1) canvas_changes.zoom = /*zoom*/ ctx[0];
    			canvas.$set(canvas_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(canvas.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(canvas.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(canvas, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TilemapEditor", slots, []);
    	let { zoom } = $$props;
    	const writable_props = ["zoom"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TilemapEditor> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    	};

    	$$self.$capture_state = () => ({ Canvas: Canvas$1, zoom });

    	$$self.$inject_state = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zoom];
    }

    class TilemapEditor$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, { zoom: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TilemapEditor",
    			options,
    			id: create_fragment$O.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*zoom*/ ctx[0] === undefined && !("zoom" in props)) {
    			console.warn("<TilemapEditor> was created without expected prop 'zoom'");
    		}
    	}

    	get zoom() {
    		throw new Error("<TilemapEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zoom(value) {
    		throw new Error("<TilemapEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_views\graphics\Tilemaps.svelte generated by Svelte v3.31.2 */
    const file$H = "src\\_views\\graphics\\Tilemaps.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i];
    	return child_ctx;
    }

    // (52:4) <Artboard on:artboardScrollEvent={changeZoomLevel}>
    function create_default_slot_1$b(ctx) {
    	let tilemapeditor;
    	let current;

    	tilemapeditor = new TilemapEditor$1({
    			props: { zoom: /*zoom*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tilemapeditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tilemapeditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tilemapeditor_changes = {};
    			if (dirty[0] & /*zoom*/ 1) tilemapeditor_changes.zoom = /*zoom*/ ctx[0];
    			tilemapeditor.$set(tilemapeditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tilemapeditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tilemapeditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tilemapeditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(52:4) <Artboard on:artboardScrollEvent={changeZoomLevel}>",
    		ctx
    	});

    	return block;
    }

    // (62:10) {:else}
    function create_else_block$9(ctx) {
    	let option;

    	const block = {
    		c: function create() {
    			option = element("option");
    			option.textContent = "oh noo!";
    			option.__value = "oh noo!";
    			option.value = option.__value;
    			add_location(option, file$H, 62, 12, 2804);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(62:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:10) {#each $SpritesetsLayers as layer}
    function create_each_block_2$1(ctx) {
    	let option;
    	let t_value = /*layer*/ ctx[28].label + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*layer*/ ctx[28];
    			option.value = option.__value;
    			add_location(option, file$H, 60, 12, 2727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$SpritesetsLayers*/ 4 && t_value !== (t_value = /*layer*/ ctx[28].label + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$SpritesetsLayers*/ 4 && option_value_value !== (option_value_value = /*layer*/ ctx[28])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(60:10) {#each $SpritesetsLayers as layer}",
    		ctx
    	});

    	return block;
    }

    // (59:8) <Select bind:value={selectedSpritesheet} on:change={selectSpritesheet}>
    function create_default_slot$k(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*$SpritesetsLayers*/ ctx[2];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let each_1_else = null;

    	if (!each_value_2.length) {
    		each_1_else = create_else_block$9(ctx);
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();

    			if (each_1_else) {
    				each_1_else.c();
    			}
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$SpritesetsLayers*/ 4) {
    				each_value_2 = /*$SpritesetsLayers*/ ctx[2];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;

    				if (each_value_2.length) {
    					if (each_1_else) {
    						each_1_else.d(1);
    						each_1_else = null;
    					}
    				} else if (!each_1_else) {
    					each_1_else = create_else_block$9(ctx);
    					each_1_else.c();
    					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			if (each_1_else) each_1_else.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(59:8) <Select bind:value={selectedSpritesheet} on:change={selectSpritesheet}>",
    		ctx
    	});

    	return block;
    }

    // (69:6) {#if $SpritesheetsActiveLayer}
    function create_if_block$f(ctx) {
    	let previous_key = /*$activeImage*/ ctx[4];
    	let key_block_anchor;
    	let key_block = create_key_block$5(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$activeImage*/ 16 && safe_not_equal(previous_key, previous_key = /*$activeImage*/ ctx[4])) {
    				key_block.d(1);
    				key_block = create_key_block$5(ctx);
    				key_block.c();
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(69:6) {#if $SpritesheetsActiveLayer}",
    		ctx
    	});

    	return block;
    }

    // (72:12) {#each yl as b}
    function create_each_block_1$2(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[15](/*b*/ ctx[25], /*a*/ ctx[22], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "tile-image svelte-on0f2o");
    			set_style(div, "--src", "url(" + /*$SpritesheetsActiveLayer*/ ctx[3].image.src + ")");
    			set_style(div, "--x", /*a*/ ctx[22] + 1);
    			set_style(div, "--y", /*b*/ ctx[25] + 1);
    			toggle_class(div, "active", /*$current*/ ctx[5]?.x == 15 - /*b*/ ctx[25] && /*$current*/ ctx[5]?.y == 15 - /*a*/ ctx[22] && /*$SpritesheetsActiveLayer*/ ctx[3] == /*$current*/ ctx[5].ref);
    			add_location(div, file$H, 72, 14, 3063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$SpritesheetsActiveLayer*/ 8) {
    				set_style(div, "--src", "url(" + /*$SpritesheetsActiveLayer*/ ctx[3].image.src + ")");
    			}

    			if (dirty[0] & /*$current, yl, xl, $SpritesheetsActiveLayer*/ 6184) {
    				toggle_class(div, "active", /*$current*/ ctx[5]?.x == 15 - /*b*/ ctx[25] && /*$current*/ ctx[5]?.y == 15 - /*a*/ ctx[22] && /*$SpritesheetsActiveLayer*/ ctx[3] == /*$current*/ ctx[5].ref);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(72:12) {#each yl as b}",
    		ctx
    	});

    	return block;
    }

    // (71:10) {#each xl as a}
    function create_each_block$c(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*yl*/ ctx[12];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$SpritesheetsActiveLayer, xl, yl, $current*/ 6184) {
    				each_value_1 = /*yl*/ ctx[12];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(71:10) {#each xl as a}",
    		ctx
    	});

    	return block;
    }

    // (70:8) {#key $activeImage}
    function create_key_block$5(ctx) {
    	let each_1_anchor;
    	let each_value = /*xl*/ ctx[11];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*yl, $SpritesheetsActiveLayer, xl, $current*/ 6184) {
    				each_value = /*xl*/ ctx[11];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$5.name,
    		type: "key",
    		source: "(70:8) {#key $activeImage}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let section1;
    	let div0;
    	let t0;
    	let div1;
    	let tilemapoptions;
    	let t1;
    	let artboard;
    	let t2;
    	let section0;
    	let header;
    	let div2;
    	let select;
    	let updating_value;
    	let t3;
    	let div3;
    	let t4;
    	let section2;
    	let tilemapslayers;
    	let t5;
    	let section3;
    	let palettelayers;
    	let current;
    	tilemapoptions = new TilemapOptions({ $$inline: true });
    	tilemapoptions.$on("centerArtboard", centerScrollAndCanvas);

    	artboard = new Artboard({
    			props: {
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	artboard.$on("artboardScrollEvent", /*changeZoomLevel*/ ctx[10]);

    	function select_value_binding(value) {
    		/*select_value_binding*/ ctx[14].call(null, value);
    	}

    	let select_props = {
    		$$slots: { default: [create_default_slot$k] },
    		$$scope: { ctx }
    	};

    	if (/*selectedSpritesheet*/ ctx[1] !== void 0) {
    		select_props.value = /*selectedSpritesheet*/ ctx[1];
    	}

    	select = new Select({ props: select_props, $$inline: true });
    	binding_callbacks.push(() => bind(select, "value", select_value_binding));
    	select.$on("change", /*selectSpritesheet*/ ctx[13]);
    	let if_block = /*$SpritesheetsActiveLayer*/ ctx[3] && create_if_block$f(ctx);
    	tilemapslayers = new TilemapsLayers({ $$inline: true });

    	palettelayers = new PaletteLayers({
    			props: { showEditButtons: false },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section1 = element("section");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			create_component(tilemapoptions.$$.fragment);
    			t1 = space();
    			create_component(artboard.$$.fragment);
    			t2 = space();
    			section0 = element("section");
    			header = element("header");
    			div2 = element("div");
    			create_component(select.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			if (if_block) if_block.c();
    			t4 = space();
    			section2 = element("section");
    			create_component(tilemapslayers.$$.fragment);
    			t5 = space();
    			section3 = element("section");
    			create_component(palettelayers.$$.fragment);
    			add_location(div0, file$H, 48, 2, 2307);
    			attr_dev(div1, "class", "inner-artboard svelte-on0f2o");
    			add_location(div1, file$H, 49, 2, 2322);
    			add_location(div2, file$H, 57, 6, 2581);
    			attr_dev(header, "class", "svelte-on0f2o");
    			add_location(header, file$H, 56, 4, 2565);
    			attr_dev(div3, "class", "tile-grid svelte-on0f2o");
    			add_location(div3, file$H, 67, 4, 2901);
    			attr_dev(section0, "class", "tiles svelte-on0f2o");
    			add_location(section0, file$H, 55, 2, 2536);
    			attr_dev(section1, "class", "main-artboard svelte-on0f2o");
    			add_location(section1, file$H, 46, 0, 2221);
    			attr_dev(section2, "class", "spritesheets-layer svelte-on0f2o");
    			add_location(section2, file$H, 81, 0, 3521);
    			attr_dev(section3, "class", "palettes-layer svelte-on0f2o");
    			add_location(section3, file$H, 85, 0, 3595);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div0);
    			append_dev(section1, t0);
    			append_dev(section1, div1);
    			mount_component(tilemapoptions, div1, null);
    			append_dev(div1, t1);
    			mount_component(artboard, div1, null);
    			append_dev(section1, t2);
    			append_dev(section1, section0);
    			append_dev(section0, header);
    			append_dev(header, div2);
    			mount_component(select, div2, null);
    			append_dev(section0, t3);
    			append_dev(section0, div3);
    			if (if_block) if_block.m(div3, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, section2, anchor);
    			mount_component(tilemapslayers, section2, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, section3, anchor);
    			mount_component(palettelayers, section3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const artboard_changes = {};

    			if (dirty[0] & /*zoom*/ 1 | dirty[1] & /*$$scope*/ 1) {
    				artboard_changes.$$scope = { dirty, ctx };
    			}

    			artboard.$set(artboard_changes);
    			const select_changes = {};

    			if (dirty[0] & /*$SpritesetsLayers*/ 4 | dirty[1] & /*$$scope*/ 1) {
    				select_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty[0] & /*selectedSpritesheet*/ 2) {
    				updating_value = true;
    				select_changes.value = /*selectedSpritesheet*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			select.$set(select_changes);

    			if (/*$SpritesheetsActiveLayer*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tilemapoptions.$$.fragment, local);
    			transition_in(artboard.$$.fragment, local);
    			transition_in(select.$$.fragment, local);
    			transition_in(tilemapslayers.$$.fragment, local);
    			transition_in(palettelayers.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tilemapoptions.$$.fragment, local);
    			transition_out(artboard.$$.fragment, local);
    			transition_out(select.$$.fragment, local);
    			transition_out(tilemapslayers.$$.fragment, local);
    			transition_out(palettelayers.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section1);
    			destroy_component(tilemapoptions);
    			destroy_component(artboard);
    			destroy_component(select);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(section2);
    			destroy_component(tilemapslayers);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(section3);
    			destroy_component(palettelayers);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let $SpritesetsLayers;
    	let $SpritesheetsActiveLayer;
    	let $activeImage;
    	let $current;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tilemaps", slots, []);
    	const { current, fallback } = Spritesheets.stores.selectedTile.stores;
    	validate_store(current, "current");
    	component_subscribe($$self, current, value => $$invalidate(5, $current = value));

    	// TODO: breakout activeImage from spritesets and on to spritesheets instead
    	const { layers, activeLayer } = Tilemaps.stores;

    	const { activeLayer: SpritesheetsActiveLayer, selectedTile } = Spritesheets.stores;
    	validate_store(SpritesheetsActiveLayer, "SpritesheetsActiveLayer");
    	component_subscribe($$self, SpritesheetsActiveLayer, value => $$invalidate(3, $SpritesheetsActiveLayer = value));
    	const { layers: SpritesetsLayers, activeLayer: SpritesetsActiveLayer, activeImage } = Spritesets.stores;
    	validate_store(SpritesetsLayers, "SpritesetsLayers");
    	component_subscribe($$self, SpritesetsLayers, value => $$invalidate(2, $SpritesetsLayers = value));
    	validate_store(activeImage, "activeImage");
    	component_subscribe($$self, activeImage, value => $$invalidate(4, $activeImage = value));

    	// this should be refactored to be an action 
    	let zoom = 2;

    	const changeZoomLevel = e => {
    		// TODO: find out the x,y of the cursor position and update the canvas origin
    		// so it zooms where the cursor is located. will perhaps give a nicer feel
    		// update zoom
    		$$invalidate(0, zoom = Math.max(1, zoom + (zoom - e.detail.deltaY > 0 ? 1 : -1)));
    	};

    	// NOTE: Keyed each is running the each block in reverse (probably a side effect due to it can become modified mid loop and it needs to keep track of it)
    	// so to combat that we reverse it, but the coordinates then gets reversed. Simply subract 15 (16 counting with 0, length/height of the spritesheet)
    	// so thats why there are a and b - 15 in the dom.
    	const generateLoop = (n = 16) => new Array(n).fill(null).map((_, i) => i).reverse();

    	let xl = [...generateLoop()];
    	let yl = [...generateLoop()];
    	let selectedSpritesheet;

    	const selectSpritesheet = e => {
    		actions.execute("spritesheet_make_layer_active", selectedSpritesheet);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tilemaps> was created with unknown prop '${key}'`);
    	});

    	function select_value_binding(value) {
    		selectedSpritesheet = value;
    		$$invalidate(1, selectedSpritesheet);
    	}

    	const click_handler = (b, a, _) => actions.execute("spritesheet_set_selected_tile", {
    		x: 15 - b,
    		y: 15 - a,
    		ref: $SpritesheetsActiveLayer
    	});

    	$$self.$capture_state = () => ({
    		Artboard,
    		centerScrollAndCanvas,
    		TilemapsLayers,
    		PaletteLayers,
    		TilemapOptions,
    		TilemapEditor: TilemapEditor$1,
    		ActionsManager: actions,
    		Tilemaps,
    		Spritesets,
    		Spritesheets,
    		Select,
    		current,
    		fallback,
    		layers,
    		activeLayer,
    		SpritesheetsActiveLayer,
    		selectedTile,
    		SpritesetsLayers,
    		SpritesetsActiveLayer,
    		activeImage,
    		zoom,
    		changeZoomLevel,
    		generateLoop,
    		xl,
    		yl,
    		selectedSpritesheet,
    		selectSpritesheet,
    		$SpritesetsLayers,
    		$SpritesheetsActiveLayer,
    		$activeImage,
    		$current
    	});

    	$$self.$inject_state = $$props => {
    		if ("zoom" in $$props) $$invalidate(0, zoom = $$props.zoom);
    		if ("xl" in $$props) $$invalidate(11, xl = $$props.xl);
    		if ("yl" in $$props) $$invalidate(12, yl = $$props.yl);
    		if ("selectedSpritesheet" in $$props) $$invalidate(1, selectedSpritesheet = $$props.selectedSpritesheet);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		zoom,
    		selectedSpritesheet,
    		$SpritesetsLayers,
    		$SpritesheetsActiveLayer,
    		$activeImage,
    		$current,
    		current,
    		SpritesheetsActiveLayer,
    		SpritesetsLayers,
    		activeImage,
    		changeZoomLevel,
    		xl,
    		yl,
    		selectSpritesheet,
    		select_value_binding,
    		click_handler
    	];
    }

    class Tilemaps_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tilemaps_1",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    // sections 
    const spritesheets = decorator(Spritesheets$2);
    spritesheets('/graphics', _ => navigate('/graphics/spritesheets'));
      // catch all /gfx/:section subroutes
    spritesheets('/graphics/spritesheets', (req, res) => {
      // send the component to the view
      try{
        // enable the right shortcuts group for this page
        const activeTool = Toolbar.activeTool.get().hotkeysGroups ?? []; 
        manager.enableGroups('*', 'spritesheets', ...activeTool);
        res.send(Spritesheets_1);
      }catch(error){
        res.error();
      }
    });

    // palettes section
    const palettes = decorator(Palettes$1);
    // catch all /gfx/:section subroutes
    palettes('/graphics/palettes', (req, res) => {
      // send the component to the view
      try{
        // enable the right shortcuts group for this page
        manager.enableGroups('*', 'palettes');
        res.send(Palettes_1);
      }catch(error){
        res.error();
      }
    });

    // spritesets section
    const spritesets = decorator(Spritesheets$2);
    // catch all /gfx/:section subroutes
    spritesets('/graphics/spritesets', (req, res) => {
      // send the component to the view
      try{
        // enable the right shortcuts group for this page
        manager.enableGroups('*', 'spritesheets');
        res.send(Spritesets_1);
      }catch(error){
        res.error();
      }
    });


    // tilemaps section
    const tilemaps = decorator(Tilemaps$1);
    // catch all /gfx/:section subroutes
    tilemaps('/graphics/tilemaps', (req, res) => {
      // send the component to the view
      try{
        // enable the right shortcuts group for this page
        manager.enableGroups('*', 'tilemaps');
        res.send(Tilemaps_1);
      }catch(error){
        res.error();
      }
    });

    /* src\_singles\buttons\ExternalLinkButton.svelte generated by Svelte v3.31.2 */
    const file$I = "src\\_singles\\buttons\\ExternalLinkButton.svelte";

    // (7:0) {:else}
    function create_else_block$a(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
    	let button_levels = [/*$$props*/ ctx[1]];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$I, 7, 2, 223);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*click_handler_1*/ ctx[5]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [dirty & /*$$props*/ 2 && /*$$props*/ ctx[1]]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(7:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (5:0) {#if !globalThis.electron}
    function create_if_block$g(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
    	let button_levels = [/*$$props*/ ctx[1]];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$I, 5, 2, 140);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [dirty & /*$$props*/ 2 && /*$$props*/ ctx[1]]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(5:0) {#if !globalThis.electron}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$g, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!globalThis.electron) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type();
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ExternalLinkButton", slots, ['default']);
    	const { href } = $$props;
    	const click_handler = _ => window.open(href);
    	const click_handler_1 = _ => actions.execute("external_link", href);

    	$$self.$$set = $$new_props => {
    		$$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ ActionsManager: actions, href });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(1, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [href, $$props, $$scope, slots, click_handler, click_handler_1];
    }

    class ExternalLinkButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExternalLinkButton",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src\_views\Support.svelte generated by Svelte v3.31.2 */
    const file$J = "src\\_views\\Support.svelte";

    // (23:0) <ExternalLink href="https://www.paypal.com/donate?hosted_button_id=N7CCZ2K5L2GV6">
    function create_default_slot_2$7(ctx) {
    	let form;
    	let input0;
    	let t0;
    	let input1;
    	let input1_src_value;
    	let t1;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			form = element("form");
    			input0 = element("input");
    			t0 = space();
    			input1 = element("input");
    			t1 = space();
    			img = element("img");
    			attr_dev(input0, "type", "hidden");
    			attr_dev(input0, "name", "hosted_button_id");
    			input0.value = "N7CCZ2K5L2GV6";
    			add_location(input0, file$J, 24, 4, 1271);
    			attr_dev(input1, "type", "image");
    			if (input1.src !== (input1_src_value = "https://www.paypalobjects.com/en_US/SE/i/btn/btn_donateCC_LG.gif")) attr_dev(input1, "src", input1_src_value);
    			attr_dev(input1, "border", "0");
    			attr_dev(input1, "name", "submit");
    			attr_dev(input1, "title", "PayPal - The safer, easier way to pay online!");
    			attr_dev(input1, "alt", "Donate with PayPal button");
    			add_location(input1, file$J, 25, 4, 1346);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "border", "0");
    			if (img.src !== (img_src_value = "https://www.paypal.com/en_SE/i/scr/pixel.gif")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "1");
    			attr_dev(img, "height", "1");
    			add_location(img, file$J, 26, 4, 1556);
    			attr_dev(form, "action", "https://www.paypal.com/donate");
    			attr_dev(form, "method", "post");
    			attr_dev(form, "target", "_top");
    			add_location(form, file$J, 23, 2, 1192);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, input0);
    			append_dev(form, t0);
    			append_dev(form, input1);
    			append_dev(form, t1);
    			append_dev(form, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(23:0) <ExternalLink href=\\\"https://www.paypal.com/donate?hosted_button_id=N7CCZ2K5L2GV6\\\">",
    		ctx
    	});

    	return block;
    }

    // (31:2) <ExternalLink href="https://www.paypal.com/donate?hosted_button_id=N7CCZ2K5L2GV6">
    function create_default_slot_1$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("https://www.paypal.com/donate?hosted_button_id=N7CCZ2K5L2GV6");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(31:2) <ExternalLink href=\\\"https://www.paypal.com/donate?hosted_button_id=N7CCZ2K5L2GV6\\\">",
    		ctx
    	});

    	return block;
    }

    // (40:2) <ExternalLink href="https://discord.gg/7mCVKnkjHc">
    function create_default_slot$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("https://discord.gg/7mCVKnkjHc");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(40:2) <ExternalLink href=\\\"https://discord.gg/7mCVKnkjHc\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let h2;
    	let t1;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let h40;
    	let t7;
    	let p2;
    	let t9;
    	let h41;
    	let t11;
    	let externallink0;
    	let t12;
    	let p3;
    	let externallink1;
    	let t13;
    	let p4;
    	let img;
    	let img_src_value;
    	let t14;
    	let h42;
    	let t16;
    	let p5;
    	let t17;
    	let br;
    	let t18;
    	let externallink2;
    	let current;

    	externallink0 = new ExternalLinkButton({
    			props: {
    				href: "https://www.paypal.com/donate?hosted_button_id=N7CCZ2K5L2GV6",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	externallink1 = new ExternalLinkButton({
    			props: {
    				href: "https://www.paypal.com/donate?hosted_button_id=N7CCZ2K5L2GV6",
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	externallink2 = new ExternalLinkButton({
    			props: {
    				href: "https://discord.gg/7mCVKnkjHc",
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Hey!";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Welcome to the online version of NESBit Studio. This application is a toolkit to help the development of homebrew NES games.";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "A lot of time and effort has already gone in to making this project, however it's still very much in an alpha stage. \r\n  At this time most of the work is being focused on the spritesheet editor. And until the application reaches a stable beta point this \r\n  project will continue to only live online.";
    			t5 = space();
    			h40 = element("h4");
    			h40.textContent = "Breaking changes";
    			t7 = space();
    			p2 = element("p");
    			p2.textContent = "Sometimes there are major changes which will break imports and project files. At the state it's currently in there is no major benefit to cater \r\n  to backwards compatability, from a developers standpoint. But since all source data is JSON encoded it should be a simple fix if you know what's changed internally. \r\n  If that happends, feel free to get in touch with me over discord and I'll do my best to help you out.";
    			t9 = space();
    			h41 = element("h4");
    			h41.textContent = "Support this project";
    			t11 = space();
    			create_component(externallink0.$$.fragment);
    			t12 = space();
    			p3 = element("p");
    			create_component(externallink1.$$.fragment);
    			t13 = space();
    			p4 = element("p");
    			img = element("img");
    			t14 = space();
    			h42 = element("h4");
    			h42.textContent = "Join discord";
    			t16 = space();
    			p5 = element("p");
    			t17 = text("Join the discord server for project updates, help or show off what you have been working on.");
    			br = element("br");
    			t18 = space();
    			create_component(externallink2.$$.fragment);
    			add_location(h2, file$J, 5, 0, 146);
    			add_location(p0, file$J, 6, 0, 161);
    			add_location(p1, file$J, 8, 0, 296);
    			add_location(h40, file$J, 14, 0, 613);
    			add_location(p2, file$J, 15, 0, 640);
    			add_location(h41, file$J, 21, 0, 1075);
    			add_location(p3, file$J, 29, 0, 1683);
    			if (img.src !== (img_src_value = "" + (subDir + "/assets/images/paypal-qr-code.png"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$J, 33, 2, 1862);
    			add_location(p4, file$J, 32, 0, 1855);
    			add_location(h42, file$J, 36, 0, 1932);
    			add_location(br, file$J, 38, 94, 2054);
    			add_location(p5, file$J, 37, 0, 1955);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, h40, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h41, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(externallink0, target, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, p3, anchor);
    			mount_component(externallink1, p3, null);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, p4, anchor);
    			append_dev(p4, img);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, h42, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, p5, anchor);
    			append_dev(p5, t17);
    			append_dev(p5, br);
    			append_dev(p5, t18);
    			mount_component(externallink2, p5, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const externallink0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				externallink0_changes.$$scope = { dirty, ctx };
    			}

    			externallink0.$set(externallink0_changes);
    			const externallink1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				externallink1_changes.$$scope = { dirty, ctx };
    			}

    			externallink1.$set(externallink1_changes);
    			const externallink2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				externallink2_changes.$$scope = { dirty, ctx };
    			}

    			externallink2.$set(externallink2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(externallink0.$$.fragment, local);
    			transition_in(externallink1.$$.fragment, local);
    			transition_in(externallink2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(externallink0.$$.fragment, local);
    			transition_out(externallink1.$$.fragment, local);
    			transition_out(externallink2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(h40);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h41);
    			if (detaching) detach_dev(t11);
    			destroy_component(externallink0, detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(p3);
    			destroy_component(externallink1);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(h42);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(p5);
    			destroy_component(externallink2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Support", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Support> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ ExternalLink: ExternalLinkButton, subDir });
    	return [];
    }

    class Support extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Support",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* src\_decorators\_Article.svelte generated by Svelte v3.31.2 */

    const file$K = "src\\_decorators\\_Article.svelte";

    function create_fragment$S(ctx) {
    	let section;
    	let div;
    	let article;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div = element("div");
    			article = element("article");
    			if (default_slot) default_slot.c();
    			attr_dev(article, "class", "svelte-w8jbub");
    			add_location(article, file$K, 2, 4, 66);
    			attr_dev(div, "class", "content svelte-w8jbub");
    			add_location(div, file$K, 1, 2, 39);
    			attr_dev(section, "class", "article checkered");
    			add_location(section, file$K, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div);
    			append_dev(div, article);

    			if (default_slot) {
    				default_slot.m(article, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Article", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Article> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Article extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Article",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    // home
    app.get('/', (req, res) => {});

    // 
    const article = decorator(Article);

    article('/support', (req, res) => {
      try{
        res.send(Support);
      }catch(error){
        res.error();
      }
    });

    // global commands
    // toggle fullscreen on f11 and altleft + enter combo. 
    manager.set(['F11'], { data: { action: actions.action('window_toggle_fullscreen') } });
    manager.set(['Altleft', 'Enter'], { data: { action: actions.action('window_toggle_fullscreen') } });

    // project
    manager.set(['ControlLeft', 'KeyS'], { data: { action: actions.action('project_save') } });

    // build
    manager.set(['F5'], { data: { action: actions.action('project_build_run') } });
    manager.set(['F6'], { data: { action: actions.action('project_run') } });
    manager.set(['F7'], { data: { action: actions.action('project_build') } });

    // manager.set(['enter_trigger_keys'], { data: { action: ActionsManager.action('graphics_center_artboard') } });

    const groups = ['palettes'];
    // global commands
    // toggle fullscreen on f11 and altleft + enter combo. 
    manager.set(['insert'], { data: { action: actions.action('palette_create') }, groups });
    manager.set(['ControlLeft', 'KeyD'], { data: { action: actions.action('palette_clone_active_layer') }, groups });

    // update active layers name
    manager.set(['f2'], { data: { action: actions.action('palette_focus_rename_active_layer') }, groups });

    // special cases since in elctron if a dialog is spawned the keyup event never triggers. so for some events it has to 
    // be handled manually where the dialog modal gets focus on the screen
    const _import = manager.set(['ControlLeft','KeyI'], { data: { action: actions.action('palette_import') }, groups });
    _import.on((args) => executeCommand(args));
    const _export = manager.set(['ControlLeft', 'KeyE'], { data: { action: actions.action('palette_export') }, groups });
    _export.on((args) => executeCommand(args));

    const groups$1 = ['*'];
    // special cases since in elctron if a dialog is spawned the keyup event never triggers. so for some events it has to 
    // be handled manually where the dialog modal gets focus on the screen
    const open$1 = manager.set(['ControlLeft', 'KeyO'], { data: { action: actions.action('project_open') }, groups: groups$1 });
    open$1.on((args) => executeCommand(args));

    // register to groups
    const groups$2 = ['spritesheets'];

    // global commands
    // toggle fullscreen on f11 and altleft + enter combo. 
    manager.set(['insert'], { data: { action: actions.action('spritesheet_create')}, groups: groups$2 });
    manager.set(['ControlLeft', 'KeyD'], { data: { action: actions.action('spritesheet_clone_active_layer') }, groups: groups$2 });

    manager.set(['ControlLeft', 'KeyZ'], { data: { action: actions.action('spritesheet_undo') }, groups: groups$2 });
    manager.set(['ControlLeft', 'ShiftLeft', 'KeyZ'], { data: { action: actions.action('spritesheet_redo') }, groups: groups$2 });
    manager.set(['ControlLeft', 'KeyY'], { data: { action: actions.action('spritesheet_redo') }, groups: groups$2 });

    // update active layers name
    manager.set(['f2'], { data: { action: actions.action('spritesheet_focus_rename_active_layer')}, groups: groups$2 });

    // special cases since in elctron if a dialog is spawned the keyup event never triggers. so for some events it has to 
    // be handled manually where the dialog modal gets focus on the screen
    const _import$1 = manager.set(['ControlLeft','KeyI'], { data: {action: actions.action('spritesheet_import')}, groups: groups$2 });
    _import$1.on((args) => executeCommand(args));
    const _export$1 = manager.set(['ControlLeft', 'KeyE'], { data: {action: actions.action('spritesheet_export')}, groups: groups$2 });
    _export$1.on((args) => executeCommand(args));

    // set active color
    manager.set(['Digit1'], { data: {action: actions.action('palette_active_color'), props: 0}, groups: groups$2 });
    manager.set(['Digit2'], { data: {action: actions.action('palette_active_color'), props: 1}, groups: groups$2 });
    manager.set(['Digit3'], { data: {action: actions.action('palette_active_color'), props: 2}, groups: groups$2 });
    manager.set(['Digit4'], { data: {action: actions.action('palette_active_color'), props: 3}, groups: groups$2 });

    // zoom
    manager.set(['NumpadAdd'], { data: {action: actions.action('spritesheet_zoom_in')}, groups: groups$2 });
    manager.set(['NumpadSubtract'], { data: {action: actions.action('spritesheet_zoom_out')}, groups: groups$2 });
    manager.set(['Numpad0'], { data: {action: actions.action('spritesheet_zoom_reset')}, groups: groups$2 });

    // toolbar
    manager.set(['KeyV'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'pointer'}, groups: groups$2 });
    manager.set(['KeyB'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'pen'}, groups: groups$2 });
    manager.set(['KeyG'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'paintbucket'}, groups: groups$2 });
    manager.set(['KeyA'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'colorattribute'}, groups: groups$2 });
    manager.set(['KeyE'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'eyedropper'}, groups: groups$2 });
    manager.set(['KeyP'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'preview'}, groups: groups$2 });
    manager.set(['KeyS'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'colorswap'}, groups: groups$2 });
    manager.set(['KeyT'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'tileswap'}, groups: groups$2 });
    manager.set(['KeyR'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'transform'}, groups: groups$2 });
    manager.set(['KeyM'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'marquee'}, groups: groups$2 });
    manager.set(['KeyD'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'brush'}, groups: groups$2 });
    manager.set(['KeyZ'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'zoom'}, groups: groups$2 });
    manager.set(['KeyL'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'line'}, groups: groups$2 });
    manager.set(['KeyC'], { data: {action: actions.action('spritesheet_set_active_tool'), props: 'circle'}, groups: groups$2 });
    // manager.set(['KeyW'], { data: {action: ActionsManager.action('spritesheet_set_active_tool'), props: 'text'}, groups });

    // we need to handle some preprocessing or atleast make a plugin 
    // that transforms the source to serialized json string
    // import demo from '../../demo_project/demo.nesbitproject';

    if(application.isDev){
      actions.execute('spritesheet_set_active_tool', 'pointer');
      if(globalThis.electron){
        const projectPath = 'C:/Users/jensa/Development/project/applications/NESBitStudio/demo_project/demo.nesbitproject';
        actions.execute('project_open', projectPath);
      }
    }

    if(application.initWithDemoProject && !globalThis.electron){
      Project.open(undefined, `
  {"project":{"path":"","version":3},"spritesheets":{"version":3,"data":{"spritesheets":{"layers":[{"label":"demo","data":[[[[0,0,0,1,1,3,3,3],[0,0,0,1,1,3,3,3],[0,0,0,0,1,3,0,0],[0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,1]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,1,2,2,2,1,1],[0,1,2,2,1,1,3,3],[0,1,2,1,2,1,3,3]],[[0,0,0,1,1,3,3,3],[0,0,0,1,1,3,3,3],[0,0,0,0,1,3,0,0],[0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,1]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,1,2,2,2,1,1],[0,1,2,2,1,1,3,3],[0,1,2,1,2,1,3,3]],[[0,0,0,1,1,3,3,3],[0,0,0,1,1,3,3,3],[0,0,0,0,1,3,0,0],[0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,1]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,1,2,2,2,1,1],[0,1,2,2,1,1,3,3],[0,1,2,1,2,1,3,3]],[[0,0,0,1,1,3,3,3],[0,0,0,1,1,3,3,3],[0,0,0,0,1,3,0,0],[0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,1]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,1,2,2,2,1,1],[0,1,2,2,1,1,3,3],[0,1,2,1,2,1,3,3]]],[[[3,3,0,0,0,0,1,2],[3,3,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,2,1,1,3,3],[0,1,1,1,1,3,3,3],[0,1,1,1,3,3,3,3],[0,1,1,3,3,3,0,0],[0,0,1,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[3,3,0,0,0,0,1,2],[3,3,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,2,1,1,3,3],[0,1,1,1,1,3,3,3],[0,1,1,1,3,3,3,3],[0,1,1,3,3,3,0,0],[0,0,1,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[3,3,0,0,0,0,1,2],[3,3,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,2,1,1,3,3],[0,1,1,1,1,3,3,3],[0,1,1,1,3,3,3,3],[0,1,1,3,3,3,0,0],[0,0,1,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[3,3,0,0,0,0,1,2],[3,3,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,2,1,1,3,3],[0,1,1,1,1,3,3,3],[0,1,1,1,3,3,3,3],[0,1,1,3,3,3,0,0],[0,0,1,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[2,2,0,0,0,1,1,2],[2,2,2,0,0,1,1,1],[2,2,1,0,0,1,1,1],[2,1,3,0,0,0,1,1],[1,3,3,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,0,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,0,0,0,0],[3,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[0,0,0,0,0,1,1,2],[0,0,0,0,0,1,1,1],[0,0,0,0,0,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,2],[1,3,0,0,0,0,2,2],[3,3,0,0,0,1,2,2],[3,3,0,0,1,2,2,2],[3,0,0,0,1,2,2,2],[3,0,0,0,1,1,2,1]]],[[[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,1,2,2,2,2,2],[0,1,1,1,2,1,1,1],[0,1,1,1,1,3,3,3]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[2,0,0,0,1,2,2,2],[2,2,0,0,1,2,2,1],[1,1,0,0,1,1,1,3],[3,3,0,0,1,1,1,3],[3,3,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[0,0,0,0,1,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,1,1,1,3],[0,0,0,0,1,1,3,3],[0,0,0,0,1,1,3,3],[0,0,0,0,0,1,3,3],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]]],[[[0,0,0,1,1,3,3,3],[0,0,0,1,1,3,3,3],[0,0,0,0,1,3,0,0],[0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,1]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,1,2,2,2,1,1],[0,1,2,2,1,1,3,3],[0,1,2,1,2,1,3,3]]],[[[3,3,0,0,0,0,1,2],[3,3,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,1,1,2,1],[0,0,1,0,3,3,2,2],[0,0,1,0,0,2,3,2],[0,0,2,0,0,0,2,3],[0,0,1,0,0,0,0,2],[0,0,2,0,0,1,0,2],[0,0,2,2,0,3,3,2]],[[0,0,0,0,0,0,0,0],[2,2,2,2,2,3,0,0],[2,2,2,3,3,0,3,0],[2,2,3,2,0,0,3,0],[2,3,2,0,0,0,3,0],[2,2,0,0,0,0,3,0],[2,2,0,1,0,0,3,0],[2,2,3,3,0,3,3,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,1,1],[0,0,0,0,1,1,2,2],[0,0,0,0,2,2,2,2],[0,0,1,0,0,2,3,2],[0,0,1,0,0,0,2,3],[0,1,2,0,0,0,0,2],[0,1,2,0,0,1,0,2],[0,2,2,2,0,3,3,2]],[[1,1,1,0,0,0,0,0],[2,3,3,3,3,0,0,0],[2,2,2,3,3,0,0,0],[2,2,3,2,0,0,3,0],[2,3,2,0,0,0,3,0],[2,2,0,0,0,0,3,3],[2,2,0,1,0,0,3,3],[2,2,3,3,0,3,3,3]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,1,2],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,2,1,1,3,3],[0,1,1,1,1,3,3,3],[0,1,1,1,3,3,3,3],[0,1,1,3,3,3,0,0],[0,0,1,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[2,2,0,0,0,1,1,2],[2,2,2,0,0,1,1,1],[2,2,1,0,0,1,1,1],[2,1,3,0,0,0,1,1],[1,3,3,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,0,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,0,0,0,0],[3,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,2,2,2,0,0,3],[0,0,2,0,0,1,0,0],[0,0,2,2,0,1,0,0],[0,0,2,2,2,2,1,0],[0,0,2,2,2,2,2,2],[0,0,0,2,2,2,2,3],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,3,0,0,3,3,3,0],[2,0,0,1,0,0,3,0],[1,0,0,1,0,3,3,0],[1,0,1,2,2,3,3,0],[2,2,2,3,3,3,3,0],[3,3,3,3,3,3,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,2,2,2,0,0,3],[0,2,2,0,0,1,0,0],[0,0,2,3,0,1,0,0],[0,0,2,2,3,3,1,0],[0,0,0,2,2,2,3,3],[0,0,0,0,2,2,2,2],[0,0,0,0,0,0,3,3],[0,0,0,0,0,0,0,0]],[[2,3,0,0,3,3,3,3],[2,0,0,1,0,0,3,3],[1,0,0,1,0,3,3,0],[1,0,1,3,2,3,3,0],[3,3,3,2,3,3,0,0],[2,2,2,3,3,0,0,0],[3,3,3,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[0,0,0,0,0,1,1,2],[0,0,0,0,0,1,1,1],[0,0,0,0,0,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,2],[1,3,0,0,0,0,2,2],[3,3,0,0,0,1,2,2],[3,3,0,0,1,2,2,2],[3,0,0,0,1,2,2,2],[3,0,0,0,1,1,2,1]]],[[[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,1,2,2,2,2,2],[0,1,1,1,2,1,1,1],[0,1,1,1,1,3,3,3]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[2,0,0,0,1,2,2,2],[2,2,0,0,1,2,2,1],[1,1,0,0,1,1,1,3],[3,3,0,0,1,1,1,3],[3,3,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]],[[0,0,3,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,2,0,0,0,0],[0,2,2,2,0,0,0,0],[0,2,2,1,2,0,0,0],[3,2,1,1,3,0,0,0],[3,3,1,1,3,3,0,0],[0,3,3,3,3,0,0,0]],[[0,0,0,1,1,1,3,1],[0,0,3,0,1,0,0,0],[0,0,0,0,1,0,2,2],[0,0,0,0,1,0,0,2],[0,0,0,1,0,0,0,2],[0,0,0,1,0,0,0,2],[0,0,0,0,0,0,2,2],[0,0,0,0,2,2,2,3]],[[3,3,1,1,1,1,0,0],[0,0,0,0,1,0,3,0],[3,3,3,0,1,0,0,0],[2,3,0,0,0,1,0,0],[2,3,0,0,0,1,0,0],[2,3,0,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,1,1,3,1,0,0,0]],[[0,0,3,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,2,0,0,0,0],[0,2,2,2,0,0,0,0],[0,2,2,1,2,0,0,0],[3,2,1,1,3,0,0,0],[3,3,1,1,3,3,0,0],[0,3,3,3,3,0,0,0]],[[0,0,0,0,0,3,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,2,0,0,0],[0,0,0,0,2,2,2,0],[0,0,0,2,1,2,2,0],[0,0,0,3,1,1,2,3],[0,0,3,3,1,1,3,3],[0,0,0,3,3,3,3,0]],[[0,0,0,1,3,3,3,3],[0,0,3,0,1,0,0,0],[0,0,0,0,1,0,2,2],[0,0,0,0,1,0,0,2],[0,0,0,1,0,0,0,2],[0,0,0,1,0,0,0,2],[0,0,0,0,0,0,2,2],[0,0,0,0,2,2,2,3]],[[3,1,3,1,1,3,0,0],[0,0,0,0,1,0,3,0],[3,3,3,0,1,0,0,0],[2,3,0,0,0,1,0,0],[2,3,0,0,0,1,0,0],[2,3,0,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,1,1,3,1,0,0,0]],[[0,0,0,0,0,3,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,2,0,0,0],[0,0,0,0,2,2,2,0],[0,0,0,2,1,2,2,0],[0,0,0,3,1,1,2,3],[0,0,3,3,1,1,3,3],[0,0,0,3,3,3,3,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[0,0,0,0,1,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,1,1,1,3],[0,0,0,0,1,1,3,3],[0,0,0,0,1,1,3,3],[0,0,0,0,0,1,3,3],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]]],[[[0,0,0,1,1,3,3,3],[0,0,0,1,1,3,3,3],[0,0,0,0,1,3,0,0],[0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,1]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,1,2,2,2,1,1],[0,1,2,2,1,1,3,3],[0,1,2,1,2,1,3,3]]],[[[3,3,0,0,0,0,1,2],[3,3,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,1,1,1,1,1,1],[0,1,1,0,0,1,0,0],[0,1,0,1,1,1,0,1],[0,1,1,0,0,1,0,0],[0,1,1,1,1,0,0,1],[0,1,0,0,0,1,0,0],[0,3,1,1,1,1,1,1],[0,0,3,3,3,3,3,3]],[[1,1,1,1,1,1,1,1],[1,0,1,1,0,0,1,1],[1,0,1,1,0,1,1,0],[1,0,1,1,0,0,1,0],[1,0,1,1,0,1,1,0],[1,0,0,1,0,0,1,1],[1,1,1,1,1,1,1,1],[3,3,3,3,3,3,3,3]],[[1,1,1,1,1,1,0,0],[0,1,0,0,0,1,1,0],[1,1,1,0,1,1,1,0],[1,1,1,0,1,1,1,0],[1,1,1,0,1,1,1,0],[0,0,1,0,1,1,1,0],[1,1,1,1,1,1,3,0],[3,3,3,3,3,3,0,0]],[[0,0,2,2,2,2,2,2],[0,2,2,1,1,2,1,1],[0,2,1,2,2,2,2,1],[0,2,2,1,1,2,2,1],[0,2,2,2,2,1,2,1],[0,2,1,1,1,2,2,1],[0,3,2,2,2,2,2,2],[0,0,3,3,3,3,3,3]],[[2,2,2,2,2,2,2,2],[1,2,2,1,2,2,1,1],[2,2,1,2,1,2,1,2],[2,2,1,2,1,2,1,1],[2,2,1,1,1,2,1,2],[2,2,1,2,1,2,1,2],[2,2,2,2,2,2,2,2],[3,3,3,3,3,3,3,3]],[[2,2,2,2,2,2,0,0],[2,2,1,1,1,2,2,0],[1,2,2,1,2,2,2,0],[2,2,2,1,2,2,2,0],[1,2,2,1,2,2,2,0],[1,2,2,1,2,2,2,0],[2,2,2,2,2,2,3,0],[3,3,3,3,3,3,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,1,2],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,2,1,1,3,3],[0,1,1,1,1,3,3,3],[0,1,1,1,3,3,3,3],[0,1,1,3,3,3,0,0],[0,0,1,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[2,2,0,0,0,1,1,2],[2,2,2,0,0,1,1,1],[2,2,1,0,0,1,1,1],[2,1,3,0,0,0,1,1],[1,3,3,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,0,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,0,0,0,0],[3,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,1,1,1,1,0,0],[0,3,1,1,1,3,0,0],[0,0,3,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[0,0,0,0,0,1,1,2],[0,0,0,0,0,1,1,1],[0,0,0,0,0,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,2],[1,3,0,0,0,0,2,2],[3,3,0,0,0,1,2,2],[3,3,0,0,1,2,2,2],[3,0,0,0,1,2,2,2],[3,0,0,0,1,1,2,1]]],[[[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,1,2,2,2,2,2],[0,1,1,1,2,1,1,1],[0,1,1,1,1,3,3,3]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[2,0,0,0,1,2,2,2],[2,2,0,0,1,2,2,1],[1,1,0,0,1,1,1,3],[3,3,0,0,1,1,1,3],[3,3,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,2,2,2,0,0,0],[0,2,0,2,0,2,0,0],[2,0,2,0,2,0,2,0],[2,0,2,0,0,0,2,0],[2,0,2,0,2,0,2,0],[0,2,0,2,0,2,0,0],[0,0,2,2,2,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,2,2,0,0,0,2,0],[0,0,0,2,0,2,0,2],[0,0,2,0,0,2,0,2],[0,2,0,0,0,2,0,2],[0,2,2,2,0,0,2,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,2,2,0,0,0,2,0],[0,0,0,2,0,2,2,0],[0,0,2,0,0,0,2,0],[0,2,0,0,0,0,2,0],[0,2,2,2,0,0,2,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[0,0,0,0,1,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,1,1,1,3],[0,0,0,0,1,1,3,3],[0,0,0,0,1,1,3,3],[0,0,0,0,0,1,3,3],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]]],[[[0,0,0,1,1,3,3,3],[0,0,0,1,1,3,3,3],[0,0,0,0,1,3,0,0],[0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,1]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,1,2,2,2,1,1],[0,1,2,2,1,1,3,3],[0,1,2,1,2,1,3,3]]],[[[3,3,0,0,0,0,1,2],[3,3,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,1,2],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,2,1,1,3,3],[0,1,1,1,1,3,3,3],[0,1,1,1,3,3,3,3],[0,1,1,3,3,3,0,0],[0,0,1,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[2,2,0,0,0,1,1,2],[2,2,2,0,0,1,1,1],[2,2,1,0,0,1,1,1],[2,1,3,0,0,0,1,1],[1,3,3,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,2],[1,3,0,0,0,0,2,2],[3,3,0,0,0,1,2,2],[3,3,0,0,1,2,2,2],[3,0,0,0,1,2,2,2],[3,0,0,0,1,1,2,1]],[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[2,2,0,0,0,1,1,2],[2,2,2,0,0,1,1,1],[2,2,1,0,0,1,1,1],[2,1,3,0,0,0,1,1],[1,3,3,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,2],[1,3,0,0,0,0,2,2],[3,3,0,0,0,1,2,2],[3,3,0,0,1,2,2,2],[3,0,0,0,1,2,2,2],[3,0,0,0,1,1,2,1]],[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[2,2,0,0,0,1,1,2],[2,2,2,0,0,1,1,1],[2,2,1,0,0,1,1,1],[2,1,3,0,0,0,1,1],[1,3,3,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,2],[1,3,0,0,0,0,2,2],[3,3,0,0,0,1,2,2],[3,3,0,0,1,2,2,2],[3,0,0,0,1,2,2,2],[3,0,0,0,1,1,2,1]],[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[2,2,0,0,0,1,1,2],[2,2,2,0,0,1,1,1],[2,2,1,0,0,1,1,1],[2,1,3,0,0,0,1,1],[1,3,3,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,2],[1,3,0,0,0,0,2,2],[3,3,0,0,0,1,2,2],[3,3,0,0,1,2,2,2],[3,0,0,0,1,2,2,2],[3,0,0,0,1,1,2,1]]],[[[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,1,2,2,2,2,2],[0,1,1,1,2,1,1,1],[0,1,1,1,1,3,3,3]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[2,0,0,0,1,2,2,2],[2,2,0,0,1,2,2,1],[1,1,0,0,1,1,1,3],[3,3,0,0,1,1,1,3],[3,3,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,1,1,1,3],[0,0,0,0,1,1,3,3],[0,0,0,0,1,1,3,3],[0,0,0,0,0,1,3,3],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]],[[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,1,2,2,2,2,2],[0,1,1,1,2,1,1,1],[0,1,1,1,1,3,3,3]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[2,0,0,0,1,2,2,2],[2,2,0,0,1,2,2,1],[1,1,0,0,1,1,1,3],[3,3,0,0,1,1,1,3],[3,3,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,1,1,1,3],[0,0,0,0,1,1,3,3],[0,0,0,0,1,1,3,3],[0,0,0,0,0,1,3,3],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]],[[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,1,2,2,2,2,2],[0,1,1,1,2,1,1,1],[0,1,1,1,1,3,3,3]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[2,0,0,0,1,2,2,2],[2,2,0,0,1,2,2,1],[1,1,0,0,1,1,1,3],[3,3,0,0,1,1,1,3],[3,3,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,1,1,1,3],[0,0,0,0,1,1,3,3],[0,0,0,0,1,1,3,3],[0,0,0,0,0,1,3,3],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]],[[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,1,2,2,2,2,2],[0,1,1,1,2,1,1,1],[0,1,1,1,1,3,3,3]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[2,0,0,0,1,2,2,2],[2,2,0,0,1,2,2,1],[1,1,0,0,1,1,1,3],[3,3,0,0,1,1,1,3],[3,3,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,1,1,1,3],[0,0,0,0,1,1,3,3],[0,0,0,0,1,1,3,3],[0,0,0,0,0,1,3,3],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]]]],"colorAttributes":[[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,null,null,{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},null,null,null,null,null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,null,null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_1","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"30","rgb":[252,252,252]},{"hex":"10","rgb":[188,188,188]},{"hex":"00","rgb":[124,124,124]}],"uuid":1614402310360.6956},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,null,null,{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,{"label":"palette_1","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"30","rgb":[252,252,252]},{"hex":"10","rgb":[188,188,188]},{"hex":"00","rgb":[124,124,124]}],"uuid":1614402310360.6956},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,null,null,{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,{"label":"palette_1","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"30","rgb":[252,252,252]},{"hex":"10","rgb":[188,188,188]},{"hex":"00","rgb":[124,124,124]}],"uuid":1614402310360.6956},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,null,null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,null,null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},null,null,null,{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444},null,null,null,null,null,{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}],[{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212}]],"uuid":1614406256124.4043},{"label":"tiles","data":[[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,3,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,2,0,0,0,0],[0,0,2,2,0,0,0,0],[0,2,2,1,2,0,0,0],[3,2,1,1,3,0,0,0],[3,3,1,1,3,3,0,0],[0,3,3,3,3,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,1,1,3,3,3],[0,0,0,1,1,3,3,3],[0,0,0,0,1,3,0,0],[0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[1,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,3,0,0,0,0,1]],[[3,0,0,0,0,0,0,0],[0,0,0,0,0,2,2,2],[0,0,0,0,2,2,2,2],[0,0,0,0,1,2,2,1],[0,0,0,0,1,1,1,3],[0,0,0,0,0,1,3,3],[2,2,2,0,0,0,3,3],[2,2,1,3,0,0,0,0]],[[0,0,0,1,1,2,1,2],[0,0,0,1,2,1,2,1],[2,0,0,1,1,2,1,3],[1,0,0,1,1,1,3,3],[3,0,0,0,1,1,3,0],[3,0,0,0,0,1,3,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[1,3,3,3,0,0,0,0],[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[0,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,1,2,2,2,1,1],[0,1,2,2,1,1,3,3],[0,1,2,1,2,1,3,3]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,1,1,1,2,1],[0,0,1,0,3,3,2,2],[0,0,1,0,0,2,3,2],[0,0,2,0,0,0,2,3],[0,0,1,0,0,0,0,2],[0,0,2,0,0,1,0,2],[0,0,2,2,0,3,3,2]],[[0,0,0,0,0,0,0,0],[2,2,2,2,2,3,0,0],[2,2,2,3,3,0,3,0],[2,2,3,2,0,0,3,0],[2,3,2,0,0,0,3,0],[2,2,0,0,0,0,3,0],[2,2,0,1,0,0,3,0],[2,2,3,3,0,3,3,0]],[[0,0,0,0,0,0,1,1],[0,0,0,0,1,1,2,2],[0,0,0,0,2,2,2,2],[0,0,1,0,0,2,3,2],[0,0,1,0,0,0,2,3],[0,1,2,0,0,0,0,2],[0,1,2,0,0,1,0,2],[0,2,2,2,0,3,3,2]],[[1,1,1,0,0,0,0,0],[2,3,3,3,3,0,0,0],[2,2,2,3,3,0,0,0],[2,2,3,2,0,0,3,0],[2,3,2,0,0,0,3,0],[2,2,0,0,0,0,3,3],[2,2,0,1,0,0,3,3],[2,2,3,3,0,3,3,3]],[[3,3,0,0,0,0,1,2],[3,3,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0],[1,1,3,3,0,0,0,1],[1,3,3,3,0,0,1,2],[3,3,3,0,0,0,1,1],[3,3,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,2,2,2,2,2,0,0],[2,2,2,2,2,2,2,0],[2,2,2,2,2,1,1,0],[2,2,1,1,1,3,3,0],[1,1,3,3,3,3,0,0],[1,3,3,3,3,3,0,0],[1,3,3,3,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,2,1,1,3,3],[0,1,1,1,1,3,3,3],[0,1,1,1,3,3,3,3],[0,1,1,3,3,3,0,0],[0,0,1,3,3,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,2,2,2,0,0,3],[0,0,2,0,0,1,0,0],[0,0,2,2,0,1,0,0],[0,0,2,2,2,2,1,0],[0,0,2,2,2,2,2,2],[0,0,0,2,2,2,2,3],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[2,3,0,0,3,3,3,0],[2,0,0,1,0,0,3,0],[1,0,0,1,0,3,3,0],[1,0,1,2,2,3,3,0],[2,2,2,3,3,3,3,0],[3,3,3,3,3,3,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,2,2,2,0,0,3],[0,2,2,0,0,1,0,0],[0,0,2,3,0,1,0,0],[0,0,2,2,3,3,1,0],[0,0,0,2,2,2,3,3],[0,0,0,0,2,2,2,2],[0,0,0,0,0,0,3,3],[0,0,0,0,0,0,0,0]],[[2,3,0,0,3,3,3,3],[2,0,0,1,0,0,3,3],[1,0,0,1,0,3,3,0],[1,0,1,3,2,3,3,0],[3,3,3,2,3,3,0,0],[2,2,2,3,3,0,0,0],[3,3,3,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,2],[0,0,0,0,0,0,1,2],[0,0,0,0,0,1,2,2],[2,2,0,0,0,1,1,2],[2,2,2,0,0,1,1,1],[2,2,1,0,0,1,1,1],[2,1,3,0,0,0,1,1],[1,3,3,0,0,0,0,1]],[[2,2,2,2,0,0,0,0],[2,2,2,2,1,0,0,0],[2,1,2,1,3,0,0,0],[1,2,1,3,3,0,0,0],[2,1,1,3,3,0,0,0],[1,1,3,3,0,0,0,0],[1,3,3,3,0,0,0,0],[1,3,3,0,0,0,0,0]],[[0,0,0,0,0,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,2,2,2,2,2,2],[1,2,2,2,2,2,2,1],[1,2,2,1,2,1,2,1],[1,1,1,2,1,2,1,3],[1,1,1,1,2,1,3,3]],[[2,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0],[2,1,0,0,0,0,0,2],[1,3,0,0,0,0,2,2],[3,3,0,0,0,1,2,2],[3,3,0,0,1,2,2,2],[3,0,0,0,1,2,2,2],[3,0,0,0,1,1,2,1]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,1,1,1,3,1],[0,0,3,0,1,0,0,0],[0,0,0,0,1,0,2,2],[0,0,0,0,1,0,0,2],[0,0,0,1,0,0,0,2],[0,0,0,1,0,0,0,2],[0,0,0,0,0,0,2,2],[0,0,0,0,2,2,2,3]],[[3,3,1,1,1,1,0,0],[0,0,0,0,1,0,3,0],[3,3,3,0,1,0,0,0],[2,3,0,0,0,1,0,0],[2,3,0,0,0,1,0,0],[2,3,0,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,1,1,3,1,0,0,0]],[[0,0,0,1,3,3,3,3],[0,0,3,0,1,0,0,0],[0,0,0,0,1,0,2,2],[0,0,0,0,1,0,0,2],[0,0,0,1,0,0,0,2],[0,0,0,1,0,0,0,2],[0,0,0,0,0,0,2,2],[0,0,0,0,2,2,2,3]],[[3,1,3,1,1,3,0,0],[0,0,0,0,1,0,3,0],[3,3,3,0,1,0,0,0],[2,3,0,0,0,1,0,0],[2,3,0,0,0,1,0,0],[2,3,0,0,0,0,0,0],[3,3,3,0,0,0,0,0],[3,1,1,3,1,0,0,0]],[[3,3,3,0,0,0,0,0],[3,3,0,0,0,0,0,0],[3,0,0,0,2,2,2,2],[0,0,0,2,2,2,2,2],[0,0,2,2,2,2,2,2],[0,1,1,2,2,2,2,2],[0,1,1,1,2,1,1,1],[0,1,1,1,1,3,3,3]],[[1,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,2,2],[2,0,0,0,1,2,2,2],[2,2,0,0,1,2,2,1],[1,1,0,0,1,1,1,3],[3,3,0,0,1,1,1,3],[3,3,0,0,0,1,3,3]],[[0,1,1,1,1,3,3,3],[0,0,1,1,3,3,3,3],[0,0,0,1,3,3,0,0],[1,0,0,0,0,0,0,0],[3,3,0,0,0,0,0,2],[3,3,0,0,0,0,2,2],[3,3,0,0,0,2,2,2],[3,0,0,0,1,2,2,2]],[[3,0,0,0,1,1,1,3],[0,0,0,0,1,1,3,3],[0,0,0,0,1,1,3,3],[0,0,0,0,0,1,3,3],[2,2,0,0,0,0,0,0],[2,2,1,0,0,0,0,0],[2,2,1,3,0,0,0,0],[2,1,3,3,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]]],"colorAttributes":[[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]],"uuid":1614231872893.8706},{"label":"font","data":[[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,1,1,0,1,1,0,0],[0,1,1,0,1,1,0,0],[0,1,0,0,1,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,0,0,1,0,0],[0,1,1,1,1,1,1,0],[0,0,1,0,0,1,0,0],[0,0,1,0,0,1,0,0],[0,1,1,1,1,1,1,0],[0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,1,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,1,0,1,0],[0,0,1,1,1,0,0,0],[0,0,0,0,1,1,1,0],[0,1,1,0,1,0,1,1],[0,0,1,1,1,1,1,0],[0,0,0,0,1,0,0,0]],[[0,0,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[1,0,1,0,1,0,0,0],[0,1,0,0,1,0,0,0],[0,0,0,1,0,0,1,0],[0,0,0,1,0,1,0,1],[0,0,1,0,0,0,1,0],[0,0,1,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,1,0,1,1,0,0],[0,0,1,1,1,0,0,0],[0,1,1,1,1,0,1,0],[0,1,1,0,1,1,0,0],[0,0,1,1,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0]],[[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,1,0,1,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,1,0,1,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,1,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,1,1,1,0],[0,1,1,1,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,1,1,0],[0,0,0,0,1,1,0,0],[0,0,1,1,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,1,0,0],[0,1,1,0,1,1,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,1,0],[0,0,0,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,1,1,1,0,0],[0,0,1,0,0,0,1,0],[0,1,0,1,1,1,0,1],[1,0,1,0,0,1,0,1],[1,0,1,0,0,1,0,1],[0,1,0,1,1,0,1,0],[0,0,1,0,0,0,0,0],[0,0,0,1,1,1,1,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,1,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,1,0,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,0,0,0],[0,1,1,0,1,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,0,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,1,1,0,0],[0,1,1,0,1,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,1,1,0,0],[0,1,1,1,1,0,0,0],[0,1,1,1,1,0,0,0],[0,1,1,0,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[1,0,0,0,0,0,1,0],[1,1,0,0,0,1,1,0],[1,1,1,0,1,1,1,0],[1,1,1,1,1,1,1,0],[1,1,0,1,0,1,1,0],[1,1,0,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,1,0,1,1,0],[0,1,1,1,1,1,1,0],[0,1,1,0,1,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,0,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,1,1,0,0],[0,0,1,1,0,1,0,1],[0,0,0,0,0,0,1,1]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,1,1,0,0],[0,1,1,1,1,0,0,0],[0,1,1,0,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,1,1,0,0,0,0],[0,0,0,0,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,0,0,1,0,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[1,1,0,0,0,0,1,1],[1,1,0,1,1,0,1,1],[0,1,0,1,1,0,1,0],[0,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,0],[0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,1,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,1,0,0]],[[0,0,1,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,1,0]],[[0,0,1,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,1,0,0,0]],[[0,0,0,0,1,0,0,0],[0,0,0,1,1,1,0,0],[0,0,1,1,0,1,1,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0]]],[[[0,0,0,0,1,1,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,1,1,0],[0,0,1,1,1,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,0,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,1,0],[0,0,0,0,0,1,1,0],[0,0,1,1,1,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,0,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,0,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,1,1,0],[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,0,1,0],[0,0,1,1,1,1,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,1,1,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,1,1,0,0],[0,1,1,0,1,1,0,0],[0,0,1,1,1,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,1,1,0,0],[0,1,1,1,1,0,0,0],[0,1,1,0,1,1,0,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[1,0,1,0,1,1,0,0],[1,1,1,1,1,1,1,0],[1,1,0,1,0,1,1,0],[1,1,0,1,0,1,1,0],[1,1,0,1,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,1,0],[0,0,0,0,0,1,1,0],[0,0,0,0,0,1,1,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,0,1,1,0,0],[0,1,1,1,0,1,1,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,1,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,1,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,1,1,1,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,1,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,0,1,1,1,0],[0,0,1,1,1,0,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,0,0,1,0,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[1,1,0,0,0,1,1,0],[1,1,0,1,0,1,1,0],[1,1,1,1,1,1,1,0],[0,1,1,0,1,1,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,0,1,1,0],[0,0,0,1,1,1,0,0],[0,0,0,0,1,1,0,0],[0,0,1,1,1,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,1,0,0]],[[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,1,0,1,1,0,1,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,1,1,1,0,0,0],[0,1,0,1,0,1,0,0],[1,0,1,0,1,0,1,0],[1,0,1,0,0,0,1,0],[1,0,1,0,1,0,1,0],[0,1,0,1,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,1,0,1,0,0],[0,0,0,1,0,1,0,0],[0,0,1,0,1,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,0,1,0,0,0],[0,1,1,1,1,1,0,0],[0,0,1,0,1,0,0,0],[0,0,1,0,1,0,0,0],[0,1,1,1,1,1,0,0],[0,0,1,0,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,1,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,1,0,1,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,1,0,0,0],[0,1,0,1,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,1,0,0,0,0]],[[0,1,0,0,0,0,0,0],[1,0,1,0,1,0,0,0],[0,1,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,1,0,0,0],[0,1,0,1,0,1,0,0],[0,0,0,0,1,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,0,1,0,1,0,0],[0,1,0,0,1,0,0,0],[0,0,1,1,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0]],[[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,1,0,1,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,1,0,1,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,1,1,0,0],[0,1,0,1,0,1,0,0],[0,1,0,1,0,1,0,0],[0,1,1,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,1,1,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,1,0,0,0],[0,1,0,0,1,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,0,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,1,1,1,0,0],[0,0,1,0,0,0,1,0],[0,1,0,1,1,1,0,1],[1,0,1,0,0,1,0,1],[1,0,1,0,0,1,0,1],[0,1,0,1,1,0,1,0],[0,0,1,0,0,0,0,0],[0,0,0,1,1,1,1,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,1,1,1,1,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,0,0,0,0],[0,1,0,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,0,0,0],[0,1,0,1,1,1,0,0],[0,1,0,0,1,1,0,0],[0,0,1,1,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,1,1,1,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,1,0,0,1,0,0,0],[0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,1,0,0,0],[0,1,0,1,0,0,0,0],[0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0],[0,1,0,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[1,0,0,0,0,0,1,0],[1,1,0,0,0,1,1,0],[1,0,1,0,1,0,1,0],[1,0,0,1,0,0,1,0],[1,0,0,0,0,0,1,0],[1,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,1,0,0,1,0,0],[0,1,0,1,0,1,0,0],[0,1,0,0,1,1,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,1,0,0,0],[0,0,1,1,0,1,0,1],[0,0,0,0,0,0,1,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,1,0,0,0],[0,1,1,1,0,0,0,0],[0,1,0,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,0,0,0,0],[0,0,0,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,0,1,0,0,0],[0,0,1,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[1,0,0,0,0,0,1,0],[1,0,0,1,0,0,1,0],[1,0,1,1,1,0,1,0],[0,1,1,0,1,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,0,1,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,1,1,1,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,1,1,0,0]],[[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,1,0]],[[0,0,1,1,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,1,1,1,0,0,0]],[[0,0,0,1,0,0,0,0],[0,0,1,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0]]],[[[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,1,0,0],[0,0,1,1,1,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,1,0,0,1,0,0],[0,1,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0],[0,0,1,1,1,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0],[0,0,0,1,0,0,0,0],[0,0,1,1,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,1,1,1,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,1,0,0,1,0,0,0],[0,0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,1,0,0,0],[0,1,1,1,0,0,0,0],[0,1,0,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[1,1,1,0,1,1,0,0],[1,0,0,1,0,0,1,0],[1,0,0,1,0,0,1,0],[1,0,0,1,0,0,1,0],[1,0,0,1,0,0,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,1,1,0,0,0],[0,1,1,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,1,1,0,0,0],[0,1,1,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,1,1,1,0,0,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,1,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,0,1,0,0,0],[0,0,1,1,0,1,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,1,0,0],[0,1,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,1,1,0,0],[0,0,1,1,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,0,1,0,0,0],[0,0,1,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[1,0,0,0,0,0,1,0],[1,0,0,1,0,0,1,0],[1,0,1,1,1,0,1,0],[0,1,1,0,1,1,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,0,1,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,1,0,0,0],[0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,0,0,1,0,0],[0,1,0,0,0,1,0,0],[0,0,1,0,0,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,1,1,1,1,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0]],[[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[0,1,0,1,1,0,1,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,1,1,1,0,0,0],[0,1,0,1,0,1,0,0],[1,0,1,0,1,0,1,0],[1,0,1,0,0,0,1,0],[1,0,1,0,1,0,1,0],[0,1,0,1,0,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,1,1,1,1,1],[0,0,1,0,0,1,0,0],[0,1,0,1,1,1,0,1],[0,1,1,0,0,1,0,0],[0,1,1,1,1,0,0,1],[0,1,0,0,0,1,0,0],[0,0,1,1,1,1,1,1],[0,0,0,1,1,1,1,1]],[[1,1,1,1,1,1,1,1],[1,0,1,1,0,0,1,1],[1,0,1,1,0,1,1,0],[1,0,1,1,0,0,1,0],[1,0,1,1,0,1,1,0],[1,0,0,1,0,0,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1]],[[1,1,1,1,1,0,0,0],[0,1,0,0,0,1,0,0],[1,1,1,0,1,1,1,0],[1,1,1,0,1,1,1,0],[1,1,1,0,1,1,1,0],[0,0,1,0,1,1,1,0],[1,1,1,1,1,1,0,0],[1,1,1,1,1,0,0,0]],[[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[1,1,0,1,1,0,1,1],[1,1,0,1,1,0,1,1],[1,1,0,0,0,0,1,1],[1,1,0,1,1,0,1,1],[0,1,0,1,1,0,1,0],[0,0,1,1,1,1,0,0]],[[0,0,0,1,0,0,0,0],[0,0,1,1,1,0,0,0],[0,0,1,1,1,0,0,0],[0,1,1,1,1,1,0,0],[0,1,1,1,1,1,0,0],[1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[0,1,1,1,1,1,0,0],[0,1,1,1,1,1,0,0],[0,0,1,1,1,0,0,0],[0,0,1,1,1,0,0,0],[0,0,0,1,0,0,0,0]],[[0,0,0,0,0,1,1,0],[0,0,0,1,1,1,1,0],[0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,0],[0,0,0,1,1,1,1,0],[0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0]],[[0,1,1,0,0,0,0,0],[0,1,1,1,1,0,0,0],[0,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,1,1,1,1,0,0,0],[0,1,1,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,1,1,1,1,1],[0,0,1,0,0,1,0,0],[0,1,0,1,1,1,1,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,0,1,0],[0,1,0,0,0,1,1,0],[0,0,1,1,1,1,1,1],[0,0,0,1,1,1,1,1]],[[1,1,1,1,1,1,1,1],[0,1,1,0,1,1,0,0],[1,1,0,1,0,1,0,1],[1,1,0,1,0,1,0,0],[1,1,0,0,0,1,0,1],[1,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1]],[[1,1,1,1,1,0,0,0],[1,1,0,0,0,1,0,0],[0,1,1,0,1,1,1,0],[1,1,1,0,1,1,1,0],[0,1,1,0,1,1,1,0],[0,1,1,0,1,1,1,0],[1,1,1,1,1,1,0,0],[1,1,1,1,1,0,0,0]],[[0,0,1,1,1,1,0,0],[0,1,0,0,0,1,1,0],[1,1,0,1,1,0,1,1],[1,1,0,0,0,1,1,1],[1,1,0,1,1,0,1,1],[1,1,0,1,1,0,1,1],[0,1,0,0,0,1,1,0],[0,0,1,1,1,1,0,0]],[[0,0,0,0,0,0,0,0],[0,1,1,0,0,0,0,0],[1,0,0,0,1,0,1,1],[1,0,0,1,0,1,1,0],[1,0,0,1,0,1,1,1],[0,1,1,0,1,0,1,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,0,1,1,1,0,1],[1,1,0,1,1,0,1,1],[0,0,1,0,1,1,0,1],[0,0,1,0,1,0,1,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,1,1,0,1,0,1,1],[1,0,0,0,1,0,1,0],[1,0,1,0,1,1,1,0],[0,1,1,0,1,0,1,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,1,1,1],[0,0,0,0,1,0,1,0],[1,1,0,1,0,1,0,1],[1,0,0,1,0,1,0,0],[1,0,0,1,0,1,0,1],[1,0,0,0,1,0,1,0],[0,0,0,0,0,1,1,1],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[1,0,0,1,1,0,0,0],[0,1,0,0,0,1,0,1],[0,1,0,0,1,0,0,1],[0,1,0,1,0,0,0,1],[1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[1,0,0,1,1,0,0,1],[0,1,0,0,0,1,0,1],[0,1,0,0,1,0,0,1],[0,1,0,1,0,0,0,1],[1,0,0,1,1,1,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]]],"colorAttributes":[[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]],"uuid":1614297313500.2754}]}}},"palettes":{"version":2,"data":[{"label":"palette_1","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"30","rgb":[252,252,252]},{"hex":"10","rgb":[188,188,188]},{"hex":"00","rgb":[124,124,124]}],"uuid":1614402310360.6956},{"label":"palette_2","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"29","rgb":[184,248,24]},{"hex":"19","rgb":[0,184,0]},{"hex":"0B","rgb":[0,88,0]}],"uuid":1614402310360.5},{"label":"palette_3","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"31","rgb":[164,228,252]},{"hex":"1C","rgb":[0,136,136]},{"hex":"0C","rgb":[0,64,88]}],"uuid":1614402310360.5212},{"label":"palette_4","colors":[{"hex":"0F","rgb":[0,0,0]},{"hex":"36","rgb":[240,208,176]},{"hex":"17","rgb":[228,92,16]},{"hex":"07","rgb":[136,20,0]}],"uuid":1614402310361.7444}]},"tilemaps":{"version":1,"data":{"layers":[]}}}
  `);
    }

    /* src\_components\header\Navigation.svelte generated by Svelte v3.31.2 */
    const file$L = "src\\_components\\header\\Navigation.svelte";

    // (57:8) {#if globalThis.electron}
    function create_if_block$h(ctx) {
    	let li;
    	let button;
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			span = element("span");
    			span.textContent = "quit";
    			add_location(span, file$L, 57, 86, 2411);
    			attr_dev(button, "href", "/");
    			add_location(button, file$L, 57, 14, 2339);
    			attr_dev(li, "class", "svelte-wz8iyp");
    			add_location(li, file$L, 57, 10, 2335);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, span);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_4*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(57:8) {#if globalThis.electron}",
    		ctx
    	});

    	return block;
    }

    // (84:10) <ExternalLink href="https://discord.gg/7mCVKnkjHc">
    function create_default_slot$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Join discord community");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(84:10) <ExternalLink href=\\\"https://discord.gg/7mCVKnkjHc\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let nav;
    	let ul3;
    	let li4;
    	let span0;
    	let t1;
    	let ul0;
    	let li0;
    	let button0;
    	let span1;
    	let t3;
    	let li1;
    	let button1;
    	let span2;
    	let t5;
    	let li2;
    	let button2;
    	let span3;
    	let t7;
    	let li3;
    	let button3;
    	let span4;
    	let t9;
    	let t10;
    	let li5;
    	let span5;
    	let t12;
    	let li6;
    	let span6;
    	let t14;
    	let li8;
    	let span7;
    	let t16;
    	let ul1;
    	let li7;
    	let button4;
    	let span8;
    	let t18;
    	let li12;
    	let span9;
    	let t20;
    	let ul2;
    	let li9;
    	let button5;
    	let t22;
    	let li10;
    	let button6;
    	let t24;
    	let li11;
    	let externallink;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = globalThis.electron && create_if_block$h(ctx);

    	externallink = new ExternalLinkButton({
    			props: {
    				href: "https://discord.gg/7mCVKnkjHc",
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			ul3 = element("ul");
    			li4 = element("li");
    			span0 = element("span");
    			span0.textContent = "file";
    			t1 = space();
    			ul0 = element("ul");
    			li0 = element("li");
    			button0 = element("button");
    			span1 = element("span");
    			span1.textContent = "new project";
    			t3 = space();
    			li1 = element("li");
    			button1 = element("button");
    			span2 = element("span");
    			span2.textContent = "open";
    			t5 = space();
    			li2 = element("li");
    			button2 = element("button");
    			span3 = element("span");
    			span3.textContent = "save";
    			t7 = space();
    			li3 = element("li");
    			button3 = element("button");
    			span4 = element("span");
    			span4.textContent = "save as";
    			t9 = space();
    			if (if_block) if_block.c();
    			t10 = space();
    			li5 = element("li");
    			span5 = element("span");
    			span5.textContent = "edit";
    			t12 = space();
    			li6 = element("li");
    			span6 = element("span");
    			span6.textContent = "build";
    			t14 = space();
    			li8 = element("li");
    			span7 = element("span");
    			span7.textContent = "window";
    			t16 = space();
    			ul1 = element("ul");
    			li7 = element("li");
    			button4 = element("button");
    			span8 = element("span");
    			span8.textContent = "toggle fullscreen";
    			t18 = space();
    			li12 = element("li");
    			span9 = element("span");
    			span9.textContent = "help";
    			t20 = space();
    			ul2 = element("ul");
    			li9 = element("li");
    			button5 = element("button");
    			button5.textContent = "Documentation";
    			t22 = space();
    			li10 = element("li");
    			button6 = element("button");
    			button6.textContent = "Support";
    			t24 = space();
    			li11 = element("li");
    			create_component(externallink.$$.fragment);
    			add_location(span0, file$L, 50, 6, 1716);
    			add_location(span1, file$L, 52, 101, 1848);
    			attr_dev(button0, "href", "/");
    			add_location(button0, file$L, 52, 12, 1759);
    			attr_dev(li0, "class", "svelte-wz8iyp");
    			add_location(li0, file$L, 52, 8, 1755);
    			add_location(span2, file$L, 53, 99, 1987);
    			attr_dev(button1, "href", "/");
    			add_location(button1, file$L, 53, 12, 1900);
    			attr_dev(li1, "class", "svelte-wz8iyp");
    			add_location(li1, file$L, 53, 8, 1896);
    			add_location(span3, file$L, 54, 99, 2119);
    			attr_dev(button2, "href", "/");
    			add_location(button2, file$L, 54, 12, 2032);
    			attr_dev(li2, "class", "svelte-wz8iyp");
    			add_location(li2, file$L, 54, 8, 2028);
    			add_location(span4, file$L, 55, 102, 2254);
    			attr_dev(button3, "href", "/");
    			add_location(button3, file$L, 55, 12, 2164);
    			attr_dev(li3, "class", "svelte-wz8iyp");
    			add_location(li3, file$L, 55, 8, 2160);
    			attr_dev(ul0, "class", "svelte-wz8iyp");
    			add_location(ul0, file$L, 51, 6, 1741);
    			attr_dev(li4, "class", "svelte-wz8iyp");
    			toggle_class(li4, "show", false);
    			add_location(li4, file$L, 49, 4, 1685);
    			add_location(span5, file$L, 62, 6, 2499);
    			attr_dev(li5, "class", "svelte-wz8iyp");
    			add_location(li5, file$L, 61, 4, 2487);
    			add_location(span6, file$L, 65, 6, 2545);
    			attr_dev(li6, "class", "svelte-wz8iyp");
    			add_location(li6, file$L, 64, 4, 2533);
    			add_location(span7, file$L, 68, 6, 2592);
    			add_location(span8, file$L, 70, 111, 2736);
    			attr_dev(button4, "href", "/");
    			add_location(button4, file$L, 70, 12, 2637);
    			attr_dev(li7, "class", "svelte-wz8iyp");
    			add_location(li7, file$L, 70, 8, 2633);
    			attr_dev(ul1, "class", "svelte-wz8iyp");
    			add_location(ul1, file$L, 69, 6, 2619);
    			attr_dev(li8, "class", "svelte-wz8iyp");
    			add_location(li8, file$L, 67, 4, 2580);
    			add_location(span9, file$L, 74, 6, 2822);
    			attr_dev(button5, "href", "/documentation");
    			add_location(button5, file$L, 77, 10, 2877);
    			attr_dev(li9, "class", "svelte-wz8iyp");
    			add_location(li9, file$L, 76, 8, 2861);
    			attr_dev(button6, "href", "/support");
    			add_location(button6, file$L, 80, 10, 2979);
    			attr_dev(li10, "class", "svelte-wz8iyp");
    			add_location(li10, file$L, 79, 8, 2963);
    			attr_dev(li11, "class", "svelte-wz8iyp");
    			add_location(li11, file$L, 82, 8, 3053);
    			attr_dev(ul2, "class", "svelte-wz8iyp");
    			add_location(ul2, file$L, 75, 6, 2847);
    			attr_dev(li12, "class", "svelte-wz8iyp");
    			add_location(li12, file$L, 73, 4, 2810);
    			attr_dev(ul3, "id", "filemenu");
    			attr_dev(ul3, "class", "svelte-wz8iyp");
    			add_location(ul3, file$L, 48, 2, 1661);
    			attr_dev(nav, "id", "main-nav");
    			attr_dev(nav, "class", "no-drag");
    			add_location(nav, file$L, 47, 0, 1622);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, ul3);
    			append_dev(ul3, li4);
    			append_dev(li4, span0);
    			append_dev(li4, t1);
    			append_dev(li4, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, button0);
    			append_dev(button0, span1);
    			append_dev(ul0, t3);
    			append_dev(ul0, li1);
    			append_dev(li1, button1);
    			append_dev(button1, span2);
    			append_dev(ul0, t5);
    			append_dev(ul0, li2);
    			append_dev(li2, button2);
    			append_dev(button2, span3);
    			append_dev(ul0, t7);
    			append_dev(ul0, li3);
    			append_dev(li3, button3);
    			append_dev(button3, span4);
    			append_dev(ul0, t9);
    			if (if_block) if_block.m(ul0, null);
    			append_dev(ul3, t10);
    			append_dev(ul3, li5);
    			append_dev(li5, span5);
    			append_dev(ul3, t12);
    			append_dev(ul3, li6);
    			append_dev(li6, span6);
    			append_dev(ul3, t14);
    			append_dev(ul3, li8);
    			append_dev(li8, span7);
    			append_dev(li8, t16);
    			append_dev(li8, ul1);
    			append_dev(ul1, li7);
    			append_dev(li7, button4);
    			append_dev(button4, span8);
    			append_dev(ul3, t18);
    			append_dev(ul3, li12);
    			append_dev(li12, span9);
    			append_dev(li12, t20);
    			append_dev(li12, ul2);
    			append_dev(ul2, li9);
    			append_dev(li9, button5);
    			append_dev(ul2, t22);
    			append_dev(ul2, li10);
    			append_dev(li10, button6);
    			append_dev(ul2, t24);
    			append_dev(ul2, li11);
    			mount_component(externallink, li11, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", prevent_default(/*click_handler*/ ctx[0]), false, true, false),
    					listen_dev(button1, "click", prevent_default(/*click_handler_1*/ ctx[1]), false, true, false),
    					listen_dev(button2, "click", prevent_default(/*click_handler_2*/ ctx[2]), false, true, false),
    					listen_dev(button3, "click", prevent_default(/*click_handler_3*/ ctx[3]), false, true, false),
    					listen_dev(button4, "click", prevent_default(/*click_handler_5*/ ctx[5]), false, true, false),
    					action_destroyer(link.call(null, button5)),
    					action_destroyer(link.call(null, button6))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (globalThis.electron) if_block.p(ctx, dirty);
    			const externallink_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				externallink_changes.$$scope = { dirty, ctx };
    			}

    			externallink.$set(externallink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(externallink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(externallink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			if (if_block) if_block.d();
    			destroy_component(externallink);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Navigation", slots, []);
    	let isActive = false;
    	let topLevelElements = [];

    	const clearActive = e => {
    		topLevelElements.forEach(_ => _.classList.remove("show"));
    		isActive = false;
    	};

    	window.addEventListener("click", clearActive);

    	// toplevel handlers
    	const toplevelClickHandler = e => {
    		e.stopPropagation();

    		// NOTE: this will toggle active menu and close menu if a sublink is clicked as well
    		isActive = !isActive;

    		e.currentTarget.classList.toggle("show");
    	};

    	const toplevelOverHandler = e => {
    		topLevelElements.forEach(_ => _.classList.remove("show"));

    		if (isActive) {
    			e.currentTarget.classList.add("show");
    		}
    	};

    	onMount(() => {
    		// top level menu
    		topLevelElements = document.querySelectorAll("nav > ul > li");

    		topLevelElements.forEach(li => li.addEventListener("click", toplevelClickHandler));
    		topLevelElements.forEach(li => li.addEventListener("mouseover", toplevelOverHandler));
    	});

    	onDestroy(() => {
    		// clear active 
    		window.removeEventListener("click", clearActive);

    		// clear toplevel
    		topLevelElements.forEach(li => li.removeEventListener("click", toplevelClickHandler));

    		topLevelElements.forEach(li => li.removeEventListener("mouseover", toplevelOverHandler));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Navigation> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => actions.execute("project_create");
    	const click_handler_1 = _ => actions.execute("project_open");
    	const click_handler_2 = _ => actions.execute("project_save");
    	const click_handler_3 = _ => actions.execute("project_save_as");
    	const click_handler_4 = _ => actions.execute(`window_close`);
    	const click_handler_5 = _ => actions.execute("window_toggle_fullscreen");

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		link,
    		ActionsManager: actions,
    		ExternalLink: ExternalLinkButton,
    		isActive,
    		topLevelElements,
    		clearActive,
    		toplevelClickHandler,
    		toplevelOverHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) isActive = $$props.isActive;
    		if ("topLevelElements" in $$props) topLevelElements = $$props.topLevelElements;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5
    	];
    }

    class Navigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navigation",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    /* src\_singles\buttons\AreaButton.svelte generated by Svelte v3.31.2 */
    const file$M = "src\\_singles\\buttons\\AreaButton.svelte";

    function create_fragment$U(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", "no-drag svelte-1j6abr5");
    			toggle_class(button, "active", /*active*/ ctx[1]);
    			add_location(button, file$M, 15, 0, 292);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			/*button_binding*/ ctx[7](button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			if (dirty & /*active*/ 2) {
    				toggle_class(button, "active", /*active*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			/*button_binding*/ ctx[7](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let active;
    	let $location;
    	validate_store(location$1, "location");
    	component_subscribe($$self, location$1, $$value => $$invalidate(4, $location = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AreaButton", slots, ['default']);
    	let { area = null } = $$props;
    	let _self;

    	const click = _ => {
    		if (area) {
    			navigate("/" + area);
    		}
    	};

    	const writable_props = ["area"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AreaButton> was created with unknown prop '${key}'`);
    	});

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			_self = $$value;
    			$$invalidate(0, _self);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("area" in $$props) $$invalidate(3, area = $$props.area);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		navigate,
    		location: location$1,
    		area,
    		_self,
    		click,
    		active,
    		$location
    	});

    	$$self.$inject_state = $$props => {
    		if ("area" in $$props) $$invalidate(3, area = $$props.area);
    		if ("_self" in $$props) $$invalidate(0, _self = $$props._self);
    		if ("active" in $$props) $$invalidate(1, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$location, area*/ 24) {
    			// update active state
    			 $$invalidate(1, active = $location.startsWith(`/${area}`));
    		}
    	};

    	return [_self, active, click, area, $location, $$scope, slots, button_binding];
    }

    class AreaButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, { area: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AreaButton",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get area() {
    		throw new Error("<AreaButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set area(value) {
    		throw new Error("<AreaButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\_components\header\SectionNavigation.svelte generated by Svelte v3.31.2 */
    const file$N = "src\\_components\\header\\SectionNavigation.svelte";

    // (8:2) {#if application.isDev}
    function create_if_block_2(ctx) {
    	let li;
    	let areabutton;
    	let current;

    	areabutton = new AreaButton({
    			props: {
    				area: "game",
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(areabutton.$$.fragment);
    			attr_dev(li, "class", "svelte-1bhpuaq");
    			add_location(li, file$N, 8, 4, 260);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(areabutton, li, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(areabutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(areabutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(areabutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(8:2) {#if application.isDev}",
    		ctx
    	});

    	return block;
    }

    // (10:6) <AreaButton area="game">
    function create_default_slot_4$5(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M6 2l1.171.203c-.355 2.245.791 2.519 2.699 2.874 1.468.273 3.13.622 3.13 3.284v.639h-1.183v-.639c0-1.556-.48-1.809-2.164-2.122-2.583-.48-4.096-1.391-3.653-4.239zm18 14c0 3.312-2.607 6-5.825 6-1.511 0-2.886-.595-3.921-1.565-1.311-1.229-3.278-1.132-4.55.038-1.03.948-2.389 1.527-3.879 1.527-3.217 0-5.825-2.688-5.825-6s2.608-6 5.825-6l12.563.007c3.118.116 5.612 2.755 5.612 5.993zm-15-1h-2v-2h-2v2h-2v2h2v2h2v-2h2v-2zm4 1h-2v1h2v-1zm4-2c0 .552.447 1 1 1s1-.448 1-1-.447-1-1-1-1 .448-1 1zm0 2c0-.552-.447-1-1-1s-1 .448-1 1 .447 1 1 1 1-.448 1-1zm2 2c0-.552-.447-1-1-1s-1 .448-1 1 .447 1 1 1 1-.448 1-1zm2-2c0-.552-.447-1-1-1s-1 .448-1 1 .447 1 1 1 1-.448 1-1z");
    			add_location(path, file$N, 10, 91, 389);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-1bhpuaq");
    			add_location(svg, file$N, 10, 8, 306);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(10:6) <AreaButton area=\\\"game\\\">",
    		ctx
    	});

    	return block;
    }

    // (16:4) <AreaButton area="graphics">
    function create_default_slot_3$5(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M0 21.398c5.504.456 3.533-5.392 8.626-5.445l2.206 1.841c.549 6.645-7.579 8.127-10.832 3.604zm16.878-8.538c1.713-2.687 7.016-11.698 7.016-11.698.423-.747-.515-1.528-1.17-.976 0 0-7.887 6.857-10.213 9.03-1.838 1.719-1.846 2.504-2.441 5.336l2.016 1.681c2.67-1.098 3.439-1.248 4.792-3.373z");
    			add_location(path, file$N, 16, 89, 1237);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-1bhpuaq");
    			add_location(svg, file$N, 16, 6, 1154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(16:4) <AreaButton area=\\\"graphics\\\">",
    		ctx
    	});

    	return block;
    }

    // (20:2) {#if application.isDev}
    function create_if_block_1$3(ctx) {
    	let li0;
    	let areabutton0;
    	let t;
    	let li1;
    	let areabutton1;
    	let current;

    	areabutton0 = new AreaButton({
    			props: {
    				area: "audio",
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	areabutton1 = new AreaButton({
    			props: {
    				area: "code",
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li0 = element("li");
    			create_component(areabutton0.$$.fragment);
    			t = space();
    			li1 = element("li");
    			create_component(areabutton1.$$.fragment);
    			attr_dev(li0, "class", "svelte-1bhpuaq");
    			add_location(li0, file$N, 20, 4, 1601);
    			attr_dev(li1, "class", "svelte-1bhpuaq");
    			add_location(li1, file$N, 25, 4, 1993);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li0, anchor);
    			mount_component(areabutton0, li0, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, li1, anchor);
    			mount_component(areabutton1, li1, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(areabutton0.$$.fragment, local);
    			transition_in(areabutton1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(areabutton0.$$.fragment, local);
    			transition_out(areabutton1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li0);
    			destroy_component(areabutton0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(li1);
    			destroy_component(areabutton1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(20:2) {#if application.isDev}",
    		ctx
    	});

    	return block;
    }

    // (22:6) <AreaButton area="audio">
    function create_default_slot_2$8(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M13 0h-2v15.676c-3.379-.667-7 1.915-7 4.731 0 2.367 1.881 3.593 3.919 3.593 2.423 0 5.077-1.728 5.081-5.24v-12.76c3.009 2.223 5.623 3.243 5.059 7 1.431-1.727 1.941-2.817 1.941-4.051 0-4.446-7-5.915-7-8.949z");
    			add_location(path, file$N, 22, 91, 1731);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-1bhpuaq");
    			add_location(svg, file$N, 22, 8, 1648);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(22:6) <AreaButton area=\\\"audio\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:6) <AreaButton area="code">
    function create_default_slot_1$d(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M23 10.826v2.349c-1.562 0-3 1.312-3 2.857 0 2.181 1.281 5.968-6 5.968v-2.002c4.917 0 3.966-1.6 3.966-3.967 0-2.094 1.211-3.5 2.278-4.031-1.067-.531-2.278-1.438-2.278-3.312 0-2.372.94-4.692-3.966-4.686v-2.002c7.285 0 6 4.506 6 6.688 0 1.544 1.438 2.138 3 2.138zm-19-2.138c0-2.182-1.285-6.688 6-6.688v2.002c-4.906-.007-3.966 2.313-3.966 4.686 0 1.875-1.211 2.781-2.278 3.312 1.067.531 2.278 1.938 2.278 4.031 0 2.367-.951 3.967 3.966 3.967v2.002c-7.281 0-6-3.787-6-5.969 0-1.545-1.438-2.857-3-2.857v-2.349c1.562.001 3-.593 3-2.137z");
    			add_location(path, file$N, 27, 91, 2122);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-1bhpuaq");
    			add_location(svg, file$N, 27, 8, 2039);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(27:6) <AreaButton area=\\\"code\\\">",
    		ctx
    	});

    	return block;
    }

    // (32:2) {#if globalThis.electron}
    function create_if_block$i(ctx) {
    	let li;
    	let areabutton;
    	let current;
    	let mounted;
    	let dispose;

    	areabutton = new AreaButton({
    			props: {
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(areabutton.$$.fragment);
    			attr_dev(li, "class", "last svelte-1bhpuaq");
    			add_location(li, file$N, 32, 4, 2745);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(areabutton, li, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(li, "click", /*click_handler*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const areabutton_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				areabutton_changes.$$scope = { dirty, ctx };
    			}

    			areabutton.$set(areabutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(areabutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(areabutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(areabutton);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(32:2) {#if globalThis.electron}",
    		ctx
    	});

    	return block;
    }

    // (34:6) <AreaButton>
    function create_default_slot$n(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M24 19h-1v-2.2c-1.853 4.237-6.083 7.2-11 7.2-6.623 0-12-5.377-12-12h1c0 6.071 4.929 11 11 11 4.66 0 8.647-2.904 10.249-7h-2.249v-1h4v4zm-11.036 0h-1.886c-.34-.957-.437-1.571-1.177-1.878h-.001c-.743-.308-1.251.061-2.162.494l-1.333-1.333c.427-.899.804-1.415.494-2.163-.308-.74-.926-.839-1.878-1.177v-1.886c.954-.339 1.57-.437 1.878-1.178.308-.743-.06-1.248-.494-2.162l1.333-1.333c.918.436 1.421.801 2.162.494l.001-.001c.74-.307.838-.924 1.177-1.877h1.886c.34.958.437 1.57 1.177 1.877l.001.001c.743.308 1.252-.062 2.162-.494l1.333 1.333c-.435.917-.801 1.421-.494 2.161v.001c.307.739.915.835 1.878 1.178v1.886c-.953.338-1.571.437-1.878 1.178-.308.743.06 1.249.494 2.162l-1.333 1.333c-.92-.438-1.42-.802-2.157-.496-.746.31-.844.926-1.183 1.88zm-.943-4.667c-1.289 0-2.333-1.044-2.333-2.333 0-1.289 1.044-2.334 2.333-2.334 1.289 0 2.333 1.045 2.333 2.334 0 1.289-1.044 2.333-2.333 2.333zm-8.021-5.333h-4v-4h1v2.2c1.853-4.237 6.083-7.2 11-7.2 6.623 0 12 5.377 12 12h-1c0-6.071-4.929-11-11-11-4.66 0-8.647 2.904-10.249 7h2.249v1z");
    			add_location(path, file$N, 34, 131, 2975);
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "fill-rule", "evenodd");
    			attr_dev(svg, "clip-rule", "evenodd");
    			attr_dev(svg, "class", "svelte-1bhpuaq");
    			add_location(svg, file$N, 34, 8, 2852);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(34:6) <AreaButton>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let ul;
    	let t0;
    	let li;
    	let areabutton;
    	let t1;
    	let t2;
    	let current;
    	let if_block0 = application.isDev && create_if_block_2(ctx);

    	areabutton = new AreaButton({
    			props: {
    				area: "graphics",
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block1 = application.isDev && create_if_block_1$3(ctx);
    	let if_block2 = globalThis.electron && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			li = element("li");
    			create_component(areabutton.$$.fragment);
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(li, "class", "svelte-1bhpuaq");
    			add_location(li, file$N, 14, 2, 1108);
    			attr_dev(ul, "class", "area svelte-1bhpuaq");
    			add_location(ul, file$N, 6, 0, 210);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			if (if_block0) if_block0.m(ul, null);
    			append_dev(ul, t0);
    			append_dev(ul, li);
    			mount_component(areabutton, li, null);
    			append_dev(ul, t1);
    			if (if_block1) if_block1.m(ul, null);
    			append_dev(ul, t2);
    			if (if_block2) if_block2.m(ul, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const areabutton_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				areabutton_changes.$$scope = { dirty, ctx };
    			}

    			areabutton.$set(areabutton_changes);
    			if (globalThis.electron) if_block2.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(areabutton.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(areabutton.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (if_block0) if_block0.d();
    			destroy_component(areabutton);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SectionNavigation", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SectionNavigation> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => actions.execute("project_build_run");
    	$$self.$capture_state = () => ({ AreaButton, ActionsManager: actions, application });
    	return [click_handler];
    }

    class SectionNavigation$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SectionNavigation",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* src\_components\header\WindowButtons.svelte generated by Svelte v3.31.2 */
    const file$O = "src\\_components\\header\\WindowButtons.svelte";

    function create_fragment$W(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			t0 = space();
    			button1 = element("button");
    			t1 = space();
    			button2 = element("button");
    			attr_dev(button0, "class", "minimize svelte-188xc0");
    			add_location(button0, file$O, 5, 0, 166);
    			attr_dev(button1, "class", "maximize svelte-188xc0");
    			add_location(button1, file$O, 6, 0, 243);
    			attr_dev(button2, "class", "close svelte-188xc0");
    			add_location(button2, file$O, 7, 0, 320);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button2, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WindowButtons", slots, []);
    	const windowCommand = command => actions.execute(`window_${command}`);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WindowButtons> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => windowCommand("minimize");
    	const click_handler_1 = _ => windowCommand("maximize");
    	const click_handler_2 = _ => windowCommand("close");
    	$$self.$capture_state = () => ({ ActionsManager: actions, windowCommand });
    	return [windowCommand, click_handler, click_handler_1, click_handler_2];
    }

    class WindowButtons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WindowButtons",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    /* src\_components\header\Header.svelte generated by Svelte v3.31.2 */
    const file$P = "src\\_components\\header\\Header.svelte";

    function create_fragment$X(ctx) {
    	let header;
    	let div0;
    	let t0;
    	let div4;
    	let div1;
    	let t1;
    	let span;
    	let t2_value = (/*projectName*/ ctx[0] || "not saved *") + "";
    	let t2;
    	let t3;
    	let t4;
    	let div2;
    	let filemenu;
    	let t5;
    	let sectionnavigation;
    	let t6;
    	let div3;
    	let windowbuttons;
    	let current;
    	filemenu = new Navigation({ $$inline: true });
    	sectionnavigation = new SectionNavigation$2({ $$inline: true });
    	windowbuttons = new WindowButtons({ $$inline: true });

    	const block = {
    		c: function create() {
    			header = element("header");
    			div0 = element("div");
    			t0 = space();
    			div4 = element("div");
    			div1 = element("div");
    			t1 = text("[");
    			span = element("span");
    			t2 = text(t2_value);
    			t3 = text("]");
    			t4 = space();
    			div2 = element("div");
    			create_component(filemenu.$$.fragment);
    			t5 = space();
    			create_component(sectionnavigation.$$.fragment);
    			t6 = space();
    			div3 = element("div");
    			create_component(windowbuttons.$$.fragment);
    			attr_dev(div0, "class", "drag app-region svelte-2xhiq2");
    			add_location(div0, file$P, 12, 2, 432);
    			attr_dev(span, "class", "no-paint svelte-2xhiq2");
    			add_location(span, file$P, 15, 7, 527);
    			attr_dev(div1, "class", "titlebar svelte-2xhiq2");
    			add_location(div1, file$P, 14, 4, 496);
    			attr_dev(div2, "id", "top-navigation");
    			attr_dev(div2, "class", "svelte-2xhiq2");
    			add_location(div2, file$P, 17, 4, 606);
    			attr_dev(div3, "id", "window-buttons");
    			attr_dev(div3, "class", "svelte-2xhiq2");
    			add_location(div3, file$P, 23, 4, 749);
    			attr_dev(div4, "class", "inner svelte-2xhiq2");
    			add_location(div4, file$P, 13, 2, 471);
    			attr_dev(header, "id", "masthead");
    			attr_dev(header, "class", "svelte-2xhiq2");
    			add_location(header, file$P, 11, 0, 406);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			append_dev(header, div0);
    			append_dev(header, t0);
    			append_dev(header, div4);
    			append_dev(div4, div1);
    			append_dev(div1, t1);
    			append_dev(div1, span);
    			append_dev(span, t2);
    			append_dev(div1, t3);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			mount_component(filemenu, div2, null);
    			append_dev(div2, t5);
    			mount_component(sectionnavigation, div2, null);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			mount_component(windowbuttons, div3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*projectName*/ 1) && t2_value !== (t2_value = (/*projectName*/ ctx[0] || "not saved *") + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filemenu.$$.fragment, local);
    			transition_in(sectionnavigation.$$.fragment, local);
    			transition_in(windowbuttons.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filemenu.$$.fragment, local);
    			transition_out(sectionnavigation.$$.fragment, local);
    			transition_out(windowbuttons.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			destroy_component(filemenu);
    			destroy_component(sectionnavigation);
    			destroy_component(windowbuttons);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let projectName;
    	let $Project;
    	validate_store(Project, "Project");
    	component_subscribe($$self, Project, $$value => $$invalidate(1, $Project = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Header", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Filemenu: Navigation,
    		SectionNavigation: SectionNavigation$2,
    		WindowButtons,
    		Project,
    		basename,
    		projectName,
    		$Project
    	});

    	$$self.$inject_state = $$props => {
    		if ("projectName" in $$props) $$invalidate(0, projectName = $$props.projectName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$Project*/ 2) {
    			 $$invalidate(0, projectName = basename($Project.path || ""));
    		}
    	};

    	return [projectName, $Project];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    /* src\_components\console.svelte generated by Svelte v3.31.2 */
    const file$Q = "src\\_components\\console.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i].error;
    	child_ctx[5] = list[i].date;
    	return child_ctx;
    }

    // (25:4) {#if error}
    function create_if_block$j(ctx) {
    	let li;
    	let t0;
    	let t1_value = /*date*/ ctx[5] + "";
    	let t1;
    	let t2;
    	let t3_value = /*error*/ ctx[4].message + "";
    	let t3;
    	let t4;
    	let div;
    	let t6;

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text("[");
    			t1 = text(t1_value);
    			t2 = text("] ( ");
    			t3 = text(t3_value);
    			t4 = text(" )\r\n        ");
    			div = element("div");
    			div.textContent = "some extra hidden details";
    			t6 = space();
    			attr_dev(div, "class", "details svelte-8fmup");
    			add_location(div, file$Q, 27, 8, 582);
    			attr_dev(li, "class", "svelte-8fmup");
    			add_location(li, file$Q, 25, 6, 530);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(li, t2);
    			append_dev(li, t3);
    			append_dev(li, t4);
    			append_dev(li, div);
    			append_dev(li, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errors*/ 2 && t1_value !== (t1_value = /*date*/ ctx[5] + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*errors*/ 2 && t3_value !== (t3_value = /*error*/ ctx[4].message + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(25:4) {#if error}",
    		ctx
    	});

    	return block;
    }

    // (24:2) {#each errors as { error, date }}
    function create_each_block$d(ctx) {
    	let if_block_anchor;
    	let if_block = /*error*/ ctx[4] && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*error*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(24:2) {#each errors as { error, date }}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let ul;
    	let each_value = /*errors*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-8fmup");
    			add_location(ul, file$Q, 22, 0, 444);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			/*ul_binding*/ ctx[2](ul);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*errors*/ 2) {
    				each_value = /*errors*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			/*ul_binding*/ ctx[2](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Console", slots, []);
    	let element;
    	let errors = [];

    	const unsubscribe = log.subscribe(async store => {
    		$$invalidate(1, errors = [...store]);
    		await tick();

    		if (element) {
    			element.scrollTo({
    				top: 1000000000,
    				left: 0,
    				behavior: "smooth"
    			});
    		}
    	});

    	onDestroy(() => {
    		unsubscribe();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Console> was created with unknown prop '${key}'`);
    	});

    	function ul_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			element = $$value;
    			$$invalidate(0, element);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onDestroy,
    		tick,
    		log,
    		element,
    		errors,
    		unsubscribe
    	});

    	$$self.$inject_state = $$props => {
    		if ("element" in $$props) $$invalidate(0, element = $$props.element);
    		if ("errors" in $$props) $$invalidate(1, errors = $$props.errors);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [element, errors, ul_binding];
    }

    class Console extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Console",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    /* src\_components\Footer.svelte generated by Svelte v3.31.2 */

    const { console: console_1$1 } = globals;
    const file$R = "src\\_components\\Footer.svelte";

    function create_fragment$Z(ctx) {
    	let footer;
    	let console;
    	let current;
    	console = new Console({ $$inline: true });

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			create_component(console.$$.fragment);
    			attr_dev(footer, "class", "footer svelte-zj1pup");
    			add_location(footer, file$R, 4, 0, 80);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);
    			mount_component(console, footer, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(console.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(console.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			destroy_component(console);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Footer", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Console });
    	return [];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$Z.name
    		});
    	}
    }

    /* src\_components\Popup.svelte generated by Svelte v3.31.2 */
    const file$S = "src\\_components\\Popup.svelte";

    // (7:0) {#if $store && $store.component}
    function create_if_block$k(ctx) {
    	let previous_key = /*$store*/ ctx[0].component;
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$6(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$store*/ 1 && safe_not_equal(previous_key, previous_key = /*$store*/ ctx[0].component)) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$6(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(7:0) {#if $store && $store.component}",
    		ctx
    	});

    	return block;
    }

    // (8:2) {#key $store.component}
    function create_key_block$6(ctx) {
    	let section;
    	let div1;
    	let button;
    	let svg;
    	let path;
    	let t;
    	let div0;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	const switch_instance_spread_levels = [/*$store*/ ctx[0].props];
    	var switch_value = /*$store*/ ctx[0].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			section = element("section");
    			div1 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t = space();
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(path, "d", "M23.954 21.03l-9.184-9.095 9.092-9.174-2.832-2.807-9.09 9.179-9.176-9.088-2.81 2.81 9.186 9.105-9.095 9.184 2.81 2.81 9.112-9.192 9.18 9.1z");
    			add_location(path, file$S, 12, 12, 467);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "fill", "white");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$S, 11, 10, 357);
    			attr_dev(button, "class", "svelte-1fughtn");
    			add_location(button, file$S, 10, 8, 306);
    			attr_dev(div0, "class", "content svelte-1fughtn");
    			add_location(div0, file$S, 15, 8, 665);
    			attr_dev(div1, "class", "popup svelte-1fughtn");
    			add_location(div1, file$S, 9, 6, 277);
    			attr_dev(section, "class", "svelte-1fughtn");
    			add_location(section, file$S, 8, 4, 260);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div1);
    			append_dev(div1, button);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$store*/ 1)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*$store*/ ctx[0].props)])
    			: {};

    			if (switch_value !== (switch_value = /*$store*/ ctx[0].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$6.name,
    		type: "key",
    		source: "(8:2) {#key $store.component}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$store*/ ctx[0] && /*$store*/ ctx[0].component && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$store*/ ctx[0] && /*$store*/ ctx[0].component) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$store*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const store = writable();
    const set = (component, props = {}) => store.set({ component, props });

    function instance$_($$self, $$props, $$invalidate) {
    	let $store;
    	validate_store(store, "store");
    	component_subscribe($$self, store, $$value => $$invalidate(0, $store = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Popup", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Popup> was created with unknown prop '${key}'`);
    	});

    	const click_handler = _ => set(undefined);
    	$$self.$capture_state = () => ({ writable, store, set, $store });
    	return [$store, click_handler];
    }

    class Popup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Popup",
    			options,
    			id: create_fragment$_.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.31.2 */
    const file$T = "src\\App.svelte";

    function create_fragment$$(ctx) {
    	let div;
    	let header;
    	let t0;
    	let main;
    	let router;
    	let t1;
    	let footer;
    	let t2;
    	let modalwindow;
    	let t3;
    	let popup;
    	let t4;
    	let toastnotifications;
    	let current;
    	header = new Header({ $$inline: true });
    	router = new Router_1({ $$inline: true });
    	footer = new Footer({ $$inline: true });
    	modalwindow = new ModalWindow({ $$inline: true });
    	popup = new Popup({ $$inline: true });
    	toastnotifications = new ToastNotifications({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(header.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(router.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    			t2 = space();
    			create_component(modalwindow.$$.fragment);
    			t3 = space();
    			create_component(popup.$$.fragment);
    			t4 = space();
    			create_component(toastnotifications.$$.fragment);
    			attr_dev(main, "class", "svelte-4azgf7");
    			add_location(main, file$T, 18, 2, 584);
    			attr_dev(div, "id", "app");
    			add_location(div, file$T, 16, 0, 554);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(header, div, null);
    			append_dev(div, t0);
    			append_dev(div, main);
    			mount_component(router, main, null);
    			append_dev(div, t1);
    			mount_component(footer, div, null);
    			insert_dev(target, t2, anchor);
    			mount_component(modalwindow, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(popup, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(toastnotifications, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			transition_in(modalwindow.$$.fragment, local);
    			transition_in(popup.$$.fragment, local);
    			transition_in(toastnotifications.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			transition_out(modalwindow.$$.fragment, local);
    			transition_out(popup.$$.fragment, local);
    			transition_out(toastnotifications.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(header);
    			destroy_component(router);
    			destroy_component(footer);
    			if (detaching) detach_dev(t2);
    			destroy_component(modalwindow, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(popup, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(toastnotifications, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);

    	if (!globalThis.electron && !application.isDev) {
    		set(Support);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Router: Router_1,
    		Header,
    		Footer,
    		ToastNotifications,
    		Popup,
    		set,
    		Support,
    		application,
    		ModalWindow
    	});

    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$$.name
    		});
    	}
    }

    /* src\Init.svelte generated by Svelte v3.31.2 */

    const { document: document_1 } = globals;
    const file$U = "src\\Init.svelte";

    function create_fragment$10(ctx) {
    	let title_value;
    	let meta;
    	let t;
    	let app;
    	let current;
    	document_1.title = title_value = "[" + (/*projectName*/ ctx[0] || "not saved *") + "]";
    	const app_spread_levels = [/*$$props*/ ctx[1]];
    	let app_props = {};

    	for (let i = 0; i < app_spread_levels.length; i += 1) {
    		app_props = assign(app_props, app_spread_levels[i]);
    	}

    	app = new App({ props: app_props, $$inline: true });

    	const block = {
    		c: function create() {
    			meta = element("meta");
    			t = space();
    			create_component(app.$$.fragment);
    			attr_dev(meta, "http-equiv", "Content-Security-Policy");
    			attr_dev(meta, "content", "script-src 'self'");
    			add_location(meta, file$U, 37, 2, 1487);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1.head, meta);
    			insert_dev(target, t, anchor);
    			mount_component(app, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*projectName*/ 1) && title_value !== (title_value = "[" + (/*projectName*/ ctx[0] || "not saved *") + "]")) {
    				document_1.title = title_value;
    			}

    			const app_changes = (dirty & /*$$props*/ 2)
    			? get_spread_update(app_spread_levels, [get_spread_object(/*$$props*/ ctx[1])])
    			: {};

    			app.$set(app_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(app.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(app.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(meta);
    			if (detaching) detach_dev(t);
    			destroy_component(app, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let projectName;
    	let $location;
    	let $Project;
    	validate_store(location$1, "location");
    	component_subscribe($$self, location$1, $$value => $$invalidate(3, $location = $$value));
    	validate_store(Project, "Project");
    	component_subscribe($$self, Project, $$value => $$invalidate(2, $Project = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Init", slots, []);

    	if (globalThis.electron) {
    		// if we are in electron context add a class to the body element
    		// of electron to be able to distinguish between webapp and electron
    		document.body.classList.add("electron");

    		// we only want to redirect on an electron application
    		// this only if you need to get the correct location of the startup page 
    		// since the initial pathname is the filepath to the local file and not '/' as we expect.
    		redirect("/");
    	}

    	// force entry at startPage during development
    	onMount(async () => {
    		// wait tick just to be sure things have been properly executed
    		await tick();

    		if (application.startPage !== $location) {
    			redirect(application.startPage);
    		}
    	});

    	$$self.$$set = $$new_props => {
    		$$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		redirect,
    		location: location$1,
    		Project,
    		application,
    		basename,
    		App,
    		$location,
    		projectName,
    		$Project
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(1, $$props = assign(assign({}, $$props), $$new_props));
    		if ("projectName" in $$props) $$invalidate(0, projectName = $$new_props.projectName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$Project*/ 4) {
    			 $$invalidate(0, projectName = basename($Project.path || ""));
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [projectName, $$props, $Project];
    }

    class Init extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Init",
    			options,
    			id: create_fragment$10.name
    		});
    	}
    }

    /* src\Adblock.svelte generated by Svelte v3.31.2 */

    const file$V = "src\\Adblock.svelte";

    function create_fragment$11(ctx) {
    	let section;
    	let article;
    	let h3;
    	let t1;
    	let p;

    	const block = {
    		c: function create() {
    			section = element("section");
    			article = element("article");
    			h3 = element("h3");
    			h3.textContent = "This online version of NESBit Studio relies on ad-monetization to be able to continue to operate";
    			t1 = space();
    			p = element("p");
    			p.textContent = "We know, we know. Intrusive ads sucks! We do our best to keep it out of your way and experience using this tool.";
    			add_location(h3, file$V, 2, 4, 46);
    			add_location(p, file$V, 3, 4, 157);
    			attr_dev(article, "class", "svelte-weu28o");
    			add_location(article, file$V, 1, 2, 31);
    			attr_dev(section, "class", "checkered svelte-weu28o");
    			add_location(section, file$V, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, article);
    			append_dev(article, h3);
    			append_dev(article, t1);
    			append_dev(article, p);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Adblock", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Adblock> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Adblock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Adblock",
    			options,
    			id: create_fragment$11.name
    		});
    	}
    }

    // shift depending on if adblock or not
    let component = window.not_adblocked ? Init : Adblock;

    const app$1 = new component({
      target: document.querySelector('body')
    });

    return app$1;

}());
//# sourceMappingURL=bundle.js.map
